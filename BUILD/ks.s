;
; File generated by cc65 v 2.18 - Git 5b56c6e
;
	.fopt		compiler,"cc65 v 2.18 - Git 5b56c6e"
	.setcpu		"6502"
	.smart		on
	.autoimport	on
	.case		on
	.debuginfo	off
	.importzp	sp, sreg, regsave, regbank
	.importzp	tmp1, tmp2, tmp3, tmp4, ptr1, ptr2, ptr3, ptr4
	.macpack	longbranch
	.forceimport	__STARTUP__
	.import		_pal_bg
	.import		_pal_spr
	.import		_pal_col
	.import		_ppu_wait_nmi
	.import		_ppu_off
	.import		_ppu_on_all
	.import		_oam_clear
	.import		_oam_spr
	.import		_oam_meta_spr
	.import		_music_play
	.import		_music_stop
	.import		_sfx_play
	.import		_pad_poll
	.import		_bank_spr
	.import		_rand8
	.import		_set_rand
	.import		_vram_adr
	.import		_vram_put
	.import		_delay
	.import		_set_vram_buffer
	.import		_one_vram_buffer
	.import		_multi_vram_buffer_horz
	.import		_clear_vram_buffer
	.import		_get_pad_new
	.import		_get_frame_count
	.import		_pal_fade_to
	.export		_title_palette_bg
	.export		_title_palette_sp
	.export		_game_palette_bg
	.export		_game_palette_sp
	.export		_upgrade_palette_bg
	.export		_upgrade_palette_sp
	.export		_upgrade_cost
	.export		_BlueSpr
	.export		_CURSOR
	.export		_LOGO
	.export		_STATUS_BAR
	.export		_SCYTHE_STATE
	.export		_OTM_R
	.export		_OTM_RC_1
	.export		_OTM_RC_2
	.export		_OTM_RC_3
	.export		_OTM_L
	.export		_initial_pallete
	.export		_abilities_icons
	.export		_set_breakpoint
	.export		_tasm
	.export		_d
	.export		_d2
	.export		_nmi_wait_and_prepare
	.export		_clear_screen
	.export		_fade_in
	.export		_fade_out
	.export		_delay_with_state_skip
	.export		_put_str
	.export		_put_char
	.export		_put_number
	.export		_game_initial_values_set
	.export		_game_process_next_level
	.export		_game_grass_grow
	.export		_game_grass_cf_prepare
	.export		_game_grass_cf_finalize
	.export		_game_grass_fading
	.export		_game_grass_overgrow
	.export		_game_grass_cut
	.export		_game_check_for_extra_point
	.export		_game_draw_rain
	.export		_game_draw_sprites
	.export		_game_draw_background
	.export		_game_draw_time
	.export		_game_draw_points
	.export		_game_draw_effects
	.export		_game_movement_and_actions
	.export		_game_check_specials_keys
	.export		_game_small_scythe_processing
	.export		_game_create_enemy
	.export		_game_enemy_processing
	.export		_upgrade_draw_sprites
	.export		_upgrade_draw_background
	.export		_upgrade_movement_and_actions
	.export		_upgrade_draw_desc
	.export		_upgrade_draw_icon
	.export		_upgrade_recalc_ability_cost
	.export		_upgrade_show_ablity_desc
	.export		_upgrade_show_current_points
	.export		_title_draw_background
	.export		_title_draw_options
	.export		_title_draw_menu
	.export		_title_check_cheat_code
	.export		_process_title
	.export		_process_upgrades
	.export		_process_main_game
	.export		_process_end_game_string_print
	.export		_process_game_win
	.export		_process_game_end
	.export		_pad1
	.export		_pad1_new
	.export		_pad2
	.export		_tmp
	.export		_state
	.export		_index
	.export		_marker
	.export		_x
	.export		_y
	.export		_adr
	.export		_frame_tick
	.export		_rain_delay
	.export		_rain_drop_x
	.export		_rain_drop_y
	.export		_grass
	.export		_debug
	.export		_points
	.export		_score
	.export		_game_calc_state
	.export		_bird_x
	.export		_bird_y
	.export		_bird_sprite
	.export		_bird_state
	.export		_bird_health
	.export		_bird_tag
	.export		_bird_speed_delay
	.export		_bird_x_speed
	.export		_bird_pallete
	.export		_player
	.export		_small_scythe
	.export		_game
	.export		_set_bg_pallete
	.export		_main

.segment	"DATA"

_rain_delay:
	.byte	$06
_grass:
	.byte	$00
	.byte	$14
	.byte	$01
	.byte	$12
	.res	32,$00
_debug:
	.byte	$00
_points:
	.byte	$00
_score:
	.word	$0000
_game_calc_state:
	.byte	$00
_player:
	.byte	$20
	.byte	$8C
	.byte	$20
	.byte	$40
	.byte	$00
	.byte	$02
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$01
	.byte	$02
	.byte	$00
	.byte	$0A
	.byte	$0A
	.byte	$00
	.res	1,$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
_small_scythe:
	.byte	$00
	.byte	$00
	.byte	$10
	.byte	$08
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$03
_game:
	.byte	$01
	.byte	$0C
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$0A
	.byte	$00
	.byte	$03
	.byte	$00
	.byte	$01
	.byte	$00

.segment	"RODATA"

_title_palette_bg:
	.byte	$0F
	.byte	$0F
	.byte	$21
	.byte	$20
	.byte	$0F
	.byte	$01
	.byte	$21
	.byte	$20
	.byte	$0F
	.byte	$0F
	.byte	$08
	.byte	$0A
	.byte	$0F
	.byte	$00
	.byte	$09
	.byte	$0A
_title_palette_sp:
	.byte	$0F
	.byte	$13
	.byte	$23
	.byte	$03
	.byte	$0F
	.byte	$13
	.byte	$23
	.byte	$03
	.byte	$0F
	.byte	$12
	.byte	$22
	.byte	$03
	.byte	$0F
	.byte	$00
	.byte	$00
	.byte	$00
_game_palette_bg:
	.byte	$0C
	.byte	$0E
	.byte	$06
	.byte	$1B
	.byte	$0C
	.byte	$01
	.byte	$21
	.byte	$20
	.byte	$0C
	.byte	$0F
	.byte	$08
	.byte	$0A
	.byte	$0F
	.byte	$00
	.byte	$09
	.byte	$0A
_game_palette_sp:
	.byte	$0C
	.byte	$00
	.byte	$0F
	.byte	$30
	.byte	$0C
	.byte	$0F
	.byte	$0F
	.byte	$10
	.byte	$0C
	.byte	$01
	.byte	$21
	.byte	$31
	.byte	$0C
	.byte	$00
	.byte	$00
	.byte	$00
_upgrade_palette_bg:
	.byte	$0C
	.byte	$0F
	.byte	$10
	.byte	$30
	.byte	$0C
	.byte	$01
	.byte	$21
	.byte	$20
	.byte	$0C
	.byte	$0F
	.byte	$08
	.byte	$0A
	.byte	$0C
	.byte	$00
	.byte	$09
	.byte	$0A
_upgrade_palette_sp:
	.byte	$0C
	.byte	$00
	.byte	$0F
	.byte	$30
	.byte	$0C
	.byte	$0F
	.byte	$0F
	.byte	$10
	.byte	$0C
	.byte	$01
	.byte	$21
	.byte	$31
	.byte	$0C
	.byte	$00
	.byte	$00
	.byte	$00
_upgrade_cost:
	.byte	$03
	.byte	$05
	.byte	$07
	.byte	$08
	.byte	$09
	.byte	$03
	.byte	$03
	.byte	$05
	.byte	$05
	.byte	$09
	.byte	$03
	.byte	$04
	.byte	$05
	.byte	$07
	.byte	$09
	.byte	$01
	.byte	$02
	.byte	$03
	.byte	$04
	.byte	$09
	.byte	$01
	.byte	$03
	.byte	$05
	.byte	$07
	.byte	$09
_BlueSpr:
	.byte	$00
	.byte	$00
	.byte	$50
	.byte	$01
	.byte	$00
	.byte	$08
	.byte	$60
	.byte	$01
	.byte	$08
	.byte	$00
	.byte	$50
	.byte	$41
	.byte	$08
	.byte	$08
	.byte	$60
	.byte	$41
	.byte	$80
_CURSOR:
	.byte	$00
	.byte	$00
	.byte	$14
	.byte	$02
	.byte	$00
	.byte	$0D
	.byte	$14
	.byte	$82
	.byte	$0C
	.byte	$00
	.byte	$14
	.byte	$42
	.byte	$0C
	.byte	$0D
	.byte	$14
	.byte	$C2
	.byte	$80
_LOGO:
	.byte	$20
	.byte	$08
	.byte	$08
	.byte	$01
	.byte	$40
	.byte	$08
	.byte	$08
	.byte	$41
	.byte	$40
	.byte	$18
	.byte	$0D
	.byte	$41
	.byte	$18
	.byte	$18
	.byte	$0A
	.byte	$01
	.byte	$20
	.byte	$20
	.byte	$09
	.byte	$01
	.byte	$40
	.byte	$30
	.byte	$07
	.byte	$01
	.byte	$58
	.byte	$18
	.byte	$0D
	.byte	$01
	.byte	$20
	.byte	$30
	.byte	$06
	.byte	$C1
	.byte	$48
	.byte	$20
	.byte	$06
	.byte	$41
	.byte	$50
	.byte	$20
	.byte	$06
	.byte	$01
	.byte	$38
	.byte	$08
	.byte	$0A
	.byte	$01
	.byte	$10
	.byte	$20
	.byte	$09
	.byte	$01
	.byte	$10
	.byte	$18
	.byte	$06
	.byte	$01
	.byte	$48
	.byte	$28
	.byte	$06
	.byte	$81
	.byte	$30
	.byte	$18
	.byte	$09
	.byte	$01
	.byte	$58
	.byte	$28
	.byte	$09
	.byte	$01
	.byte	$40
	.byte	$28
	.byte	$09
	.byte	$01
	.byte	$30
	.byte	$08
	.byte	$0B
	.byte	$01
	.byte	$58
	.byte	$30
	.byte	$07
	.byte	$01
	.byte	$40
	.byte	$20
	.byte	$0C
	.byte	$01
	.byte	$30
	.byte	$28
	.byte	$07
	.byte	$01
	.byte	$20
	.byte	$18
	.byte	$06
	.byte	$41
	.byte	$10
	.byte	$30
	.byte	$06
	.byte	$81
	.byte	$10
	.byte	$28
	.byte	$09
	.byte	$01
	.byte	$50
	.byte	$28
	.byte	$06
	.byte	$C1
	.byte	$18
	.byte	$30
	.byte	$0A
	.byte	$01
	.byte	$20
	.byte	$28
	.byte	$09
	.byte	$01
	.byte	$58
	.byte	$20
	.byte	$0C
	.byte	$41
	.byte	$30
	.byte	$10
	.byte	$09
	.byte	$01
	.byte	$28
	.byte	$08
	.byte	$0A
	.byte	$01
	.byte	$30
	.byte	$20
	.byte	$09
	.byte	$01
_STATUS_BAR:
	.byte	$00
	.byte	$A7
	.byte	$2F
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$A9
	.byte	$2F
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$A8
	.byte	$00
	.byte	$30
	.byte	$30
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$AA
	.byte	$00
	.byte	$00
	.byte	$AB
_SCYTHE_STATE:
	.byte	$00
	.byte	$00
	.byte	$70
	.byte	$00
	.byte	$08
	.byte	$00
	.byte	$71
	.byte	$00
	.byte	$00
	.byte	$08
	.byte	$72
	.byte	$00
	.byte	$08
	.byte	$08
	.byte	$73
	.byte	$00
	.byte	$80
	.byte	$00
	.byte	$00
	.byte	$74
	.byte	$00
	.byte	$08
	.byte	$00
	.byte	$75
	.byte	$00
	.byte	$00
	.byte	$08
	.byte	$0F
	.byte	$00
	.byte	$08
	.byte	$08
	.byte	$76
	.byte	$00
	.byte	$80
	.byte	$00
	.byte	$00
	.byte	$77
	.byte	$00
	.byte	$08
	.byte	$00
	.byte	$78
	.byte	$00
	.byte	$00
	.byte	$08
	.byte	$79
	.byte	$00
	.byte	$08
	.byte	$08
	.byte	$7A
	.byte	$00
	.byte	$80
	.byte	$00
	.byte	$00
	.byte	$7F
	.byte	$00
	.byte	$08
	.byte	$00
	.byte	$7B
	.byte	$00
	.byte	$00
	.byte	$08
	.byte	$7C
	.byte	$00
	.byte	$08
	.byte	$08
	.byte	$7D
	.byte	$00
	.byte	$80
	.byte	$00
	.byte	$00
	.byte	$73
	.byte	$C0
	.byte	$08
	.byte	$00
	.byte	$72
	.byte	$C0
	.byte	$00
	.byte	$08
	.byte	$71
	.byte	$C0
	.byte	$08
	.byte	$08
	.byte	$70
	.byte	$C0
	.byte	$80
	.byte	$00
	.byte	$00
	.byte	$76
	.byte	$C0
	.byte	$08
	.byte	$00
	.byte	$0F
	.byte	$C0
	.byte	$00
	.byte	$08
	.byte	$75
	.byte	$C0
	.byte	$08
	.byte	$08
	.byte	$74
	.byte	$C0
	.byte	$80
	.byte	$00
	.byte	$00
	.byte	$7A
	.byte	$C0
	.byte	$08
	.byte	$00
	.byte	$79
	.byte	$C0
	.byte	$00
	.byte	$08
	.byte	$78
	.byte	$C0
	.byte	$08
	.byte	$08
	.byte	$77
	.byte	$C0
	.byte	$80
	.byte	$00
	.byte	$00
	.byte	$7D
	.byte	$C0
	.byte	$08
	.byte	$00
	.byte	$7C
	.byte	$C0
	.byte	$00
	.byte	$08
	.byte	$7B
	.byte	$C0
	.byte	$08
	.byte	$08
	.byte	$0F
	.byte	$C0
	.byte	$80
_OTM_R:
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$20
	.byte	$00
	.byte	$08
	.byte	$10
	.byte	$20
	.byte	$00
	.byte	$10
	.byte	$20
	.byte	$20
	.byte	$00
	.byte	$18
	.byte	$30
	.byte	$20
	.byte	$08
	.byte	$00
	.byte	$01
	.byte	$20
	.byte	$08
	.byte	$08
	.byte	$11
	.byte	$20
	.byte	$08
	.byte	$10
	.byte	$21
	.byte	$20
	.byte	$08
	.byte	$18
	.byte	$31
	.byte	$20
	.byte	$08
	.byte	$20
	.byte	$41
	.byte	$20
	.byte	$08
	.byte	$28
	.byte	$51
	.byte	$20
	.byte	$08
	.byte	$30
	.byte	$61
	.byte	$20
	.byte	$10
	.byte	$00
	.byte	$02
	.byte	$20
	.byte	$10
	.byte	$08
	.byte	$12
	.byte	$20
	.byte	$10
	.byte	$10
	.byte	$22
	.byte	$20
	.byte	$10
	.byte	$18
	.byte	$32
	.byte	$20
	.byte	$10
	.byte	$20
	.byte	$42
	.byte	$20
	.byte	$10
	.byte	$28
	.byte	$52
	.byte	$20
	.byte	$10
	.byte	$30
	.byte	$62
	.byte	$20
	.byte	$18
	.byte	$00
	.byte	$03
	.byte	$20
	.byte	$18
	.byte	$08
	.byte	$13
	.byte	$20
	.byte	$18
	.byte	$10
	.byte	$23
	.byte	$20
	.byte	$18
	.byte	$18
	.byte	$33
	.byte	$20
	.byte	$18
	.byte	$20
	.byte	$43
	.byte	$20
	.byte	$18
	.byte	$28
	.byte	$53
	.byte	$20
	.byte	$18
	.byte	$30
	.byte	$63
	.byte	$20
	.byte	$80
_OTM_RC_1:
	.byte	$00
	.byte	$18
	.byte	$B0
	.byte	$20
	.byte	$00
	.byte	$20
	.byte	$C0
	.byte	$20
	.byte	$08
	.byte	$10
	.byte	$A1
	.byte	$20
	.byte	$08
	.byte	$18
	.byte	$B1
	.byte	$20
	.byte	$10
	.byte	$08
	.byte	$92
	.byte	$20
	.byte	$10
	.byte	$10
	.byte	$A2
	.byte	$20
	.byte	$10
	.byte	$18
	.byte	$B2
	.byte	$20
	.byte	$10
	.byte	$20
	.byte	$C2
	.byte	$20
	.byte	$10
	.byte	$28
	.byte	$D2
	.byte	$20
	.byte	$10
	.byte	$30
	.byte	$E2
	.byte	$20
	.byte	$18
	.byte	$00
	.byte	$83
	.byte	$20
	.byte	$18
	.byte	$08
	.byte	$93
	.byte	$20
	.byte	$18
	.byte	$10
	.byte	$A3
	.byte	$20
	.byte	$18
	.byte	$18
	.byte	$B3
	.byte	$20
	.byte	$18
	.byte	$20
	.byte	$C3
	.byte	$20
	.byte	$18
	.byte	$28
	.byte	$D3
	.byte	$20
	.byte	$18
	.byte	$30
	.byte	$E3
	.byte	$20
	.byte	$20
	.byte	$00
	.byte	$84
	.byte	$20
	.byte	$20
	.byte	$08
	.byte	$94
	.byte	$20
	.byte	$20
	.byte	$10
	.byte	$A4
	.byte	$20
	.byte	$20
	.byte	$18
	.byte	$B4
	.byte	$20
	.byte	$20
	.byte	$20
	.byte	$C4
	.byte	$20
	.byte	$20
	.byte	$28
	.byte	$D4
	.byte	$20
	.byte	$20
	.byte	$30
	.byte	$E4
	.byte	$20
	.byte	$80
_OTM_RC_2:
	.byte	$00
	.byte	$28
	.byte	$D5
	.byte	$20
	.byte	$00
	.byte	$30
	.byte	$E5
	.byte	$20
	.byte	$08
	.byte	$08
	.byte	$96
	.byte	$20
	.byte	$08
	.byte	$10
	.byte	$A6
	.byte	$20
	.byte	$08
	.byte	$18
	.byte	$B6
	.byte	$20
	.byte	$08
	.byte	$20
	.byte	$C6
	.byte	$20
	.byte	$08
	.byte	$28
	.byte	$D6
	.byte	$20
	.byte	$08
	.byte	$30
	.byte	$E6
	.byte	$20
	.byte	$10
	.byte	$00
	.byte	$87
	.byte	$20
	.byte	$10
	.byte	$08
	.byte	$97
	.byte	$20
	.byte	$10
	.byte	$10
	.byte	$A7
	.byte	$20
	.byte	$10
	.byte	$18
	.byte	$B7
	.byte	$20
	.byte	$10
	.byte	$20
	.byte	$C7
	.byte	$20
	.byte	$10
	.byte	$28
	.byte	$D7
	.byte	$20
	.byte	$10
	.byte	$30
	.byte	$E7
	.byte	$20
	.byte	$18
	.byte	$00
	.byte	$88
	.byte	$20
	.byte	$18
	.byte	$08
	.byte	$98
	.byte	$20
	.byte	$18
	.byte	$10
	.byte	$A8
	.byte	$20
	.byte	$18
	.byte	$18
	.byte	$B8
	.byte	$20
	.byte	$18
	.byte	$20
	.byte	$C8
	.byte	$20
	.byte	$18
	.byte	$28
	.byte	$D8
	.byte	$20
	.byte	$18
	.byte	$30
	.byte	$E8
	.byte	$20
	.byte	$80
_OTM_RC_3:
	.byte	$00
	.byte	$08
	.byte	$9A
	.byte	$20
	.byte	$00
	.byte	$10
	.byte	$AA
	.byte	$20
	.byte	$00
	.byte	$18
	.byte	$BA
	.byte	$20
	.byte	$00
	.byte	$20
	.byte	$CA
	.byte	$20
	.byte	$00
	.byte	$28
	.byte	$DA
	.byte	$20
	.byte	$00
	.byte	$30
	.byte	$EA
	.byte	$20
	.byte	$08
	.byte	$00
	.byte	$8B
	.byte	$20
	.byte	$08
	.byte	$08
	.byte	$9B
	.byte	$20
	.byte	$08
	.byte	$10
	.byte	$AB
	.byte	$20
	.byte	$08
	.byte	$18
	.byte	$BB
	.byte	$20
	.byte	$08
	.byte	$20
	.byte	$CB
	.byte	$20
	.byte	$08
	.byte	$28
	.byte	$DB
	.byte	$20
	.byte	$08
	.byte	$30
	.byte	$EB
	.byte	$20
	.byte	$10
	.byte	$00
	.byte	$8C
	.byte	$20
	.byte	$10
	.byte	$08
	.byte	$9C
	.byte	$20
	.byte	$10
	.byte	$10
	.byte	$AC
	.byte	$20
	.byte	$10
	.byte	$18
	.byte	$BC
	.byte	$20
	.byte	$10
	.byte	$20
	.byte	$CC
	.byte	$20
	.byte	$10
	.byte	$28
	.byte	$DC
	.byte	$20
	.byte	$10
	.byte	$30
	.byte	$EC
	.byte	$20
	.byte	$18
	.byte	$18
	.byte	$BD
	.byte	$20
	.byte	$18
	.byte	$20
	.byte	$CD
	.byte	$20
	.byte	$18
	.byte	$28
	.byte	$DD
	.byte	$20
	.byte	$80
_OTM_L:
	.byte	$18
	.byte	$00
	.byte	$00
	.byte	$60
	.byte	$18
	.byte	$08
	.byte	$10
	.byte	$60
	.byte	$18
	.byte	$10
	.byte	$20
	.byte	$60
	.byte	$18
	.byte	$18
	.byte	$30
	.byte	$60
	.byte	$10
	.byte	$00
	.byte	$01
	.byte	$60
	.byte	$10
	.byte	$08
	.byte	$11
	.byte	$60
	.byte	$10
	.byte	$10
	.byte	$21
	.byte	$60
	.byte	$10
	.byte	$18
	.byte	$31
	.byte	$60
	.byte	$10
	.byte	$20
	.byte	$41
	.byte	$60
	.byte	$10
	.byte	$28
	.byte	$51
	.byte	$60
	.byte	$10
	.byte	$30
	.byte	$61
	.byte	$60
	.byte	$08
	.byte	$00
	.byte	$02
	.byte	$60
	.byte	$08
	.byte	$08
	.byte	$12
	.byte	$60
	.byte	$08
	.byte	$10
	.byte	$22
	.byte	$60
	.byte	$08
	.byte	$18
	.byte	$32
	.byte	$60
	.byte	$08
	.byte	$20
	.byte	$42
	.byte	$60
	.byte	$08
	.byte	$28
	.byte	$52
	.byte	$60
	.byte	$08
	.byte	$30
	.byte	$62
	.byte	$60
	.byte	$00
	.byte	$00
	.byte	$03
	.byte	$60
	.byte	$00
	.byte	$08
	.byte	$13
	.byte	$60
	.byte	$00
	.byte	$10
	.byte	$23
	.byte	$60
	.byte	$00
	.byte	$18
	.byte	$33
	.byte	$60
	.byte	$00
	.byte	$20
	.byte	$43
	.byte	$60
	.byte	$00
	.byte	$28
	.byte	$53
	.byte	$60
	.byte	$00
	.byte	$30
	.byte	$63
	.byte	$60
	.byte	$80
_initial_pallete:
	.byte	$55
	.byte	$55
	.byte	$55
	.byte	$55
	.byte	$55
	.byte	$55
	.byte	$55
	.byte	$55
	.byte	$55
	.byte	$55
	.byte	$55
	.byte	$55
	.byte	$55
	.byte	$55
	.byte	$55
	.byte	$55
	.byte	$55
	.byte	$55
	.byte	$55
	.byte	$55
	.byte	$55
	.byte	$55
	.byte	$55
	.byte	$55
	.byte	$55
	.byte	$55
	.byte	$55
	.byte	$55
	.byte	$55
	.byte	$55
	.byte	$55
	.byte	$55
	.byte	$FF
	.byte	$FF
	.byte	$FF
	.byte	$FF
	.byte	$FF
	.byte	$FF
	.byte	$FF
	.byte	$FF
	.byte	$FF
	.byte	$FF
	.byte	$FF
	.byte	$FF
	.byte	$FF
	.byte	$FF
	.byte	$FF
	.byte	$FF
	.byte	$AA
	.byte	$AA
	.byte	$AA
	.byte	$AA
	.byte	$AA
	.byte	$AA
	.byte	$AA
	.byte	$AA
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
_abilities_icons:
	.byte	$80
	.byte	$81
	.byte	$90
	.byte	$91
	.byte	$82
	.byte	$83
	.byte	$92
	.byte	$93
	.byte	$84
	.byte	$85
	.byte	$94
	.byte	$95
	.byte	$86
	.byte	$87
	.byte	$96
	.byte	$97
	.byte	$88
	.byte	$89
	.byte	$98
	.byte	$99
L10AB:
	.byte	$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20
	.byte	$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20
	.byte	$00
L103E	:=	L10AB+0
L1032	:=	L10AB+0
L0EA6:
	.byte	$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20
	.byte	$50,$4F,$49,$4E,$54,$53,$20,$20,$20,$20,$00
L0785:
	.byte	$20,$20,$20,$4B,$4F,$53,$41,$52,$49,$20,$43,$4F,$44,$45,$20,$41
	.byte	$43,$54,$49,$56,$41,$54,$45,$44,$20,$20,$00
L076F:
	.byte	$53,$45,$41,$52,$43,$48,$49,$4E,$47,$20,$46,$4F,$52,$20,$41,$4C
	.byte	$54,$45,$52,$4E,$41,$54,$49,$56,$45,$53,$00
L1105:
	.byte	$54,$48,$41,$4E,$4B,$20,$59,$4F,$55,$20,$46,$4F,$52,$20,$50,$4C
	.byte	$41,$59,$49,$4E,$47,$21,$00
L0740:
	.byte	$4B,$4F,$4E,$41,$4D,$49,$20,$43,$4F,$44,$45,$20,$4E,$4F,$54,$20
	.byte	$46,$4F,$55,$4E,$44,$00
L1145:
	.byte	$50,$52,$45,$53,$53,$20,$53,$54,$41,$52,$54,$20,$54,$4F,$20,$52
	.byte	$45,$54,$55,$52,$4E,$00
L0642	:=	L10AB+12
L10D5:
	.byte	$4F,$52,$49,$47,$49,$4E,$41,$4C,$20,$43,$4F,$4D,$49,$43,$53,$20
	.byte	$42,$59,$00
L078F	:=	L10AB+15
L10E5:
	.byte	$53,$50,$45,$43,$49,$41,$4C,$20,$54,$48,$41,$4E,$4B,$53,$20,$54
	.byte	$4F,$00
L0779	:=	L10AB+15
L10BD:
	.byte	$4F,$4E,$45,$20,$54,$48,$4F,$55,$53,$41,$4E,$44,$20,$4D,$41,$4E
	.byte	$00
L06FD	:=	L10BD+0
L10C5:
	.byte	$47,$41,$4D,$45,$20,$43,$52,$45,$41,$54,$45,$44,$20,$42,$59,$00
L0F3E:
	.byte	$20,$41,$43,$54,$49,$56,$41,$54,$45,$44,$20,$20,$20,$20,$00
L0F34:
	.byte	$20,$4D,$4F,$56,$45,$20,$41,$4E,$44,$20,$43,$55,$54,$20,$00
L0EFB:
	.byte	$20,$41,$42,$49,$4C,$49,$54,$49,$45,$53,$20,$20,$20,$20,$00
L0F11:
	.byte	$20,$50,$4F,$57,$45,$52,$20,$53,$4C,$41,$53,$48,$20,$20,$00
L0ECF:
	.byte	$20,$53,$4D,$41,$4C,$4C,$20,$53,$43,$59,$54,$48,$45,$20,$00
L0F05:
	.byte	$20,$50,$4F,$57,$45,$52,$5B,$20,$20,$20,$20,$20,$20,$20,$00
L0ED9:
	.byte	$20,$5C,$20,$5B,$20,$41,$20,$20,$20,$20,$20,$20,$20,$20,$00
L0EEF:
	.byte	$20,$5E,$20,$5E,$20,$4F,$52,$20,$5F,$20,$5F,$20,$20,$20,$00
L0F1B:
	.byte	$20,$5D,$20,$5D,$20,$5D,$20,$20,$20,$20,$20,$20,$20,$20,$00
L0EE5:
	.byte	$20,$44,$41,$53,$48,$20,$20,$20,$20,$20,$20,$20,$20,$20,$00
L10DD:
	.byte	$43,$59,$4E,$49,$43,$20,$4D,$41,$4E,$53,$49,$4F,$4E,$00
L10CD:
	.byte	$53,$50,$45,$52,$4C,$49,$4E,$47,$53,$4B,$41,$55,$5A,$00
L114E:
	.byte	$54,$4F,$20,$4D,$41,$49,$4E,$20,$4D,$45,$4E,$55,$00
L1157:
	.byte	$46,$49,$4E,$41,$4C,$20,$53,$43,$4F,$52,$45,$00
L0FFC:
	.byte	$43,$55,$54,$20,$53,$50,$45,$45,$44,$20,$00
L0FF5:
	.byte	$43,$55,$54,$20,$50,$4F,$57,$45,$52,$20,$00
L0FEE:
	.byte	$43,$55,$54,$20,$57,$49,$44,$54,$48,$20,$00
L100A:
	.byte	$53,$50,$45,$43,$49,$41,$4C,$20,$20,$20,$00
L1003:
	.byte	$4D,$4F,$56,$45,$20,$53,$50,$45,$45,$44,$00
L113C:
	.byte	$47,$41,$4D,$45,$20,$4F,$56,$45,$52,$00
L0669:
	.byte	$4C,$45,$56,$45,$4C,$20,$20,$20,$00
L067D:
	.byte	$46,$4C,$41,$53,$48,$20,$20,$20,$00
L0687:
	.byte	$52,$45,$54,$55,$52,$4E,$20,$20,$00
L0673:
	.byte	$45,$4E,$44,$4C,$45,$53,$53,$20,$00
L10F5:
	.byte	$4E,$45,$53,$44,$4F,$55,$47,$00
L065D:
	.byte	$4F,$50,$54,$49,$4F,$4E,$53,$00
L0623:
	.byte	$4E,$4F,$52,$4D,$41,$4C,$00
L0617:
	.byte	$45,$41,$53,$59,$20,$20,$00
L062F:
	.byte	$48,$41,$52,$44,$20,$20,$00
L08B5	:=	L1157+6
L08C7:
	.byte	$4C,$45,$56,$45,$4C,$00
L05AF	:=	L10AB+27
L10ED:
	.byte	$53,$48,$49,$52,$55,$00
L05AC:
	.byte	$53,$54,$41,$52,$54,$00
L0653	:=	L05AC+0
L0607:
	.byte	$4F,$46,$46,$20,$00
L05F8:
	.byte	$4F,$4E,$20,$00
L05F5:
	.byte	$4F,$46,$46,$00
L0604	:=	L10DD+11
L10FD	:=	L10AB+31
L0F27:
	.byte	$5B,$00

.segment	"BSS"

.segment	"ZEROPAGE"
_pad1:
	.res	1,$00
_pad1_new:
	.res	1,$00
_pad2:
	.res	1,$00
_tmp:
	.res	1,$00
_state:
	.res	1,$00
_index:
	.res	1,$00
_marker:
	.res	1,$00
_x:
	.res	1,$00
_y:
	.res	1,$00
_adr:
	.res	2,$00
_frame_tick:
	.res	1,$00
_rain_drop_x:
	.res	8,$00
_rain_drop_y:
	.res	8,$00
.segment	"BSS"
_bird_x:
	.res	4,$00
_bird_y:
	.res	4,$00
_bird_sprite:
	.res	4,$00
_bird_state:
	.res	4,$00
_bird_health:
	.res	4,$00
_bird_tag:
	.res	4,$00
_bird_speed_delay:
	.res	4,$00
_bird_x_speed:
	.res	4,$00
_bird_pallete:
	.res	4,$00

; ---------------------------------------------------------------
; void __near__ set_breakpoint (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_set_breakpoint: near

.segment	"CODE"

;
; *(unsigned char*)0x00ff=1;
;
	lda     #$01
	sta     $00FF
;
; }
;
	rts

.endproc

; ---------------------------------------------------------------
; void __near__ tasm (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_tasm: near

.segment	"CODE"

;
; }
;
	rts

.endproc

; ---------------------------------------------------------------
; void __near__ d (unsigned int)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_d: near

.segment	"CODE"

;
; void d(unsigned int dt) {
;
	jsr     pushax
;
; one_vram_buffer(CHR_ZERO + dt / 100, NTADR_A(0, 1));
;
	jsr     pushw0sp
	lda     #$64
	jsr     tosudiva0
	clc
	adc     #$30
	jsr     pusha
	ldx     #$20
	txa
	jsr     _one_vram_buffer
;
; one_vram_buffer(CHR_ZERO + dt / 10 % 10, NTADR_A(1, 1));
;
	jsr     pushw0sp
	lda     #$0A
	jsr     tosudiva0
	jsr     pushax
	lda     #$0A
	jsr     tosumoda0
	clc
	adc     #$30
	jsr     pusha
	ldx     #$20
	lda     #$21
	jsr     _one_vram_buffer
;
; one_vram_buffer(CHR_ZERO + dt % 10, NTADR_A(2, 1));
;
	jsr     pushw0sp
	lda     #$0A
	jsr     tosumoda0
	clc
	adc     #$30
	jsr     pusha
	ldx     #$20
	lda     #$22
	jsr     _one_vram_buffer
;
; }
;
	jmp     incsp2

.endproc

; ---------------------------------------------------------------
; void __near__ d2 (unsigned int)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_d2: near

.segment	"CODE"

;
; void d2(unsigned int dt) {
;
	jsr     pushax
;
; one_vram_buffer(CHR_ZERO + dt / 100, NTADR_A(6, 1));
;
	jsr     pushw0sp
	lda     #$64
	jsr     tosudiva0
	clc
	adc     #$30
	jsr     pusha
	ldx     #$20
	lda     #$26
	jsr     _one_vram_buffer
;
; one_vram_buffer(CHR_ZERO + dt / 10 % 10, NTADR_A(7, 1));
;
	jsr     pushw0sp
	lda     #$0A
	jsr     tosudiva0
	jsr     pushax
	lda     #$0A
	jsr     tosumoda0
	clc
	adc     #$30
	jsr     pusha
	ldx     #$20
	lda     #$27
	jsr     _one_vram_buffer
;
; one_vram_buffer(CHR_ZERO + dt % 10, NTADR_A(8, 1));
;
	jsr     pushw0sp
	lda     #$0A
	jsr     tosumoda0
	clc
	adc     #$30
	jsr     pusha
	ldx     #$20
	lda     #$28
	jsr     _one_vram_buffer
;
; }
;
	jmp     incsp2

.endproc

; ---------------------------------------------------------------
; void __near__ nmi_wait_and_prepare (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_nmi_wait_and_prepare: near

.segment	"CODE"

;
; ppu_wait_nmi();
;
	jsr     _ppu_wait_nmi
;
; pad1 = pad_poll(0);
;
	lda     #$00
	jsr     _pad_poll
	sta     _pad1
;
; pad1_new = get_pad_new(0);
;
	lda     #$00
	jsr     _get_pad_new
	sta     _pad1_new
;
; clear_vram_buffer();
;
	jmp     _clear_vram_buffer

.endproc

; ---------------------------------------------------------------
; void __near__ clear_screen (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_clear_screen: near

.segment	"CODE"

;
; clear_vram_buffer();
;
	jsr     _clear_vram_buffer
;
; vram_adr(NAMETABLE_A);
;
	ldx     #$20
	lda     #$00
	jsr     _vram_adr
;
; for(x = 0x00; x != 0x20; ++x) {
;
	lda     #$00
	sta     _x
L118A:	lda     _x
	cmp     #$20
	beq     L048D
;
; for(y = 0x00; y != 0x1D; ++y) {
;
	lda     #$00
	sta     _y
L118B:	lda     _y
	cmp     #$1D
	beq     L118C
;
; vram_put(0x00);
;
	lda     #$00
	jsr     _vram_put
;
; for(y = 0x00; y != 0x1D; ++y) {
;
	inc     _y
	jmp     L118B
;
; for(x = 0x00; x != 0x20; ++x) {
;
L118C:	inc     _x
	jmp     L118A
;
; oam_clear();
;
L048D:	jmp     _oam_clear

.endproc

; ---------------------------------------------------------------
; void __near__ fade_in (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_fade_in: near

.segment	"CODE"

;
; pal_fade_to(5, 0);
;
	lda     #$05
	jsr     pusha
	lda     #$00
	jsr     _pal_fade_to
;
; delay(10);
;
	lda     #$0A
	jmp     _delay

.endproc

; ---------------------------------------------------------------
; void __near__ fade_out (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_fade_out: near

.segment	"CODE"

;
; delay(10);
;
	lda     #$0A
	jsr     _delay
;
; pal_fade_to(0, 4);
;
	lda     #$00
	jsr     pusha
	lda     #$04
	jmp     _pal_fade_to

.endproc

; ---------------------------------------------------------------
; void __near__ delay_with_state_skip (unsigned char)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_delay_with_state_skip: near

.segment	"CODE"

;
; void delay_with_state_skip(unsigned char delay_length) {
;
	jsr     pusha
;
; for(tmp = 1; tmp != delay_length; ++tmp) {
;
	lda     #$01
	sta     _tmp
L04AC:	ldy     #$00
	lda     (sp),y
	cmp     _tmp
	beq     L04AD
;
; nmi_wait_and_prepare();
;
	jsr     _nmi_wait_and_prepare
;
; if (state == 1) break;
;
	lda     _state
	cmp     #$01
	beq     L04AD
;
; if (pad1_new & PAD_START) state = 1;
;
	lda     _pad1_new
	and     #$10
	beq     L118E
	lda     #$01
	sta     _state
;
; for(tmp = 1; tmp != delay_length; ++tmp) {
;
L118E:	inc     _tmp
	jmp     L04AC
;
; }
;
L04AD:	jmp     incsp1

.endproc

; ---------------------------------------------------------------
; void __near__ put_str (unsigned int, __near__ const unsigned char *)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_put_str: near

.segment	"CODE"

;
; void put_str(unsigned int address, const char *str) {
;
	jsr     pushax
;
; vram_adr(address);
;
	ldy     #$03
	lda     (sp),y
	tax
	dey
	lda     (sp),y
	jsr     _vram_adr
;
; if (!*str) break;
;
L04BE:	ldy     #$01
	lda     (sp),y
	sta     ptr1+1
	dey
	lda     (sp),y
	sta     ptr1
	lda     (ptr1),y
	beq     L04BF
;
; vram_put((*str++) - 0x00);
;
	iny
	lda     (sp),y
	tax
	dey
	lda     (sp),y
	sta     regsave
	stx     regsave+1
	clc
	adc     #$01
	bcc     L04C7
	inx
L04C7:	jsr     stax0sp
	ldy     #$00
	lda     (regsave),y
	jsr     _vram_put
;
; while(1) {
;
	jmp     L04BE
;
; } 
;
L04BF:	jmp     incsp4

.endproc

; ---------------------------------------------------------------
; void __near__ put_char (unsigned int, __near__ const unsigned char *, unsigned char)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_put_char: near

.segment	"CODE"

;
; void put_char(unsigned int address, const char *str, unsigned char num) {
;
	jsr     pusha
;
; unsigned char npos = 0;
;
	lda     #$00
	jsr     pusha
;
; if (!*str) break;
;
L04CA:	ldy     #$03
	lda     (sp),y
	sta     ptr1+1
	dey
	lda     (sp),y
	sta     ptr1
	ldy     #$00
	lda     (ptr1),y
	beq     L04CB
;
; if (npos == num) {
;
	lda     (sp),y
	iny
	cmp     (sp),y
	bne     L04D0
;
; one_vram_buffer(*str, address);
;
	ldy     #$03
	lda     (sp),y
	sta     ptr1+1
	dey
	lda     (sp),y
	sta     ptr1
	ldy     #$00
	lda     (ptr1),y
	jsr     pusha
	ldy     #$06
	lda     (sp),y
	tax
	dey
	lda     (sp),y
	jsr     _one_vram_buffer
;
; break;
;
	jmp     incsp6
;
; *str++;
;
L04D0:	ldy     #$03
	lda     (sp),y
	tax
	dey
	lda     (sp),y
	clc
	adc     #$01
	bcc     L04D7
	inx
L04D7:	jsr     staxysp
;
; ++npos;
;
	ldy     #$00
	clc
	lda     #$01
	adc     (sp),y
	sta     (sp),y
;
; while(1) {
;
	jmp     L04CA
;
; } 
;
L04CB:	jmp     incsp6

.endproc

; ---------------------------------------------------------------
; void __near__ put_number (unsigned int, unsigned int, unsigned char)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_put_number: near

.segment	"CODE"

;
; void put_number(unsigned int address, unsigned int number, unsigned char zero_count) {
;
	jsr     pusha
;
; adr = number;
;
	ldy     #$02
	lda     (sp),y
	sta     _adr+1
	dey
	lda     (sp),y
	sta     _adr
;
; x = 0;
;
	lda     #$00
	sta     _x
;
; while(adr != 0) {
;
	jmp     L04E0
;
; ++x;
;
L04DE:	inc     _x
;
; adr /= 10;
;
	lda     _adr
	ldx     _adr+1
	jsr     pushax
	lda     #$0A
	jsr     tosudiva0
	sta     _adr
	stx     _adr+1
;
; while(adr != 0) {
;
L04E0:	lda     _adr
	ora     _adr+1
	bne     L04DE
;
; if(number == 0) {
;
	ldy     #$01
	lda     (sp),y
	iny
	ora     (sp),y
	bne     L04E6
;
; vram_adr(address + 1);
;
	ldy     #$04
	lda     (sp),y
	tax
	dey
	lda     (sp),y
	clc
	adc     #$01
	bcc     L04EB
	inx
L04EB:	jsr     _vram_adr
;
; vram_put(CHR_ZERO);
;
	lda     #$30
	jsr     _vram_put
;
; } else {
;
	jmp     incsp5
;
; for(y = 0x00; y != x; ++y) {
;
L04E6:	lda     #$00
	sta     _y
L1195:	lda     _x
	cmp     _y
	beq     L04F0
;
; adr = number % 10;
;
	ldy     #$04
	jsr     pushwysp
	lda     #$0A
	jsr     tosumoda0
	sta     _adr
	stx     _adr+1
;
; number /= 10;
;
	ldy     #$04
	jsr     pushwysp
	lda     #$0A
	jsr     tosudiva0
	ldy     #$01
	jsr     staxysp
;
; vram_adr(address + x - y);
;
	ldy     #$04
	lda     (sp),y
	tax
	dey
	lda     (sp),y
	clc
	adc     _x
	bcc     L1190
	inx
L1190:	sec
	sbc     _y
	pha
	txa
	sbc     #$00
	tax
	pla
	jsr     _vram_adr
;
; vram_put(CHR_ZERO + adr);
;
	lda     _adr
	clc
	adc     #$30
	jsr     _vram_put
;
; for(y = 0x00; y != x; ++y) {
;
	inc     _y
	jmp     L1195
;
; vram_adr(address + x + 1);
;
L04F0:	ldy     #$04
	lda     (sp),y
	tax
	dey
	lda     (sp),y
	clc
	adc     _x
	bcc     L1194
	inx
	clc
L1194:	adc     #$01
	bcc     L0502
	inx
L0502:	jsr     _vram_adr
;
; for(y = 0x00; y != zero_count; ++y) {
;
	lda     #$00
	sta     _y
L0503:	ldy     #$00
	lda     (sp),y
	cmp     _y
	beq     L0504
;
; vram_put(CHR_ZERO);
;
	lda     #$30
	jsr     _vram_put
;
; for(y = 0x00; y != zero_count; ++y) {
;
	inc     _y
	jmp     L0503
;
; }
;
L0504:	jmp     incsp5

.endproc

; ---------------------------------------------------------------
; void __near__ game_initial_values_set (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_game_initial_values_set: near

.segment	"CODE"

;
; for(x = 0x00; x != RAIN_COUNT; ++x) {
;
	lda     #$00
	sta     _x
L1196:	lda     _x
	cmp     #$08
	beq     L1197
;
; rain_drop_x[x] = 0;
;
	ldy     _x
	lda     #$00
	sta     _rain_drop_x,y
;
; rain_drop_y[x] = 0;
;
	ldy     _x
	sta     _rain_drop_y,y
;
; for(x = 0x00; x != RAIN_COUNT; ++x) {
;
	inc     _x
	jmp     L1196
;
; points = 1;
;
L1197:	lda     #$01
	sta     _points
;
; score = 0;
;
	lda     #$00
	sta     _score
	sta     _score+1
;
; game.level = 1;
;
	lda     #$01
	sta     _game
;
; game.lives = 3;
;
	lda     #$03
	sta     _game+7
;
; player.move_delay = 0; 
;
	lda     #$00
	sta     _player+4
;
; player.move_max_delay = 2;
;
	lda     #$02
	sta     _player+5
;
; player.move_increase = 0;
;
	lda     #$00
	sta     _player+6
;
; player.move_max_increase = 0;
;
	sta     _player+7
;
; player.abilities.selection = 0;
;
	sta     _player+16
;
; player.abilities.list[ABILITY_CUT_SPEED] = 0;
;
	sta     _player+17
;
; player.abilities.list[ABILITY_CUT_POWER] = 0;
;
	sta     _player+18
;
; player.abilities.list[ABILITY_CUT_SIZE] = 0;
;
	sta     _player+19
;
; player.abilities.list[ABILITY_MOVE_SPEED] = 0;
;
	sta     _player+20
;
; player.abilities.elevel = 0;
;
	sta     _player+22
;
; set_vram_buffer(); 
;
	jsr     _set_vram_buffer
;
; ppu_off();
;
	jsr     _ppu_off
;
; bank_spr(1);
;
	lda     #$01
	jsr     _bank_spr
;
; ppu_on_all();
;
	jmp     _ppu_on_all

.endproc

; ---------------------------------------------------------------
; void __near__ game_process_next_level (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_game_process_next_level: near

.segment	"CODE"

;
; fade_in();
;
	jsr     _fade_in
;
; ppu_off();
;
	jsr     _ppu_off
;
; pal_bg(game_palette_bg);
;
	lda     #<(_game_palette_bg)
	ldx     #>(_game_palette_bg)
	jsr     _pal_bg
;
; pal_spr(game_palette_sp);
;
	lda     #<(_game_palette_sp)
	ldx     #>(_game_palette_sp)
	jsr     _pal_spr
;
; clear_vram_buffer();
;
	jsr     _clear_vram_buffer
;
; if (game.state == GAME_ST_LEVEL_END_WIN) {
;
	lda     _game+3
	cmp     #$03
	jne     L11A6
;
; ++game.level;
;
	inc     _game
;
; switch(game.difficulty) {
;
	lda     _game+6
;
; }
;
	beq     L119A
	cmp     #$01
	beq     L119E
	cmp     #$02
	beq     L11A3
	jmp     L11A6
;
; if (grass.delay_max != 10) --grass.delay_max;
;
L119A:	lda     _grass+1
	cmp     #$0A
	beq     L119B
	dec     _grass+1
;
; if (game.level % 3 == 0 && grass.instant_count != 10) ++grass.instant_count;
;
L119B:	lda     _game
	jsr     pusha0
	lda     #$03
	jsr     tosumoda0
	cpx     #$00
	bne     L119D
	cmp     #$00
	bne     L119D
	lda     _grass+2
	cmp     #$0A
	beq     L119D
	inc     _grass+2
;
; if (game.max_play_time != 60) game.max_play_time += 2;
;
L119D:	lda     _game+5
	cmp     #$3C
	beq     L11A6
	lda     #$02
;
; break;
;
	jmp     L11B1
;
; if (grass.delay_max != 8) --grass.delay_max;
;
L119E:	lda     _grass+1
	cmp     #$08
	beq     L119F
	dec     _grass+1
;
; if (game.level % 2 == 0 && grass.instant_count != 10) ++grass.instant_count;
;
L119F:	lda     _game
	and     #$01
	bne     L11A2
	lda     _grass+2
	cmp     #$0A
	beq     L11A2
	inc     _grass+2
;
; if (game.max_play_time != 60) game.max_play_time += 4;
;
L11A2:	lda     _game+5
	cmp     #$3C
	beq     L11A6
	lda     #$04
;
; break;
;
	jmp     L11B1
;
; if (grass.delay_max != 6) --grass.delay_max;
;
L11A3:	lda     _grass+1
	cmp     #$06
	beq     L11A4
	dec     _grass+1
;
; if (grass.instant_count != 10) ++grass.instant_count;
;
L11A4:	lda     _grass+2
	cmp     #$0A
	beq     L11A5
	inc     _grass+2
;
; if (game.max_play_time != 60) game.max_play_time += 6;
;
L11A5:	lda     _game+5
	cmp     #$3C
	beq     L11A6
	lda     #$06
L11B1:	clc
	adc     _game+5
	sta     _game+5
;
; game.play_time = game.max_play_time;
;
L11A6:	lda     _game+5
	sta     _game+4
;
; game.state = GAME_ST_LEVEL_PLAYING;
;
	lda     #$01
	sta     _game+3
;
; grass.delay = grass.delay_max;
;
	lda     _grass+1
	sta     _grass
;
; vram_adr(NAMETABLE_A);
;
	ldx     #$20
	lda     #$00
	jsr     _vram_adr
;
; for(x = 0x00; x != 0x20; ++x) 
;
	lda     #$00
	sta     _x
L11A7:	lda     _x
	cmp     #$20
	beq     L11AA
;
; for(y = 0x00; y != 0x1D; ++y) 
;
	lda     #$00
	sta     _y
L11A8:	lda     _y
	cmp     #$1D
	beq     L11A9
;
; vram_put(CHR_BG_BLANK);
;
	lda     #$7F
	jsr     _vram_put
;
; for(y = 0x00; y != 0x1D; ++y) 
;
	inc     _y
	jmp     L11A8
;
; for(x = 0x00; x != 0x20; ++x) 
;
L11A9:	inc     _x
	jmp     L11A7
;
; for(x = 0x00; x != BIRDS_COUNT; ++x) 
;
L11AA:	lda     #$00
	sta     _x
L11AB:	lda     _x
	cmp     #$04
	beq     L11AC
;
; bird_state[x] = 0;
;
	ldy     _x
	lda     #$00
	sta     _bird_state,y
;
; for(x = 0x00; x != BIRDS_COUNT; ++x) 
;
	inc     _x
	jmp     L11AB
;
; for (x = 0x00; x < RAIN_COUNT; ++x) {
;
L11AC:	lda     #$00
	sta     _x
L11AD:	lda     _x
	cmp     #$08
	bcs     L089F
;
; rain_drop_x[x] = rand8();
;
	lda     #<(_rain_drop_x)
	ldx     #>(_rain_drop_x)
	clc
	adc     _x
	bcc     L08A8
	inx
L08A8:	jsr     pushax
	jsr     _rand8
	ldy     #$00
	jsr     staspidx
;
; rain_drop_y[x] = rand8();
;
	lda     #<(_rain_drop_y)
	ldx     #>(_rain_drop_y)
	clc
	adc     _x
	bcc     L08AC
	inx
L08AC:	jsr     pushax
	jsr     _rand8
	ldy     #$00
	jsr     staspidx
;
; for (x = 0x00; x < RAIN_COUNT; ++x) {
;
	inc     _x
	jmp     L11AD
;
; put_str(NTADR_A(0x0D, 0x09), "SCORE");
;
L089F:	ldx     #$21
	lda     #$2D
	jsr     pushax
	lda     #<(L08B5)
	ldx     #>(L08B5)
	jsr     _put_str
;
; put_number(NTADR_A(0x12, 0x09), score, 2);
;
	jsr     decsp4
	lda     #$32
	ldy     #$02
	sta     (sp),y
	iny
	lda     #$21
	sta     (sp),y
	lda     _score
	ldy     #$00
	sta     (sp),y
	iny
	lda     _score+1
	sta     (sp),y
	lda     #$02
	jsr     _put_number
;
; put_str(NTADR_A(0x0D, 0x0B), "LEVEL");
;
	ldx     #$21
	lda     #$6D
	jsr     pushax
	lda     #<(L08C7)
	ldx     #>(L08C7)
	jsr     _put_str
;
; vram_adr(NTADR_A(0x13, 0x0B));
;
	ldx     #$21
	lda     #$73
	jsr     _vram_adr
;
; if (game.level >= 10) {
;
	lda     _game
	cmp     #$0A
	bcc     L11AE
;
; vram_put(CHR_ZERO + game.level / 10);
;
	lda     _game
	jsr     pusha0
	lda     #$0A
	jsr     tosudiva0
	clc
	adc     #$30
	jsr     _vram_put
;
; vram_put(CHR_ZERO + game.level % 10);
;
	lda     _game
	jsr     pusha0
	lda     #$0A
	jsr     tosumoda0
;
; } else {
;
	jmp     L11B2
;
; vram_put(CHR_ZERO + game.level);
;
L11AE:	lda     _game
L11B2:	clc
	adc     #$30
	jsr     _vram_put
;
; vram_adr(NTADR_A(0x0F, 0x0D));
;
	ldx     #$21
	lda     #$AF
	jsr     _vram_adr
;
; vram_put(CHR_LIVE);
;
	lda     #$A7
	jsr     _vram_put
;
; vram_put(CHR_CROSS);
;
	lda     #$2F
	jsr     _vram_put
;
; vram_put(CHR_ZERO + game.lives);
;
	lda     _game+7
	clc
	adc     #$30
	jsr     _vram_put
;
; oam_clear();
;
	jsr     _oam_clear
;
; ppu_on_all();
;
	jsr     _ppu_on_all
;
; fade_out();
;
	jsr     _fade_out
;
; delay(120);
;
	lda     #$78
	jmp     _delay

.endproc

; ---------------------------------------------------------------
; void __near__ game_grass_grow (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_game_grass_grow: near

.segment	"CODE"

;
; if (game_calc_state == GCS_CHECK) {
;
	lda     _game_calc_state
	cmp     #$01
	jne     L11B8
;
; game_calc_state = GCS_NORMAL;
;
	lda     #$00
	sta     _game_calc_state
;
; total_height = 0;
;
	sta     _adr
	sta     _adr+1
;
; for(x = 0x00; x != 0x20; ++x) total_height += grass.height[x];
;
	sta     _x
L11B5:	lda     _x
	cmp     #$20
	beq     L0A84
	ldy     _x
	lda     _grass+4,y
	clc
	adc     _adr
	sta     _adr
	lda     #$00
	adc     _adr+1
	sta     _adr+1
	inc     _x
	jmp     L11B5
;
; if (total_height > GRASS_SBLOCK * 6) {
;
L0A84:	lda     _adr
	cmp     #$D3
	lda     _adr+1
	sbc     #$00
	bcc     L0A8F
;
; one_vram_buffer(0xA6, NTADR_A(0x1D, Y_EDGE));
;
	lda     #$A6
	jsr     pusha
	ldx     #$23
	lda     #$9D
	jsr     _one_vram_buffer
;
; one_vram_buffer(0x9E + total_height / GRASS_SBLOCK, NTADR_A(0x1E, Y_EDGE));
;
	lda     _adr
	ldx     _adr+1
	jsr     pushax
	lda     #$23
	jsr     tosudiva0
	clc
	adc     #$9E
	jsr     pusha
	ldx     #$23
	lda     #$9E
	jsr     _one_vram_buffer
;
; if (total_height > GRASS_SBLOCK * 8) {
;
	lda     _adr
	cmp     #$19
	lda     _adr+1
	sbc     #$01
	bcc     L0AC3
;
; sfx_play(SND_GAME_LOSE, 0);
;
	lda     #$07
	jsr     pusha
	lda     #$00
	jsr     _sfx_play
;
; game.state = GAME_ST_LEVEL_LOSE;
;
	lda     #$04
	sta     _game+3
;
; player.cut.state = 0;
;
	lda     #$00
	sta     _player+11
;
; --game.lives;
;
	dec     _game+7
;
; } else {
;
	rts
;
; if (total_height > GRASS_SBLOCK * 4) {
;
L0A8F:	lda     _adr
	cmp     #$8D
	lda     _adr+1
	sbc     #$00
	bcc     L0AAD
;
; one_vram_buffer(0xA3, NTADR_A(0x1D, Y_EDGE));
;
	lda     #$A3
	jsr     pusha
	ldx     #$23
	lda     #$9D
	jsr     _one_vram_buffer
;
; one_vram_buffer(total_height > GRASS_SBLOCK * 5 ? 0xA0 : 0x7F, NTADR_A(0x1E, Y_EDGE));
;
	lda     _adr
	cmp     #$B0
	lda     _adr+1
	sbc     #$00
	bcc     L11B6
	lda     #$A0
	jmp     L11B7
L11B6:	lda     #$7F
L11B7:	jsr     pusha
	ldx     #$23
	lda     #$9E
	jmp     _one_vram_buffer
;
; one_vram_buffer(0x9F + total_height / GRASS_SBLOCK, NTADR_A(0x1D, Y_EDGE));
;
L0AAD:	lda     _adr
	ldx     _adr+1
	jsr     pushax
	lda     #$23
	jsr     tosudiva0
	clc
	adc     #$9F
	jsr     pusha
	ldx     #$23
	lda     #$9D
	jsr     _one_vram_buffer
;
; one_vram_buffer(0x7F, NTADR_A(0x1E, Y_EDGE));
;
	lda     #$7F
	jsr     pusha
	ldx     #$23
	lda     #$9E
	jmp     _one_vram_buffer
;
; } else {
;
L0AC3:	rts
;
; --grass.delay;
;
L11B8:	dec     _grass
;
; if (grass.delay == 0x00) {
;
	beq     L11BE
;
; }
;
	rts
;
; game_calc_state = GCS_CHECK;
;
L11BE:	lda     #$01
	sta     _game_calc_state
;
; grass.delay = grass.delay_max;
;
	lda     _grass+1
	sta     _grass
;
; for (y = 0x00; ; ++y) {
;
	lda     #$00
	sta     _y
;
; x = (rand8() >> 3);
;
L0AE0:	jsr     _rand8
	jsr     asrax3
	sta     _x
;
; single_sprout = grass.height[x];
;
	ldy     _x
	lda     _grass+4,y
	sta     _tmp
;
; if (single_sprout != 12) {
;
	cmp     #$0C
	jeq     L11BD
;
; ++single_sprout;
;
	inc     _tmp
;
; if (single_sprout == 5) one_vram_buffer(5, NTADR_A(x, GRASS_BORDER));
;
	lda     _tmp
	cmp     #$05
	bne     L11B9
	jsr     pusha
	lda     _x
	ora     #$E0
	ldx     #$22
	jsr     _one_vram_buffer
;
; if (single_sprout == 9) one_vram_buffer(5, NTADR_A(x, GRASS_BORDER - 1));
;
L11B9:	lda     _tmp
	cmp     #$09
	bne     L11BA
	lda     #$05
	jsr     pusha
	lda     _x
	ora     #$C0
	ldx     #$22
	jsr     _one_vram_buffer
;
; if (single_sprout > 8) index = 2; 
;
L11BA:	lda     _tmp
	cmp     #$09
	bcc     L11BB
	lda     #$02
;
; else if (single_sprout > 4) index = 1; 
;
	jmp     L11B4
L11BB:	lda     _tmp
	cmp     #$05
	lda     #$00
	bcc     L11B4
	lda     #$01
;
; else index = 0;
;
L11B4:	sta     _index
;
; grass.height[x] = single_sprout;
;
	ldy     _x
	lda     _tmp
	sta     _grass+4,y
;
; one_vram_buffer(single_sprout - index * 4, NTADR_A(x, GRASS_BORDER - index));
;
	lda     _tmp
	jsr     pusha0
	lda     _index
	jsr     shlax2
	jsr     tossubax
	jsr     pusha
	lda     #$17
	sec
	sbc     _index
	ldx     #$00
	jsr     shlax4
	stx     tmp1
	asl     a
	rol     tmp1
	sta     ptr1
	lda     _x
	ora     ptr1
	pha
	lda     tmp1
	ora     #$20
	tax
	pla
	jsr     _one_vram_buffer
;
; if (y == grass.instant_count) break;
;
L11BD:	lda     _grass+2
	cmp     _y
	beq     L0ADE
;
; for (y = 0x00; ; ++y) {
;
	inc     _y
	jmp     L0AE0
;
; }
;
L0ADE:	rts

.endproc

; ---------------------------------------------------------------
; void __near__ game_grass_cf_prepare (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_game_grass_cf_prepare: near

.segment	"CODE"

;
; if (single_sprout > 8) index = 2; 
;
	lda     _tmp
	cmp     #$09
	bcc     L11C0
	lda     #$02
;
; else if (single_sprout > 4) index = 1; 
;
	jmp     L11BF
L11C0:	lda     _tmp
	cmp     #$05
	lda     #$00
	bcc     L11BF
	lda     #$01
;
; else index = 0;
;
L11BF:	sta     _index
;
; }
;
	rts

.endproc

; ---------------------------------------------------------------
; void __near__ game_grass_cf_finalize (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_game_grass_cf_finalize: near

.segment	"CODE"

;
; if (index == 2) {
;
	lda     _index
	cmp     #$02
	bne     L11C3
;
; if (single_sprout < 9) one_vram_buffer(0, NTADR_A(x, GRASS_BORDER - 2));
;
	lda     _tmp
	cmp     #$09
	bcs     L11C3
	lda     #$00
	jsr     pusha
	lda     _x
	ora     #$A0
	ldx     #$22
	jsr     _one_vram_buffer
;
; if (index == 1 || index == 2) {
;
L11C3:	lda     _index
	cmp     #$01
	beq     L11C6
	cmp     #$02
	bne     L11C7
;
; if (single_sprout < 5) one_vram_buffer(0, NTADR_A(x, GRASS_BORDER - 1));
;
L11C6:	lda     _tmp
	cmp     #$05
	bcs     L11C7
	lda     #$00
	jsr     pusha
	lda     _x
	ora     #$C0
	ldx     #$22
	jsr     _one_vram_buffer
;
; if (single_sprout > 8) index = 2; 
;
L11C7:	lda     _tmp
	cmp     #$09
	bcc     L11C8
	lda     #$02
;
; else if (single_sprout > 4) index = 1; 
;
	jmp     L11C2
L11C8:	lda     _tmp
	cmp     #$05
	lda     #$00
	bcc     L11C2
	lda     #$01
;
; else index = 0;
;
L11C2:	sta     _index
;
; one_vram_buffer(single_sprout - index * 4, NTADR_A(x, GRASS_BORDER - index));  
;
	lda     _tmp
	jsr     pusha0
	lda     _index
	jsr     shlax2
	jsr     tossubax
	jsr     pusha
	lda     #$17
	sec
	sbc     _index
	ldx     #$00
	jsr     shlax4
	stx     tmp1
	asl     a
	rol     tmp1
	sta     ptr1
	lda     _x
	ora     ptr1
	pha
	lda     tmp1
	ora     #$20
	tax
	pla
	jsr     _one_vram_buffer
;
; grass.height[x] = single_sprout;
;
	ldy     _x
	lda     _tmp
	sta     _grass+4,y
;
; }
;
	rts

.endproc

; ---------------------------------------------------------------
; void __near__ game_grass_fading (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_game_grass_fading: near

.segment	"CODE"

;
; x = (rand8() >> 3);
;
	jsr     _rand8
	jsr     asrax3
	sta     _x
;
; single_sprout = grass.height[x];
;
	ldy     _x
	lda     _grass+4,y
	sta     _tmp
;
; if (single_sprout > 2) {
;
	cmp     #$03
	bcc     L0B8D
;
; game_grass_cf_prepare();
;
	jsr     _game_grass_cf_prepare
;
; --single_sprout;
;
	dec     _tmp
;
; game_grass_cf_finalize();
;
	jsr     _game_grass_cf_finalize
;
; ++adr;
;
L0B8D:	inc     _adr
	bne     L0B93
	inc     _adr+1
;
; if (adr == GAME_WIN_TIME) game.state = GAME_ST_LEVEL_END_WIN;
;
L0B93:	lda     _adr+1
	bne     L0B94
	lda     _adr
	cmp     #$80
	bne     L0B94
	lda     #$03
	sta     _game+3
;
; }
;
L0B94:	rts

.endproc

; ---------------------------------------------------------------
; void __near__ game_grass_overgrow (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_game_grass_overgrow: near

.segment	"CODE"

;
; --grass.delay;
;
	dec     _grass
;
; if (grass.delay == 0x00) {
;
	beq     L11D1
;
; }
;
	rts
;
; game_calc_state = GCS_CHECK;
;
L11D1:	lda     #$01
	sta     _game_calc_state
;
; grass.delay = 0x14;
;
	lda     #$14
	sta     _grass
;
; state = (player.x & 0xF8) / 8;
;
	lda     _player
	and     #$F8
	lsr     a
	lsr     a
	lsr     a
	sta     _state
;
; index = 0;
;
	lda     #$00
	sta     _index
;
; for (x = state; x != state + 6; ++x) {
;
	lda     _state
	sta     _x
	ldx     #$00
L11CC:	lda     _state
	clc
	adc     #$06
	bcc     L0BAD
	inx
L0BAD:	cpx     #$00
	bne     L11D0
	cmp     _x
	jeq     L0BA7
;
; single_sprout = grass.height[x];
;
L11D0:	ldy     _x
	lda     _grass+4,y
	sta     _tmp
;
; for (y = 0x01; y != 0x07; ++y) {
;
	lda     #$01
	sta     _y
L11CD:	lda     _y
	cmp     #$07
	beq     L11CE
;
; if (single_sprout <= y * 4) {
;
	lda     _tmp
	jsr     pusha0
	lda     _y
	jsr     shlax2
	jsr     tosicmp
	beq     L11CB
	bcs     L0BB5
;
; one_vram_buffer(0xA3, NTADR_A(x, GRASS_BORDER - y + 1));
;
L11CB:	lda     #$A3
	jsr     pusha
	lda     #$17
	sec
	sbc     _y
	ldx     #$00
	clc
	adc     #$01
	bcc     L0BC4
	inx
L0BC4:	jsr     shlax4
	stx     tmp1
	asl     a
	rol     tmp1
	sta     ptr1
	lda     _x
	ora     ptr1
	pha
	lda     tmp1
	ora     #$20
	tax
	pla
	jsr     _one_vram_buffer
;
; one_vram_buffer(0x01, NTADR_A(x, GRASS_BORDER - y));
;
	lda     #$01
	jsr     pusha
	lda     #$17
	sec
	sbc     _y
	ldx     #$00
	jsr     shlax4
	stx     tmp1
	asl     a
	rol     tmp1
	sta     ptr1
	lda     _x
	ora     ptr1
	pha
	lda     tmp1
	ora     #$20
	tax
	pla
	jsr     _one_vram_buffer
;
; break;
;
	jmp     L11CE
;
; for (y = 0x01; y != 0x07; ++y) {
;
L0BB5:	inc     _y
	jmp     L11CD
;
; single_sprout += 4;
;
L11CE:	lda     #$04
	clc
	adc     _tmp
	sta     _tmp
;
; grass.height[x] = single_sprout;
;
	ldy     _x
	lda     _tmp
	sta     _grass+4,y
;
; if (y == 0x07) ++index;
;
	ldx     #$00
	lda     _y
	cmp     #$07
	bne     L11CF
	inc     _index
;
; for (x = state; x != state + 6; ++x) {
;
L11CF:	inc     _x
	jmp     L11CC
;
; if (index == 6) game.state = GAME_ST_LEVEL_END_LOSE;
;
L0BA7:	lda     _index
	cmp     #$06
	bne     L0BD7
	lda     #$05
	sta     _game+3
;
; }
;
L0BD7:	rts

.endproc

; ---------------------------------------------------------------
; void __near__ game_grass_cut (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_game_grass_cut: near

.segment	"CODE"

;
; x = (player.x / 8) + 2;
;
	lda     _player
	lsr     a
	lsr     a
	lsr     a
	clc
	adc     #$02
	sta     _x
;
; state = 0;
;
	lda     #$00
	sta     _state
;
; corr_power = player.cut.power;
;
	lda     _player+9
	sta     _marker
;
; if (game.effects.lightning == 0 && game.effects.wind == 0) sfx_play(SND_GAME_CUT, 1);
;
	lda     _game+8
	bne     L11DD
	lda     _game+10
	bne     L11DD
	lda     #$04
	jsr     pusha
	lda     #$01
	jsr     _sfx_play
;
; for (y = 0; y != player.cut.size; ++y) {
;
L11DD:	lda     #$00
	sta     _y
L11D8:	lda     _player+10
	cmp     _y
	jeq     L11DC
;
; if (state == 0) {
;
	lda     _state
	bne     L11DA
;
; x += y;
;
	lda     _y
	clc
	adc     _x
	sta     _x
;
; state = 1; 
;
	lda     #$01
	sta     _state
;
; if (player.abilities.list[ABILITY_CUT_POWER] < ABILITY_MAX_LEVEL) {
;
	lda     _player+18
	cmp     #$05
	bcs     L0B46
;
; if (corr_power > (player.abilities.list[ABILITY_CUT_POWER] < ABILITY_EX_LEVEL ? 1 : 2)) --corr_power;
;
	lda     _marker
	jsr     pusha0
	lda     _player+18
	cmp     #$03
	bcs     L11D9
	lda     #$01
	jmp     L0B43
L11D9:	lda     #$02
L0B43:	jsr     tosicmp0
	bcc     L0B46
	beq     L0B46
	dec     _marker
;
; } else {
;
	jmp     L0B46
;
; x -= y;
;
L11DA:	lda     _y
	eor     #$FF
	sec
	adc     _x
	sta     _x
;
; state = 0;
;
	lda     #$00
	sta     _state
;
; single_sprout = grass.height[x];
;
L0B46:	ldy     _x
	lda     _grass+4,y
	sta     _tmp
;
; game_grass_cf_prepare();
;
	jsr     _game_grass_cf_prepare
;
; if (corr_power >= single_sprout) {
;
	ldx     #$00
	lda     _marker
	cmp     _tmp
	bcc     L11DB
;
; single_sprout = 1;
;
	lda     #$01
	sta     _tmp
;
; score += (corr_power - single_sprout);
;
	lda     _marker
	sec
	sbc     _tmp
	clc
	adc     _score
	sta     _score
	txa
	adc     _score+1
	sta     _score+1
;
; player.cut.count += (corr_power - single_sprout);
;
	lda     _marker
	sec
	sbc     _tmp
;
; } else {
;
	jmp     L11DF
;
; single_sprout -= corr_power;
;
L11DB:	lda     _marker
	eor     #$FF
	sec
	adc     _tmp
	sta     _tmp
;
; score += corr_power;
;
	lda     _marker
	clc
	adc     _score
	sta     _score
	txa
	adc     _score+1
	sta     _score+1
;
; player.cut.count += corr_power;
;
	lda     _marker
L11DF:	clc
	adc     _player+15
	sta     _player+15
;
; game_check_for_extra_point();
;
	jsr     _game_check_for_extra_point
;
; game_grass_cf_finalize();
;
	jsr     _game_grass_cf_finalize
;
; for (y = 0; y != player.cut.size; ++y) {
;
	inc     _y
	jmp     L11D8
;
; if (player.specials.active[SP_SLASH] != 0) {
;
L11DC:	lda     _player+26
	beq     L0B68
;
; --player.specials.active[SP_SLASH];
;
	dec     _player+26
;
; if (player.specials.active[SP_SLASH] == 0) {
;
	bne     L0B68
;
; player.cut.max_delay = player.cut.temp_store;
;
	lda     _player+14
	sta     _player+13
;
; } 
;
L0B68:	rts

.endproc

; ---------------------------------------------------------------
; void __near__ game_check_for_extra_point (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_game_check_for_extra_point: near

.segment	"CODE"

;
; if (points < GAME_MAX_POINTS && player.cut.count > grass.col_for_point) {
;
	lda     _points
	cmp     #$63
	bcs     L11E2
	lda     _player+15
	sec
	sbc     _grass+3
	sta     tmp1
	lda     tmp1
	beq     L11E2
	bcs     L11E3
L11E2:	rts
;
; player.cut.count = 0;
;
L11E3:	lda     #$00
	sta     _player+15
;
; switch (game.difficulty) {
;
	lda     _game+6
;
; }
;
	beq     L11E4
	cmp     #$01
	beq     L11E5
	cmp     #$02
	beq     L11E6
	jmp     L11E7
;
; case GAME_DF_EASY :   grass.col_for_point += 1; break;
;
L11E4:	inc     _grass+3
	jmp     L11E7
;
; case GAME_DF_MEDIUM : grass.col_for_point += 3; break;
;
L11E5:	lda     #$03
	jmp     L11E9
;
; case GAME_DF_HARD :   grass.col_for_point += 5; break;
;
L11E6:	lda     #$05
L11E9:	clc
	adc     _grass+3
	sta     _grass+3
;
; ++points;
;
L11E7:	inc     _points
;
; game_draw_points();
;
	jmp     _game_draw_points

.endproc

; ---------------------------------------------------------------
; void __near__ game_draw_rain (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_game_draw_rain: near

.segment	"CODE"

;
; --rain_delay;
;
	dec     _rain_delay
;
; if (rain_delay == 0) {
;
	bne     L11ED
;
; rain_delay = DEFAULT_RAIN_DELAY;
;
	lda     #$06
	sta     _rain_delay
;
; for (index = 0x00; index != RAIN_COUNT; ++index) {
;
	lda     #$00
	sta     _index
L11EB:	lda     _index
	cmp     #$08
	beq     L11ED
;
; rain_drop_x[index] += rain_drop_y[index];
;
	lda     #<(_rain_drop_x)
	ldx     #>(_rain_drop_x)
	clc
	adc     _index
	bcc     L0A1C
	inx
L0A1C:	jsr     pushax
	sta     ptr1
	stx     ptr1+1
	ldy     #$00
	lda     (ptr1),y
	sta     ptr1
	ldy     _index
	lda     _rain_drop_y,y
	clc
	adc     ptr1
	ldy     #$00
	jsr     staspidx
;
; rain_drop_y[index] += 0x10;
;
	lda     #<(_rain_drop_y)
	ldx     #>(_rain_drop_y)
	clc
	adc     _index
	bcc     L0A22
	inx
L0A22:	sta     ptr1
	stx     ptr1+1
	ldy     #$00
	lda     (ptr1),y
	clc
	adc     #$10
	sta     (ptr1),y
;
; if (rain_drop_y[index] > 200) rain_drop_y[index] = 10;
;
	ldy     _index
	lda     _rain_drop_y,y
	cmp     #$C9
	bcc     L11EC
	ldy     _index
	lda     #$0A
	sta     _rain_drop_y,y
;
; for (index = 0x00; index != RAIN_COUNT; ++index) {
;
L11EC:	inc     _index
	jmp     L11EB
;
; for (index = 0x00; index != RAIN_COUNT; ++index) {
;
L11ED:	lda     #$00
	sta     _index
L11EE:	lda     _index
	cmp     #$08
	beq     L0A2D
;
; oam_spr(rain_drop_x[index], rain_drop_y[index], 0x04, 0b00000010);
;
	jsr     decsp3
	ldy     _index
	lda     _rain_drop_x,y
	ldy     #$02
	sta     (sp),y
	ldy     _index
	lda     _rain_drop_y,y
	ldy     #$01
	sta     (sp),y
	lda     #$04
	dey
	sta     (sp),y
	lda     #$02
	jsr     _oam_spr
;
; for (index = 0x00; index != RAIN_COUNT; ++index) {
;
	inc     _index
	jmp     L11EE
;
; }
;
L0A2D:	rts

.endproc

; ---------------------------------------------------------------
; void __near__ game_draw_sprites (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_game_draw_sprites: near

.segment	"CODE"

;
; oam_clear();
;
	jsr     _oam_clear
;
; if (player.cut.state == 0 || player.cut.state == CUT_ST_RECOVER) {
;
	lda     _player+11
	beq     L11F0
	cmp     #$05
	bne     L11F1
;
; if (player.direction == DIR_LEFT) oam_meta_spr(player.x, player.y, OTM_L);
;
L11F0:	lda     _player+8
	bne     L09A3
	jsr     decsp2
	lda     _player
	ldy     #$01
	sta     (sp),y
	lda     _player+1
	dey
	sta     (sp),y
	lda     #<(_OTM_L)
	ldx     #>(_OTM_L)
;
; else oam_meta_spr(player.x, player.y, OTM_R);
;
	jmp     L11EF
L09A3:	jsr     decsp2
	lda     _player
	ldy     #$01
	sta     (sp),y
	lda     _player+1
	dey
	sta     (sp),y
	lda     #<(_OTM_R)
	ldx     #>(_OTM_R)
;
; } else {
;
	jmp     L11EF
;
; --player.cut.delay;
;
L11F1:	dec     _player+12
;
; if (player.cut.delay == 0) {
;
	bne     L11F3
;
; player.cut.delay = player.cut.max_delay;
;
	lda     _player+13
	sta     _player+12
;
; if (player.cut.state == CUT_ST_C3) {
;
	lda     _player+11
	cmp     #$03
	bne     L11F2
;
; player.cut.state = CUT_ST_RECOVER;
;
	lda     #$05
	sta     _player+11
;
; game_grass_cut();
;
	jsr     _game_grass_cut
;
; } else {
;
	jmp     L11F3
;
; ++player.cut.state;
;
L11F2:	inc     _player+11
;
; if (player.cut.state == CUT_ST_C1 || player.cut.state == CUT_ST_RECOVER) oam_meta_spr(player.x - 8, player.y, OTM_RC_1);
;
L11F3:	lda     _player+11
	cmp     #$01
	beq     L11F5
	cmp     #$05
	bne     L11F6
L11F5:	jsr     decsp2
	lda     _player
	sec
	sbc     #$08
	ldy     #$01
	sta     (sp),y
	lda     _player+1
	dey
	sta     (sp),y
	lda     #<(_OTM_RC_1)
	ldx     #>(_OTM_RC_1)
	jsr     _oam_meta_spr
;
; if (player.cut.state == CUT_ST_C2) oam_meta_spr(player.x, player.y, OTM_RC_2);
;
L11F6:	lda     _player+11
	cmp     #$02
	bne     L11F7
	jsr     decsp2
	lda     _player
	ldy     #$01
	sta     (sp),y
	lda     _player+1
	dey
	sta     (sp),y
	lda     #<(_OTM_RC_2)
	ldx     #>(_OTM_RC_2)
	jsr     _oam_meta_spr
;
; if (player.cut.state == CUT_ST_C3) oam_meta_spr(player.x + 8, player.y, OTM_RC_3);
;
L11F7:	lda     _player+11
	cmp     #$03
	bne     L11F8
	jsr     decsp2
	lda     _player
	clc
	adc     #$08
	ldy     #$01
	sta     (sp),y
	lda     _player+1
	dey
	sta     (sp),y
	lda     #<(_OTM_RC_3)
	ldx     #>(_OTM_RC_3)
L11EF:	jsr     _oam_meta_spr
;
; if (small_scythe.state != 0) {
;
L11F8:	lda     _small_scythe+5
	beq     L09D0
;
; oam_meta_spr(small_scythe.x, small_scythe.y, SCYTHE_STATE[small_scythe.sprite]);
;
	jsr     decsp2
	lda     _small_scythe
	ldy     #$01
	sta     (sp),y
	lda     _small_scythe+1
	dey
	sta     (sp),y
	lda     _small_scythe+4
	jsr     pusha0
	lda     #$11
	jsr     tosmula0
	clc
	adc     #<(_SCYTHE_STATE)
	tay
	txa
	adc     #>(_SCYTHE_STATE)
	tax
	tya
	jmp     _oam_meta_spr
;
; }
;
L09D0:	rts

.endproc

; ---------------------------------------------------------------
; void __near__ game_draw_background (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_game_draw_background: near

.segment	"CODE"

;
; set_rand(get_frame_count());
;
	jsr     _get_frame_count
	ldx     #$00
	jsr     _set_rand
;
; fade_in();
;
	jsr     _fade_in
;
; ppu_off();
;
	jsr     _ppu_off
;
; clear_vram_buffer();
;
	jsr     _clear_vram_buffer
;
; clear_screen();
;
	jsr     _clear_screen
;
; set_bg_pallete(initial_pallete);
;
	lda     #<(_initial_pallete)
	ldx     #>(_initial_pallete)
	jsr     _set_bg_pallete
;
; for(x = 0x00; x != STARS_COUNT; ++x) {
;
	lda     #$00
	sta     _x
L11F9:	lda     _x
	cmp     #$20
	beq     L11FA
;
; vram_adr(NAMETABLE_A + rand8() * 3 - SCREEN_TILES_X * 5);
;
	jsr     _rand8
	jsr     mulax3
	pha
	txa
	clc
	adc     #$20
	tax
	pla
	sec
	sbc     #$A0
	bcs     L0902
	dex
L0902:	jsr     _vram_adr
;
; vram_put(0x2B);
;
	lda     #$2B
	jsr     _vram_put
;
; vram_adr(NAMETABLE_A + rand8() * 3 - SCREEN_TILES_X * 5);
;
	jsr     _rand8
	jsr     mulax3
	pha
	txa
	clc
	adc     #$20
	tax
	pla
	sec
	sbc     #$A0
	bcs     L0907
	dex
L0907:	jsr     _vram_adr
;
; vram_put(0x2D);
;
	lda     #$2D
	jsr     _vram_put
;
; for(x = 0x00; x != STARS_COUNT; ++x) {
;
	inc     _x
	jmp     L11F9
;
; index = 0x10;
;
L11FA:	lda     #$10
	sta     _index
;
; for(y = MOON_Y; y != MOON_Y + 0x04; ++y) {
;
	lda     #$03
	sta     _y
L11FB:	lda     _y
	cmp     #$07
	beq     L090D
;
; vram_adr(NAMETABLE_A + y * SCREEN_TILES_X + MOON_X);
;
	ldx     #$00
	lda     _y
	jsr     shlax4
	stx     tmp1
	asl     a
	rol     tmp1
	pha
	lda     tmp1
	clc
	adc     #$20
	tax
	pla
	clc
	adc     #$18
	bcc     L0916
	inx
L0916:	jsr     _vram_adr
;
; for(x = 0x00; x != 0x04; ++x) {
;
	lda     #$00
	sta     _x
L11FC:	lda     _x
	cmp     #$04
	beq     L11FD
;
; vram_put(index);
;
	lda     _index
	jsr     _vram_put
;
; ++index;
;
	inc     _index
;
; for(x = 0x00; x != 0x04; ++x) {
;
	inc     _x
	jmp     L11FC
;
; for(y = MOON_Y; y != MOON_Y + 0x04; ++y) {
;
L11FD:	inc     _y
	jmp     L11FB
;
; vram_adr(NAMETABLE_A + 0x20 * GRASS_BORDER);
;
L090D:	ldx     #$22
	lda     #$E0
	jsr     _vram_adr
;
; for(x = 0x00; x != GRASS_WIDTH; ++x) {
;
	lda     #$00
	sta     _x
L11FE:	lda     _x
	cmp     #$20
	beq     L11FF
;
; grass.height[x] = rand8() % 0x03 + 1;
;
	lda     #<(_grass+4)
	ldx     #>(_grass+4)
	clc
	adc     _x
	bcc     L092E
	inx
L092E:	jsr     pushax
	jsr     _rand8
	jsr     pushax
	lda     #$03
	jsr     tosumoda0
	clc
	adc     #$01
	ldy     #$00
	jsr     staspidx
;
; vram_put(grass.height[x]);
;
	ldy     _x
	lda     _grass+4,y
	jsr     _vram_put
;
; for(x = 0x00; x != GRASS_WIDTH; ++x) {
;
	inc     _x
	jmp     L11FE
;
; for(x = 0x00; x != GRASS_WIDTH; ++x) vram_put(0x06 + (rand8() % 4));
;
L11FF:	lda     #$00
	sta     _x
L1200:	lda     _x
	cmp     #$20
	beq     L1201
	jsr     _rand8
	and     #$03
	clc
	adc     #$06
	jsr     _vram_put
	inc     _x
	jmp     L1200
;
; for(x = 0x00; x != GRASS_WIDTH * 2; ++x) vram_put(0x0A + (rand8() % 4));
;
L1201:	lda     #$00
	sta     _x
L1202:	lda     _x
	cmp     #$40
	beq     L1203
	jsr     _rand8
	and     #$03
	clc
	adc     #$0A
	jsr     _vram_put
	inc     _x
	jmp     L1202
;
; for(x = 0x00; x != GRASS_WIDTH; ++x) {
;
L1203:	lda     #$00
	sta     _x
L1204:	lda     _x
	cmp     #$20
	beq     L094E
;
; state = state == 0x0E ? 0x0F : 0x0E;
;
	lda     _state
	cmp     #$0E
	bne     L1205
	lda     #$0F
	jmp     L1206
L1205:	lda     #$0E
L1206:	sta     _state
;
; vram_put(state);
;
	jsr     _vram_put
;
; for(x = 0x00; x != GRASS_WIDTH; ++x) {
;
	inc     _x
	jmp     L1204
;
; vram_adr(NAMETABLE_A + SCREEN_TILES_X * 0x1C);
;
L094E:	ldx     #$23
	lda     #$80
	jsr     _vram_adr
;
; for (x = 0x00; x != 0x20; ++x) 
;
	lda     #$00
	sta     _x
L1207:	lda     _x
	cmp     #$20
	beq     L0960
;
; vram_put(STATUS_BAR[x] == 0 ? CHR_BG_BLANK : STATUS_BAR[x]);
;
	ldy     _x
	lda     _STATUS_BAR,y
	bne     L096B
	lda     #$7F
	jmp     L1208
L096B:	ldy     _x
	lda     _STATUS_BAR,y
L1208:	jsr     _vram_put
;
; for (x = 0x00; x != 0x20; ++x) 
;
	inc     _x
	jmp     L1207
;
; vram_adr(NAMETABLE_A + SCREEN_TILES_X * 0x1C + 0x03);
;
L0960:	ldx     #$23
	lda     #$83
	jsr     _vram_adr
;
; vram_put(CHR_ZERO + game.lives);
;
	lda     _game+7
	clc
	adc     #$30
	jsr     _vram_put
;
; ppu_on_all();
;
	jsr     _ppu_on_all
;
; fade_out();
;
	jmp     _fade_out

.endproc

; ---------------------------------------------------------------
; void __near__ game_draw_time (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_game_draw_time: near

.segment	"CODE"

;
; one_vram_buffer(CHR_ZERO + game.play_time / 10, NTADR_A(0x15, Y_EDGE));
;
	lda     _game+4
	jsr     pusha0
	lda     #$0A
	jsr     tosudiva0
	clc
	adc     #$30
	jsr     pusha
	ldx     #$23
	lda     #$95
	jsr     _one_vram_buffer
;
; one_vram_buffer(CHR_ZERO + game.play_time % 10, NTADR_A(0x16, Y_EDGE));
;
	lda     _game+4
	jsr     pusha0
	lda     #$0A
	jsr     tosumoda0
	clc
	adc     #$30
	jsr     pusha
	ldx     #$23
	lda     #$96
	jmp     _one_vram_buffer

.endproc

; ---------------------------------------------------------------
; void __near__ game_draw_points (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_game_draw_points: near

.segment	"CODE"

;
; one_vram_buffer(CHR_ZERO + points / 10, NTADR_A(0x0B, Y_EDGE));
;
	lda     _points
	jsr     pusha0
	lda     #$0A
	jsr     tosudiva0
	clc
	adc     #$30
	jsr     pusha
	ldx     #$23
	lda     #$8B
	jsr     _one_vram_buffer
;
; one_vram_buffer(CHR_ZERO + points % 10, NTADR_A(0x0C, Y_EDGE));
;
	lda     _points
	jsr     pusha0
	lda     #$0A
	jsr     tosumoda0
	clc
	adc     #$30
	jsr     pusha
	ldx     #$23
	lda     #$8C
	jmp     _one_vram_buffer

.endproc

; ---------------------------------------------------------------
; void __near__ game_draw_effects (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_game_draw_effects: near

.segment	"CODE"

;
; if (game.effects.lightning != 0 && game.effects.lightning_enabled) {
;
	lda     _game+8
	beq     L120D
	lda     _game+9
	beq     L120D
;
; ++game.effects.lightning;
;
	inc     _game+8
;
; switch (game.effects.lightning) {
;
	lda     _game+8
;
; }
;
	cmp     #$02
	beq     L09E1
	cmp     #$08
	beq     L09E6
	cmp     #$10
	beq     L09EB
	cmp     #$18
	beq     L09F0
	cmp     #$20
	beq     L09F5
	cmp     #$3C
	beq     L120C
	jmp     L120D
;
; case 2: sfx_play(SND_GAME_LIGHTNING, 0);
;
L09E1:	lda     #$09
	jsr     pusha
	lda     #$00
	jsr     _sfx_play
;
; break;
;
	jmp     L120D
;
; case 8: pal_col(0, 0x30);
;
L09E6:	lda     #$00
	jsr     pusha
	lda     #$30
	jsr     _pal_col
;
; break;
;
	jmp     L120D
;
; case 16: pal_col(0, 0x0F);
;
L09EB:	lda     #$00
	jsr     pusha
	lda     #$0F
	jsr     _pal_col
;
; break;
;
	jmp     L120D
;
; case 24: pal_col(0, 0x30);
;
L09F0:	lda     #$00
	jsr     pusha
	lda     #$30
	jsr     _pal_col
;
; break;
;
	jmp     L120D
;
; case 32: pal_col(0, GAME_BG_COLOR);
;
L09F5:	lda     #$00
	jsr     pusha
	lda     #$0C
	jsr     _pal_col
;
; break;
;
	jmp     L120D
;
; case 60: game.effects.lightning = 0;
;
L120C:	lda     #$00
	sta     _game+8
;
; if (game.effects.wind != 0) {
;
L120D:	lda     _game+10
	beq     L0A02
;
; ++game.effects.wind;
;
	inc     _game+10
;
; switch (game.effects.wind) {
;
	lda     _game+10
;
; }
;
	cmp     #$02
	beq     L0A04
	cmp     #$5A
	beq     L120E
	rts
;
; case 2 : sfx_play(SND_GAME_WIND, 0);
;
L0A04:	lda     #$0A
	jsr     pusha
	lda     #$00
	jmp     _sfx_play
;
; case 90: game.effects.wind = 0;
;
L120E:	lda     #$00
	sta     _game+10
;
; }
;
L0A02:	rts

.endproc

; ---------------------------------------------------------------
; void __near__ game_movement_and_actions (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_game_movement_and_actions: near

.segment	"CODE"

;
; if (player.specials.active[SP_DASH] != 0) {
;
	lda     _player+25
	jeq     L1218
;
; if (ability_max) x = SP_DASH_SPEED_MAX;
;
	lda     _player+22
	cmp     #$05
	bne     L1213
	lda     #$04
;
; else if (ability_ex) x = SP_DASH_SPEED_MED;
;
	jmp     L1211
L1213:	lda     _player+22
	cmp     #$03
	bcc     L1214
	lda     #$03
;
; else x = SP_DASH_SPEED_LOW;
;
	jmp     L1211
L1214:	lda     #$02
L1211:	sta     _x
;
; if (player.specials.state[SP_DASH] == SP_DASH_LEFT) {
;
	lda     _player+28
	cmp     #$01
	bne     L1215
;
; if (player.x < x + 3) player.x = 3; else player.x -= x;
;
	lda     _player
	jsr     pusha0
	lda     _x
	clc
	adc     #$03
	bcc     L0BF2
	ldx     #$01
L0BF2:	jsr     tosicmp
	bcs     L0BF0
	lda     #$03
	jmp     L1212
L0BF0:	lda     _x
	eor     #$FF
	sec
	adc     _player
;
; } else {
;
	jmp     L1212
;
; player.x += x;
;
L1215:	lda     _x
	clc
	adc     _player
	sta     _player
;
; if (player.x > RIGHT_EDGE - PLAYER_WIDTH) player.x = RIGHT_EDGE - PLAYER_WIDTH;
;
	cmp     #$DB
	bcc     L1216
	lda     #$DA
L1212:	sta     _player
;
; --player.specials.active[SP_DASH];
;
L1216:	dec     _player+25
;
; player.y += player.specials.active[SP_DASH] > SP_DASH_JUMP ? -1 : 1;
;
	lda     _player+25
	cmp     #$06
	bcc     L1217
	lda     #$FF
	jmp     L0C06
L1217:	lda     #$01
L0C06:	clc
	adc     _player+1
	sta     _player+1
;
; if (player.specials.active[SP_DASH] == 0) player.specials.state[SP_DASH] = SP_IDLE;
;
	lda     _player+25
	jne     L1226
	sta     _player+28
;
; } else {
;
	jmp     L1226
;
; if (pad1 & PAD_LEFT || pad1 & PAD_RIGHT) {
;
L1218:	lda     _pad1
	and     #$02
	bne     L1219
	lda     _pad1
	and     #$01
	jeq     L1226
;
; if ((ability_max && player.abilities.list[ABILITY_MOVE_SPEED] == ABILITY_MAX_LEVEL) || player.cut.state == CUT_ST_IDLE) {
;
L1219:	lda     _player+22
	cmp     #$05
	bne     L121C
	lda     _player+20
	cmp     #$05
	beq     L121F
L121C:	lda     _player+11
	bne     L1226
;
; if (player.move_delay == 0) {
;
L121F:	lda     _player+4
	bne     L1225
;
; if (player.move_max_delay != 0) player.move_delay = player.move_max_delay;
;
	lda     _player+5
	beq     L1220
	sta     _player+4
;
; x = 1;
;
L1220:	lda     #$01
	sta     _x
;
; if (player.cut.state == CUT_ST_IDLE) {
;
	lda     _player+11
	bne     L1221
;
; if (player.move_max_increase != 0) {
;
	lda     _player+7
	beq     L1221
;
; --player.move_increase;
;
	dec     _player+6
;
; if (player.move_increase == 0) {
;
	bne     L1221
;
; player.move_increase = player.move_max_increase;
;
	lda     _player+7
	sta     _player+6
;
; ++x;
;
	inc     _x
;
; if (pad1 & PAD_LEFT) {
;
L1221:	lda     _pad1
	and     #$02
	beq     L1223
;
; player.x = (player.x - 3) < x ? 3 : player.x - x;
;
	ldx     #$00
	lda     _player
	sec
	sbc     #$03
	bcs     L0C31
	dex
L0C31:	cmp     _x
	txa
	sbc     #$00
	bcs     L0C32
	lda     #$03
	jmp     L1222
L0C32:	lda     _player
	sec
	sbc     _x
L1222:	sta     _player
;
; player.direction = DIR_LEFT;
;
	lda     #$00
	sta     _player+8
;
; } else {
;
	jmp     L1226
;
; player.x += x;
;
L1223:	lda     _x
	clc
	adc     _player
	sta     _player
;
; if (player.x > RIGHT_EDGE - PLAYER_WIDTH) player.x = RIGHT_EDGE - PLAYER_WIDTH;
;
	cmp     #$DB
	bcc     L1224
	lda     #$DA
	sta     _player
;
; player.direction = DIR_RIGHT;
;
L1224:	lda     #$01
	sta     _player+8
;
; } else {
;
	jmp     L1226
;
; --player.move_delay;
;
L1225:	dec     _player+4
;
; if (game.state == GAME_ST_LEVEL_PLAYING ) {
;
L1226:	lda     _game+3
	cmp     #$01
	bne     L0C57
;
; if (pad1 & PAD_B || player.specials.active[SP_SLASH] != 0) {
;
	lda     _pad1
	and     #$40
	bne     L1227
	lda     _player+26
	beq     L1231
;
; if (player.cut.state == CUT_ST_IDLE || (player.specials.active[SP_SLASH] != 0 && player.cut.state == CUT_ST_RECOVER)) {
;
L1227:	lda     _player+11
	beq     L122D
	lda     _player+26
	beq     L0C57
	lda     _player+11
	cmp     #$05
	jne     _game_check_specials_keys
;
; player.cut.state = CUT_ST_C1;
;
L122D:	lda     #$01
	sta     _player+11
;
; if (player.direction == DIR_LEFT) player.direction = DIR_RIGHT;
;
	lda     _player+8
	bne     L0C57
	lda     #$01
	sta     _player+8
;
; } else {
;
	jmp     _game_check_specials_keys
;
; if (player.cut.state == CUT_ST_RECOVER) player.cut.state = CUT_ST_IDLE;
;
L1231:	lda     _player+11
	cmp     #$05
	bne     L0C57
	lda     #$00
	sta     _player+11
;
; game_check_specials_keys();
;
L0C57:	jmp     _game_check_specials_keys

.endproc

; ---------------------------------------------------------------
; void __near__ game_check_specials_keys (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_game_check_specials_keys: near

.segment	"CODE"

;
; if (player.specials.delayed > 0) {
;
	lda     _player+23
	beq     L1234
;
; --player.specials.delayed;
;
	dec     _player+23
;
; if (player.specials.delayed == 0) {
;
	lda     _player+23
	bne     L1234
;
; player.specials.state[SP_DASH] = SP_IDLE;
;
	sta     _player+28
;
; player.specials.state[SP_SLASH] = SP_IDLE;
;
	sta     _player+29
;
; if (player.abilities.elevel >= SP_SSCYTHE_ALEVEL) {
;
L1234:	lda     _player+22
	beq     L123C
;
; if (pad1 & PAD_A && pad1 & PAD_UP && small_scythe.state == 0) {
;
	lda     _pad1
	and     #$80
	beq     L123C
	lda     _pad1
	and     #$08
	beq     L123C
	lda     _small_scythe+5
	bne     L123C
;
; tmp = ability_max ? SP_SSCYTHE_SPEED_EX : SP_SSCYTHE_SPEED;
;
	lda     _player+22
	cmp     #$05
	beq     L1239
	lda     #$03
L1239:	sta     _tmp
;
; small_scythe.x = player.x + 0x0A;
;
	lda     _player
	clc
	adc     #$0A
	sta     _small_scythe
;
; small_scythe.y = player.y;
;
	lda     _player+1
	sta     _small_scythe+1
;
; small_scythe.y_speed = tmp;
;
	lda     _tmp
	sta     _small_scythe+7
;
; if (pad1 & PAD_LEFT) small_scythe.x_speed = -tmp;
;
	lda     _pad1
	and     #$02
	beq     L123A
	lda     _tmp
	eor     #$FF
	clc
	adc     #$01
;
; else if (pad1 & PAD_RIGHT) small_scythe.x_speed = tmp;
;
	jmp     L1232
L123A:	lda     _pad1
	and     #$01
	beq     L1232
	lda     _tmp
;
; else small_scythe.x_speed = 0;
;
L1232:	sta     _small_scythe+6
;
; small_scythe.state = small_scythe.sprite = 1;
;
	lda     #$01
	sta     _small_scythe+4
	sta     _small_scythe+5
;
; if (player.abilities.elevel >= SP_DASH_ALEVEL && player.specials.active[SP_DASH] == 0) {
;
L123C:	lda     _player+22
	cmp     #$02
	bcc     L1244
	lda     _player+25
	bne     L1244
;
; switch (player.specials.state[SP_DASH]) {
;
	lda     _player+28
;
; }
;
	beq     L1240
	cmp     #$01
	beq     L1242
	cmp     #$02
	beq     L1243
	jmp     L1244
;
; if (pad1_new & PAD_RIGHT) {
;
L1240:	lda     _pad1_new
	and     #$01
	beq     L1241
;
; player.specials.state[SP_DASH] = SP_DASH_RIGHT;
;
	lda     #$02
	sta     _player+28
;
; player.specials.delayed = SP_MAX_DELAY;
;
	lda     #$10
	sta     _player+23
;
; if (pad1_new & PAD_LEFT) {
;
L1241:	lda     _pad1_new
	and     #$02
	beq     L1244
;
; player.specials.state[SP_DASH] = SP_DASH_LEFT;
;
	lda     #$01
	sta     _player+28
;
; player.specials.delayed = SP_MAX_DELAY;
;
	lda     #$10
;
; break;
;
	jmp     L1233
;
; if (pad1_new & PAD_LEFT) {
;
L1242:	lda     _pad1_new
	and     #$02
;
; break;
;
	jmp     L1250
;
; if (pad1_new & PAD_RIGHT) {
;
L1243:	lda     _pad1_new
	and     #$01
L1250:	beq     L1244
;
; player.specials.active[SP_DASH] = SP_DASH_LENGTH;
;
	lda     #$0C
	sta     _player+25
;
; player.specials.delayed = 0;
;
	lda     #$00
L1233:	sta     _player+23
;
; if (pad1_new & PAD_DOWN) {
;
L1244:	lda     _pad1_new
	and     #$04
	beq     L0CD6
;
; if (player.abilities.elevel >= SP_SLASH_ALEVEL && player.specials.active[SP_SLASH] == 0) {
;
	lda     _player+22
	cmp     #$04
	bcc     L1246
	lda     _player+26
	beq     L1247
L1246:	rts
;
; ++player.specials.state[SP_SLASH];
;
L1247:	inc     _player+29
;
; if (player.specials.state[SP_SLASH] == SP_SLASH_TRIPLE_DOWN) {
;
	lda     _player+29
	cmp     #$03
	bne     L124C
;
; player.specials.active[SP_SLASH] = ability_max ? SP_SLASH_COUNT_EX : SP_SLASH_COUNT;
;
	lda     _player+22
	cmp     #$05
	beq     L1249
	lda     #$03
L1249:	sta     _player+26
;
; player.specials.state[SP_SLASH] = SP_IDLE;
;
	lda     #$00
	sta     _player+29
;
; player.cut.temp_store = player.cut.max_delay;
;
	lda     _player+13
	sta     _player+14
;
; player.cut.max_delay = ability_max ? SP_SLASH_FAST_DELAY_EX : SP_SLASH_FAST_DELAY;
;
	lda     _player+22
	cmp     #$05
	bne     L124A
	lda     #$01
	jmp     L124B
L124A:	lda     #$03
L124B:	sta     _player+13
;
; } else {
;
	rts
;
; player.specials.delayed = SP_MAX_DELAY;
;
L124C:	lda     #$10
	sta     _player+23
;
; }
;
L0CD6:	rts

.endproc

; ---------------------------------------------------------------
; void __near__ game_small_scythe_processing (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_game_small_scythe_processing: near

.segment	"CODE"

;
; if (small_scythe.state != 0) {
;
	lda     _small_scythe+5
	beq     L0CEB
;
; x = small_scythe.x + small_scythe.x_speed;
;
	lda     _small_scythe
	clc
	adc     _small_scythe+6
	sta     _x
;
; y = small_scythe.y - small_scythe.y_speed;
;
	lda     _small_scythe+1
	sec
	sbc     _small_scythe+7
	sta     _y
;
; if (x > RIGHT_EDGE || y > BOTTOM_EDGE) {
;
	lda     _x
	cmp     #$FB
	bcs     L1252
	lda     _y
	cmp     #$E7
	bcc     L1253
;
; small_scythe.state = 0;
;
L1252:	lda     #$00
	sta     _small_scythe+5
;
; } else {
;
	rts
;
; ++small_scythe.state;
;
L1253:	inc     _small_scythe+5
;
; small_scythe.x = x;
;
	lda     _x
	sta     _small_scythe
;
; small_scythe.y = y;
;
	lda     _y
	sta     _small_scythe+1
;
; if (small_scythe.state == CHR_SC_ANIM_DELAY) {
;
	lda     _small_scythe+5
	cmp     #$04
	bne     L0CEB
;
; small_scythe.state = 1;
;
	lda     #$01
	sta     _small_scythe+5
;
; small_scythe.sprite = small_scythe.sprite == 7 ? 0 : small_scythe.sprite + 1;
;
	lda     _small_scythe+4
	cmp     #$07
	bne     L1254
	lda     #$00
	jmp     L1255
L1254:	lda     _small_scythe+4
	clc
	adc     #$01
L1255:	sta     _small_scythe+4
;
; }
;
L0CEB:	rts

.endproc

; ---------------------------------------------------------------
; void __near__ game_create_enemy (unsigned char)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_game_create_enemy: near

.segment	"CODE"

;
; void game_create_enemy(char bird_num) {
;
	jsr     pusha
;
; if (bird_state[bird_num] == 0) {
;
	ldy     #$00
	lda     (sp),y
	tay
	lda     _bird_state,y
	beq     L1259
;
; }
;
	jmp     incsp1
;
; bird_state[bird_num] = 1;
;
L1259:	tay
	lda     (sp),y
	tay
	lda     #$01
	sta     _bird_state,y
;
; if (rand8() % 2 == 0) {
;
	jsr     _rand8
	and     #$01
	bne     L0CFF
;
; bird_x[bird_num] = 2;
;
	tay
	lda     (sp),y
	tay
	lda     #$02
	sta     _bird_x,y
;
; bird_x_speed[bird_num] = 1;
;
	ldy     #$00
	lda     (sp),y
	tay
	lda     #$01
;
; } else {
;
	jmp     L1256
;
; bird_x[bird_num] = 235;
;
L0CFF:	ldy     #$00
	lda     (sp),y
	tay
	lda     #$EB
	sta     _bird_x,y
;
; bird_x_speed[bird_num] = -1;
;
	ldy     #$00
	lda     (sp),y
	tay
	lda     #$FF
L1256:	sta     _bird_x_speed,y
;
; bird_tag[bird_num] = 0;
;
	ldy     #$00
	lda     (sp),y
	tay
	lda     #$00
	sta     _bird_tag,y
;
; bird_y[bird_num] = 30 + (rand8() >> 3);
;
	lda     #<(_bird_y)
	ldx     #>(_bird_y)
	ldy     #$00
	clc
	adc     (sp),y
	bcc     L0D19
	inx
L0D19:	jsr     pushax
	jsr     _rand8
	jsr     asrax3
	clc
	adc     #$1E
	ldy     #$00
	jsr     staspidx
;
; bird_pallete[bird_num] = rand8() % 3 + 1;
;
	lda     #<(_bird_pallete)
	ldx     #>(_bird_pallete)
	ldy     #$00
	clc
	adc     (sp),y
	bcc     L0D1F
	inx
L0D1F:	jsr     pushax
	jsr     _rand8
	jsr     pushax
	lda     #$03
	jsr     tosumoda0
	clc
	adc     #$01
	ldy     #$00
	jsr     staspidx
;
; bird_health[bird_num] = bird_pallete[bird_num] == 3 ? 4 : bird_pallete[bird_num];
;
	lda     #<(_bird_health)
	ldx     #>(_bird_health)
	ldy     #$00
	clc
	adc     (sp),y
	bcc     L0D24
	inx
L0D24:	sta     ptr1
	stx     ptr1+1
	lda     (sp),y
	tay
	lda     _bird_pallete,y
	cmp     #$03
	bne     L0D28
	lda     #$04
	jmp     L1257
L0D28:	ldy     #$00
	lda     (sp),y
	tay
	lda     _bird_pallete,y
L1257:	ldy     #$00
	sta     (ptr1),y
;
; if (game.level >= 5) ++bird_health[bird_num];
;
	lda     _game
	cmp     #$05
	bcc     L1258
	lda     #<(_bird_health)
	ldx     #>(_bird_health)
	clc
	adc     (sp),y
	bcc     L0D32
	inx
L0D32:	sta     ptr1
	stx     ptr1+1
	lda     #$01
	clc
	adc     (ptr1),y
	sta     (ptr1),y
;
; if (game.level >= 10) ++bird_health[bird_num];
;
L1258:	lda     _game
	cmp     #$0A
	bcc     L0D33
	lda     #<(_bird_health)
	ldx     #>(_bird_health)
	clc
	adc     (sp),y
	bcc     L0D37
	inx
L0D37:	sta     ptr1
	stx     ptr1+1
	lda     #$01
	clc
	adc     (ptr1),y
	sta     (ptr1),y
;
; bird_speed_delay[bird_num] = bird_health[bird_num];
;
L0D33:	lda     #<(_bird_speed_delay)
	ldx     #>(_bird_speed_delay)
	clc
	adc     (sp),y
	bcc     L0D3A
	inx
L0D3A:	jsr     pushax
	ldy     #$02
	lda     (sp),y
	tay
	lda     _bird_health,y
	ldy     #$00
	jsr     staspidx
;
; }
;
	jmp     incsp1

.endproc

; ---------------------------------------------------------------
; void __near__ game_enemy_processing (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_game_enemy_processing: near

.segment	"CODE"

;
; for (x = 0; x < BIRDS_COUNT; ++x) {
;
	lda     #$00
	sta     _x
L1261:	lda     _x
	cmp     #$04
	bcc     L1272
;
; }
;
	rts
;
; if (bird_state[x] != 0) {
;
L1272:	ldy     _x
	lda     _bird_state,y
	jeq     L1271
;
; ++bird_state[x];
;
	lda     #<(_bird_state)
	ldx     #>(_bird_state)
	clc
	adc     _x
	bcc     L0D4D
	inx
L0D4D:	sta     ptr1
	stx     ptr1+1
	ldy     #$00
	lda     #$01
	clc
	adc     (ptr1),y
	sta     (ptr1),y
;
; --bird_speed_delay[x];
;
	lda     #<(_bird_speed_delay)
	ldx     #>(_bird_speed_delay)
	clc
	adc     _x
	bcc     L0D50
	inx
L0D50:	sta     ptr1
	stx     ptr1+1
	lda     (ptr1),y
	sec
	sbc     #$01
	sta     (ptr1),y
;
; if (bird_speed_delay[x] == 0) {
;
	ldy     _x
	lda     _bird_speed_delay,y
	bne     L0D51
;
; bird_x[x] += bird_x_speed[x];
;
	lda     #<(_bird_x)
	ldx     #>(_bird_x)
	clc
	adc     _x
	bcc     L0D57
	inx
L0D57:	jsr     pushax
	sta     ptr1
	stx     ptr1+1
	ldy     #$00
	lda     (ptr1),y
	sta     ptr1
	ldy     _x
	lda     _bird_x_speed,y
	clc
	adc     ptr1
	ldy     #$00
	jsr     staspidx
;
; bird_speed_delay[x] = bird_health[x];
;
	lda     #<(_bird_speed_delay)
	ldx     #>(_bird_speed_delay)
	clc
	adc     _x
	bcc     L0D5D
	inx
L0D5D:	sta     ptr1
	stx     ptr1+1
	ldy     _x
	lda     _bird_health,y
	ldy     #$00
	sta     (ptr1),y
;
; if (bird_state[x] == 0x0A) {
;
L0D51:	ldy     _x
	lda     _bird_state,y
	cmp     #$0A
	bne     L0D61
;
; bird_state[x] = 1;
;
	ldy     _x
	lda     #$01
	sta     _bird_state,y
;
; bird_sprite[x] = bird_sprite[x] == 1 ? 0 : 1;
;
	lda     #<(_bird_sprite)
	ldx     #>(_bird_sprite)
	clc
	adc     _x
	bcc     L0D6B
	inx
L0D6B:	sta     ptr1
	stx     ptr1+1
	ldy     _x
	lda     _bird_sprite,y
	cmp     #$01
	bne     L1262
	lda     #$00
	jmp     L1263
L1262:	lda     #$01
L1263:	ldy     #$00
	sta     (ptr1),y
;
; if (bird_x[x] <= 1 || bird_x[x] > 235) bird_state[x] = 0;
;
L0D61:	ldy     _x
	lda     _bird_x,y
	cmp     #$02
	bcc     L1264
	ldy     _x
	lda     _bird_x,y
	cmp     #$EC
	bcc     L1265
L1264:	ldy     _x
	lda     #$00
	sta     _bird_state,y
;
; if (small_scythe.state != 0 && bird_tag[x] == 0) {
;
L1265:	lda     _small_scythe+5
	jeq     L126F
	ldy     _x
	lda     _bird_tag,y
	jne     L126E
;
; if (small_scythe.x <= bird_x[x] + BIRDS_WIDTH && 
;
	lda     _small_scythe
	jsr     pusha0
	ldy     _x
	lda     _bird_x,y
	clc
	adc     #$10
	bcc     L0D88
	ldx     #$01
L0D88:	jsr     tosicmp
	beq     L125F
	jcs     L126E
;
; small_scythe.x + SP_SSCYTHE_SIZE >= bird_x[x] &&
;
L125F:	ldx     #$00
	lda     _small_scythe
	clc
	adc     #$10
	bcc     L0D8A
	inx
L0D8A:	jsr     pushax
	ldy     _x
	lda     _bird_x,y
	jsr     tosicmp0
	jcc     L126E
;
; small_scythe.y <= bird_y[x] + BIRDS_HEIGHT && 
;
	lda     _small_scythe+1
	jsr     pusha0
	ldy     _x
	lda     _bird_y,y
	clc
	adc     #$08
	bcc     L0D8F
	ldx     #$01
L0D8F:	jsr     tosicmp
	beq     L1260
	jcs     L126E
;
; small_scythe.y + SP_SSCYTHE_SIZE >= bird_y[x]) {
;
L1260:	ldx     #$00
	lda     _small_scythe+1
	clc
	adc     #$10
	bcc     L0D90
	inx
L0D90:	jsr     pushax
	ldy     _x
	lda     _bird_y,y
	jsr     tosicmp0
	jcc     L126E
;
; tmp = ability_ex ? SP_SSCYTHE_DMG_EX : SP_SSCYTHE_DMG;
;
	lda     _player+22
	cmp     #$03
	bcc     L1269
	lda     #$02
	jmp     L126A
L1269:	lda     #$01
L126A:	sta     _tmp
;
; small_scythe.state = 0;
;
	lda     #$00
	sta     _small_scythe+5
;
; if (bird_health[x] <= tmp) {
;
	ldy     _x
	lda     _bird_health,y
	sec
	sbc     _tmp
	sta     tmp1
	lda     tmp1
	beq     L125D
	bcs     L0D9D
;
; bird_tag[x] = BIRDS_TAG_DIE;
;
L125D:	ldy     _x
	lda     #$19
	sta     _bird_tag,y
;
; sfx_play(SND_BIRD_DEATH, 1);
;
	lda     #$0B
	jsr     pusha
	lda     #$01
	jsr     _sfx_play
;
; score += bird_pallete[x] * 10;
;
	ldy     _x
	ldx     #$00
	lda     _bird_pallete,y
	jsr     mulax10
	clc
	adc     _score
	sta     _score
	txa
	adc     _score+1
	sta     _score+1
;
; if (points < GAME_MAX_POINTS) {
;
	lda     _points
	cmp     #$63
	bcs     L126E
;
; switch (bird_pallete[x]) {
;
	ldy     _x
	lda     _bird_pallete,y
;
; }
;
	cmp     #$01
	beq     L126B
	cmp     #$02
	beq     L126C
	cmp     #$03
	beq     L126D
	jmp     L126E
;
; case 1: player.cut.count += grass.col_for_point >> 1; 
;
L126B:	lda     _grass+3
	lsr     a
	clc
	adc     _player+15
	sta     _player+15
;
; game_check_for_extra_point();
;
	jsr     _game_check_for_extra_point
;
; break;
;
	jmp     L126E
;
; case 2: ++points; 
;
L126C:	inc     _points
;
; game_draw_points();
;
	jsr     _game_draw_points
;
; break;
;
	jmp     L126E
;
; case 3: points += 2; 
;
L126D:	lda     #$02
	clc
	adc     _points
	sta     _points
;
; game_draw_points();
;
	jsr     _game_draw_points
;
; break;
;
	jmp     L126E
;
; bird_health[x] -= tmp;
;
L0D9D:	lda     #<(_bird_health)
	ldx     #>(_bird_health)
	clc
	adc     _x
	bcc     L0DC4
	inx
L0DC4:	jsr     pushax
	sta     ptr1
	stx     ptr1+1
	ldy     #$00
	lda     (ptr1),y
	sec
	sbc     _tmp
	jsr     staspidx
;
; bird_tag[x] = BIRDS_TAG_HIT;
;
	ldy     _x
	lda     #$05
	sta     _bird_tag,y
;
; tmp = 0;
;
L126E:	lda     #$00
L126F:	sta     _tmp
;
; if (bird_tag[x] > 0) --bird_tag[x];
;
	ldy     _x
	lda     _bird_tag,y
	beq     L0DCC
	lda     #<(_bird_tag)
	ldx     #>(_bird_tag)
	clc
	adc     _x
	bcc     L0DD2
	inx
L0DD2:	sta     ptr1
	stx     ptr1+1
	ldy     #$00
	lda     (ptr1),y
	sec
	sbc     #$01
	sta     (ptr1),y
;
; if (bird_tag[x] > BIRDS_TAG_HIT) {
;
L0DCC:	ldy     _x
	lda     _bird_tag,y
	cmp     #$06
	bcc     L0DD3
;
; tmp = BIRDS_TAG_DIE - bird_tag[x];
;
	lda     #$19
	jsr     pusha0
	ldy     _x
	lda     _bird_tag,y
	jsr     tossuba0
	sta     _tmp
;
; if (bird_tag[x] == BIRDS_TAG_HIT + 1) {
;
	ldy     _x
	lda     _bird_tag,y
	cmp     #$06
	bne     L0DD3
;
; bird_state[x] = 0;
;
	ldy     _x
	lda     #$00
	sta     _bird_state,y
;
; if (bird_tag[x] == 0 || bird_tag[x] > BIRDS_TAG_HIT)
;
L0DD3:	ldy     _x
	lda     _bird_tag,y
	beq     L1270
	ldy     _x
	lda     _bird_tag,y
	cmp     #$06
	jcc     L1271
;
; if (bird_x_speed[x] == 1) {
;
L1270:	ldy     _x
	lda     _bird_x_speed,y
	cmp     #$01
	bne     L0DEA
;
; oam_spr(bird_x[x] + 0x08, bird_y[x] - tmp, 0x19, bird_pallete[x] - 1 | OAM_FLIP_H);
;
	jsr     decsp3
	ldy     _x
	lda     _bird_x,y
	clc
	adc     #$08
	ldy     #$02
	sta     (sp),y
	ldy     _x
	lda     _bird_y,y
	sec
	sbc     _tmp
	ldy     #$01
	sta     (sp),y
	lda     #$19
	dey
	sta     (sp),y
	ldy     _x
	lda     _bird_pallete,y
	sec
	sbc     #$01
	ora     #$40
	jsr     _oam_spr
;
; oam_spr(bird_x[x], bird_y[x] + tmp, 0x1A + bird_sprite[x], bird_pallete[x] - 1 | OAM_FLIP_H );
;
	jsr     decsp3
	ldy     _x
	lda     _bird_x,y
	ldy     #$02
	sta     (sp),y
	ldy     _x
	lda     _bird_y,y
	clc
	adc     _tmp
	ldy     #$01
	sta     (sp),y
	ldy     _x
	lda     _bird_sprite,y
	clc
	adc     #$1A
	ldy     #$00
	sta     (sp),y
	ldy     _x
	lda     _bird_pallete,y
	sec
	sbc     #$01
	ora     #$40
;
; } else {
;
	jmp     L125E
;
; oam_spr(bird_x[x], bird_y[x] - tmp, 0x19, bird_pallete[x] - 1);
;
L0DEA:	jsr     decsp3
	ldy     _x
	lda     _bird_x,y
	ldy     #$02
	sta     (sp),y
	ldy     _x
	lda     _bird_y,y
	sec
	sbc     _tmp
	ldy     #$01
	sta     (sp),y
	lda     #$19
	dey
	sta     (sp),y
	ldy     _x
	lda     _bird_pallete,y
	sec
	sbc     #$01
	jsr     _oam_spr
;
; oam_spr(bird_x[x] + 0x08, bird_y[x] + tmp, 0x1A + bird_sprite[x], bird_pallete[x] - 1);
;
	jsr     decsp3
	ldy     _x
	lda     _bird_x,y
	clc
	adc     #$08
	ldy     #$02
	sta     (sp),y
	ldy     _x
	lda     _bird_y,y
	clc
	adc     _tmp
	ldy     #$01
	sta     (sp),y
	ldy     _x
	lda     _bird_sprite,y
	clc
	adc     #$1A
	ldy     #$00
	sta     (sp),y
	ldy     _x
	lda     _bird_pallete,y
	sec
	sbc     #$01
L125E:	jsr     _oam_spr
;
; for (x = 0; x < BIRDS_COUNT; ++x) {
;
L1271:	inc     _x
	jmp     L1261

.endproc

; ---------------------------------------------------------------
; void __near__ upgrade_draw_sprites (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_upgrade_draw_sprites: near

.segment	"CODE"

;
; oam_clear();
;
	jsr     _oam_clear
;
; oam_meta_spr(0x1E, 0x1D + player.abilities.selection * 0x18, CURSOR);
;
	jsr     decsp2
	lda     #$1E
	ldy     #$01
	sta     (sp),y
	lda     _player+16
	jsr     pusha0
	lda     #$18
	jsr     tosumula0
	clc
	adc     #$1D
	ldy     #$00
	sta     (sp),y
	lda     #<(_CURSOR)
	ldx     #>(_CURSOR)
	jmp     _oam_meta_spr

.endproc

; ---------------------------------------------------------------
; void __near__ upgrade_draw_background (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_upgrade_draw_background: near

.segment	"CODE"

;
; fade_in();
;
	jsr     _fade_in
;
; ppu_off();
;
	jsr     _ppu_off
;
; clear_screen();
;
	jsr     _clear_screen
;
; pal_bg(upgrade_palette_bg);
;
	lda     #<(_upgrade_palette_bg)
	ldx     #>(_upgrade_palette_bg)
	jsr     _pal_bg
;
; pal_spr(upgrade_palette_sp);
;
	lda     #<(_upgrade_palette_sp)
	ldx     #>(_upgrade_palette_sp)
	jsr     _pal_spr
;
; vram_adr(PPU_PALLETE);
;
	ldx     #$23
	lda     #$C0
	jsr     _vram_adr
;
; for (x = 0x00; x != 0x40; ++x) {
;
	lda     #$00
	sta     _x
L1274:	lda     _x
	cmp     #$40
	beq     L1275
;
; vram_put(0x00);
;
	lda     #$00
	jsr     _vram_put
;
; for (x = 0x00; x != 0x40; ++x) {
;
	inc     _x
	jmp     L1274
;
; for (y = 0x02; y != 0x1B; ++y) {
;
L1275:	lda     #$02
	sta     _y
L1276:	lda     _y
	cmp     #$1B
	beq     L1279
;
; vram_adr(NAMETABLE_A + SCREEN_TILES_X * y + 0x02);
;
	ldx     #$00
	lda     _y
	jsr     shlax4
	stx     tmp1
	asl     a
	rol     tmp1
	pha
	lda     tmp1
	clc
	adc     #$20
	tax
	pla
	clc
	adc     #$02
	bcc     L0E51
	inx
L0E51:	jsr     _vram_adr
;
; if (y == 0x02 || y == 0x18 || y == 0x1A) {
;
	lda     _y
	cmp     #$02
	beq     L1277
	cmp     #$18
	beq     L1277
	cmp     #$1A
	bne     L0E52
;
; vram_put(CHR_BORDER_CORNER);
;
L1277:	lda     #$26
	jsr     _vram_put
;
; for(x = 0x00; x != 0x1A; ++x) vram_put(CHR_BORDER_HORZ);
;
	lda     #$00
	sta     _x
L1278:	lda     _x
	cmp     #$1A
	beq     L0E58
	lda     #$27
	jsr     _vram_put
	inc     _x
	jmp     L1278
;
; vram_put(CHR_BORDER_CORNER);
;
L0E58:	lda     #$26
;
; } else {
;
	jmp     L1273
;
; vram_put(CHR_BORDER_VERT);
;
L0E52:	lda     #$2A
	jsr     _vram_put
;
; vram_adr(NAMETABLE_A + SCREEN_TILES_X * y + 0x1D);
;
	ldx     #$00
	lda     _y
	jsr     shlax4
	stx     tmp1
	asl     a
	rol     tmp1
	pha
	lda     tmp1
	clc
	adc     #$20
	tax
	pla
	clc
	adc     #$1D
	bcc     L0E68
	inx
L0E68:	jsr     _vram_adr
;
; vram_put(CHR_BORDER_VERT);
;
	lda     #$2A
L1273:	jsr     _vram_put
;
; for (y = 0x02; y != 0x1B; ++y) {
;
	inc     _y
	jmp     L1276
;
; index = 0x00;
;
L1279:	lda     #$00
	sta     _index
;
; adr = NAMETABLE_A + SCREEN_TILES_X * 0x04 + 0x04;
;
	ldx     #$20
	lda     #$84
	sta     _adr
	stx     _adr+1
;
; for(x = 0x00; x != ABILITIES_COUNT; ++x) {
;
	lda     #$00
	sta     _x
L127A:	lda     _x
	cmp     #$05
	beq     L0E70
;
; tmp = player.abilities.list[x];
;
	ldy     _x
	lda     _player+17,y
	sta     _tmp
;
; upgrade_draw_icon();
;
	jsr     _upgrade_draw_icon
;
; for (y = 0x00; y != ABILITY_MAX_LEVEL; ++y)
;
	lda     #$00
	sta     _y
L127B:	lda     _y
	cmp     #$05
	beq     L0E7D
;
; vram_put(y < tmp ? CHR_FCELL_TOP : CHR_CELL_TOP);
;
	cmp     _tmp
	bcs     L127C
	lda     #$23
	jmp     L127D
L127C:	lda     #$22
L127D:	jsr     _vram_put
;
; for (y = 0x00; y != ABILITY_MAX_LEVEL; ++y)
;
	inc     _y
	jmp     L127B
;
; adr += SCREEN_TILES_X;
;
L0E7D:	lda     #$20
	clc
	adc     _adr
	sta     _adr
	bcc     L0E8C
	inc     _adr+1
;
; upgrade_draw_icon();
;
L0E8C:	jsr     _upgrade_draw_icon
;
; for (y = 0x00; y != ABILITY_MAX_LEVEL; ++y)
;
	lda     #$00
	sta     _y
L127E:	lda     _y
	cmp     #$05
	beq     L0E8F
;
; vram_put(y < tmp ? CHR_FCELL_BOTTOM : CHR_CELL_BOTTOM);
;
	cmp     _tmp
	bcs     L127F
	lda     #$25
	jmp     L1280
L127F:	lda     #$24
L1280:	jsr     _vram_put
;
; for (y = 0x00; y != ABILITY_MAX_LEVEL; ++y)
;
	inc     _y
	jmp     L127E
;
; adr += SCREEN_TILES_X + SCREEN_TILES_X;
;
L0E8F:	lda     #$40
	clc
	adc     _adr
	sta     _adr
	bcc     L0E9E
	inc     _adr+1
;
; for(x = 0x00; x != ABILITIES_COUNT; ++x) {
;
L0E9E:	inc     _x
	jmp     L127A
;
; put_str(NTADR_A(0x03, 0x19), "                POINTS    ");
;
L0E70:	ldx     #$23
	txa
	jsr     pushax
	lda     #<(L0EA6)
	ldx     #>(L0EA6)
	jsr     _put_str
;
; for (x = 0x01; x != ABILITY_MAX_LEVEL; ++x) {
;
	lda     #$01
	sta     _x
L1281:	lda     _x
	cmp     #$05
	beq     L0EA9
;
; if (player.abilities.elevel >= x) upgrade_draw_desc(x);
;
	lda     _player+22
	cmp     _x
	bcc     L0EA9
	lda     _x
	jsr     _upgrade_draw_desc
;
; for (x = 0x01; x != ABILITY_MAX_LEVEL; ++x) {
;
	inc     _x
	jmp     L1281
;
; upgrade_show_ablity_desc();
;
L0EA9:	jsr     _upgrade_show_ablity_desc
;
; upgrade_show_current_points();
;
	jsr     _upgrade_show_current_points
;
; ppu_on_all();
;
	jsr     _ppu_on_all
;
; for (x = 0x01; x <= ABILITY_MAX_LEVEL; ++x) {
;
	lda     #$01
	sta     _x
L1282:	lda     _x
	cmp     #$06
	bcs     L0EB9
;
; ppu_wait_nmi();
;
	jsr     _ppu_wait_nmi
;
; clear_vram_buffer();
;
	jsr     _clear_vram_buffer
;
; if (player.abilities.elevel >= x) upgrade_draw_desc(x); else break;
;
	lda     _player+22
	cmp     _x
	bcc     L0EB9
	lda     _x
	jsr     _upgrade_draw_desc
;
; for (x = 0x01; x <= ABILITY_MAX_LEVEL; ++x) {
;
	inc     _x
	jmp     L1282
;
; fade_out();
;
L0EB9:	jmp     _fade_out

.endproc

; ---------------------------------------------------------------
; void __near__ upgrade_movement_and_actions (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_upgrade_movement_and_actions: near

.segment	"CODE"

;
; state = 0;
;
	lda     #$00
	sta     _state
;
; if (pad1_new & PAD_DOWN) {
;
	lda     _pad1_new
	and     #$04
	beq     L1284
;
; sfx_play(SND_MENU_MOVE, 0);
;
	lda     #$00
	jsr     pusha
	jsr     _sfx_play
;
; if (player.abilities.selection == (ABILITIES_COUNT - 1)) player.abilities.selection = 0;
;
	lda     _player+16
	cmp     #$04
	bne     L1283
	lda     #$00
	sta     _player+16
;
; else ++player.abilities.selection;
;
	jmp     L0F6A
L1283:	inc     _player+16
;
; upgrade_show_ablity_desc();
;
L0F6A:	jsr     _upgrade_show_ablity_desc
;
; if (pad1_new & PAD_UP) {
;
L1284:	lda     _pad1_new
	and     #$08
	beq     L1286
;
; sfx_play(SND_MENU_MOVE, 0);
;
	lda     #$00
	jsr     pusha
	jsr     _sfx_play
;
; if (player.abilities.selection == 0) player.abilities.selection = ABILITIES_COUNT - 1;
;
	lda     _player+16
	bne     L1285
	lda     #$04
	sta     _player+16
;
; else --player.abilities.selection;
;
	jmp     L0F76
L1285:	dec     _player+16
;
; upgrade_show_ablity_desc();
;
L0F76:	jsr     _upgrade_show_ablity_desc
;
; if (pad1_new & PAD_B) {
;
L1286:	lda     _pad1_new
	and     #$40
	jeq     L1295
;
; if (tmp != ABILITY_MAX_LEVEL && points >= index) {
;
	lda     _tmp
	cmp     #$05
	jeq     L0F7B
	lda     _points
	cmp     _index
	jcc     L0F7B
;
; sfx_play(SND_MENU_UPGRADE, 0);
;
	lda     #$02
	jsr     pusha
	lda     #$00
	jsr     _sfx_play
;
; ++tmp;
;
	inc     _tmp
;
; points -= index;
;
	lda     _index
	eor     #$FF
	sec
	adc     _points
	sta     _points
;
; upgrade_recalc_ability_cost();
;
	jsr     _upgrade_recalc_ability_cost
;
; upgrade_show_current_points();
;
	jsr     _upgrade_show_current_points
;
; one_vram_buffer(CHR_FCELL_TOP, NTADR_A(0x06 + tmp, 0x04 + player.abilities.selection * 3));
;
	lda     #$23
	jsr     pusha
	ldx     #$00
	lda     _player+16
	jsr     mulax3
	clc
	adc     #$04
	bcc     L0F8E
	inx
L0F8E:	jsr     shlax4
	stx     tmp1
	asl     a
	rol     tmp1
	sta     ptr1
	ldx     #$00
	lda     _tmp
	clc
	adc     #$06
	bcc     L0F90
	inx
L0F90:	ora     ptr1
	pha
	txa
	ora     tmp1
	tax
	pla
	pha
	txa
	ora     #$20
	tax
	pla
	jsr     _one_vram_buffer
;
; one_vram_buffer(CHR_FCELL_BOTTOM, NTADR_A(0x06 + tmp, 0x05 + player.abilities.selection * 3));
;
	lda     #$25
	jsr     pusha
	ldx     #$00
	lda     _player+16
	jsr     mulax3
	clc
	adc     #$05
	bcc     L0F98
	inx
L0F98:	jsr     shlax4
	stx     tmp1
	asl     a
	rol     tmp1
	sta     ptr1
	ldx     #$00
	lda     _tmp
	clc
	adc     #$06
	bcc     L0F9A
	inx
L0F9A:	ora     ptr1
	pha
	txa
	ora     tmp1
	tax
	pla
	pha
	txa
	ora     #$20
	tax
	pla
	jsr     _one_vram_buffer
;
; player.abilities.list[player.abilities.selection] = tmp;
;
	ldy     _player+16
	lda     _tmp
	sta     _player+17,y
;
; switch(player.abilities.selection) {
;
	lda     _player+16
;
; }
;
	beq     L128E
	cmp     #$01
	beq     L128A
	cmp     #$02
	beq     L1289
	cmp     #$03
	beq     L128F
	cmp     #$04
	beq     L1294
	jmp     L1295
;
; ++player.cut.size; 
;
L1289:	inc     _player+10
;
; break;
;
	jmp     L1295
;
; if (tmp == 1 || tmp == 3 || tmp == 5) ++player.cut.power; 
;
L128A:	lda     _tmp
	cmp     #$01
	beq     L128D
	cmp     #$03
	beq     L128D
	cmp     #$05
	bne     L1295
L128D:	inc     _player+9
;
; break;
;
	jmp     L1295
;
; --player.cut.max_delay; 
;
L128E:	dec     _player+13
;
; break;
;
	jmp     L1295
;
; if (player.move_max_delay == 0) {
;
L128F:	lda     _player+5
	bne     L1292
;
; if (player.move_max_increase == 0) player.move_max_increase = 3;
;
	lda     _player+7
	bne     L1290
	lda     #$03
	sta     _player+7
;
; else --player.move_max_increase;
;
	jmp     L1291
L1290:	dec     _player+7
;
; player.move_increase = player.move_max_increase;
;
L1291:	lda     _player+7
	sta     _player+6
;
; } else {
;
	jmp     L1293
;
; --player.move_max_delay; 
;
L1292:	dec     _player+5
;
; if (tmp == ABILITY_MAX_LEVEL) upgrade_draw_desc(player.abilities.elevel);
;
L1293:	lda     _tmp
	cmp     #$05
	bne     L1295
	lda     _player+22
	jsr     _upgrade_draw_desc
;
; break;
;
	jmp     L1295
;
; ++player.abilities.elevel;
;
L1294:	inc     _player+22
;
; upgrade_draw_desc(player.abilities.elevel);
;
	lda     _player+22
	jsr     _upgrade_draw_desc
;
; break;
;
	jmp     L1295
;
; sfx_play(SND_MENU_ERROR, 0);
;
L0F7B:	lda     #$03
	jsr     pusha
	lda     #$00
	jsr     _sfx_play
;
; if (pad1_new & PAD_START) state = 1;
;
L1295:	lda     _pad1_new
	and     #$10
	beq     L0FC9
	lda     #$01
	sta     _state
;
; } 
;
L0FC9:	rts

.endproc

; ---------------------------------------------------------------
; void __near__ upgrade_draw_desc (unsigned char)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_upgrade_draw_desc: near

.segment	"CODE"

;
; void upgrade_draw_desc(char abil_num) {
;
	jsr     pusha
;
; switch (abil_num) {
;
	ldy     #$00
	lda     (sp),y
;
; }
;
	cmp     #$01
	beq     L0ECD
	cmp     #$02
	beq     L0EE3
	cmp     #$03
	beq     L0EF9
	cmp     #$04
	jeq     L0F0F
	cmp     #$05
	jeq     L0F25
	jmp     incsp1
;
; case 1: multi_vram_buffer_horz(" SMALL SCYTHE ", 0x0E, NTADR_A(0x0E, 0x04));
;
L0ECD:	jsr     decsp3
	lda     #<(L0ECF)
	iny
	sta     (sp),y
	iny
	lda     #>(L0ECF)
	sta     (sp),y
	lda     #$0E
	ldy     #$00
	sta     (sp),y
	ldx     #$20
	lda     #$8E
	jsr     _multi_vram_buffer_horz
;
; multi_vram_buffer_horz(" \\ [ A        ", 0x0E, NTADR_A(0x0E, 0x05));
;
	jsr     decsp3
	lda     #<(L0ED9)
	ldy     #$01
	sta     (sp),y
	iny
	lda     #>(L0ED9)
	sta     (sp),y
	lda     #$0E
	ldy     #$00
	sta     (sp),y
	ldx     #$20
	lda     #$AE
;
; break;
;
	jmp     L1296
;
; case 2: multi_vram_buffer_horz(" DASH         ", 0x0E, NTADR_A(0x0E, 0x07));
;
L0EE3:	jsr     decsp3
	lda     #<(L0EE5)
	iny
	sta     (sp),y
	iny
	lda     #>(L0EE5)
	sta     (sp),y
	lda     #$0E
	ldy     #$00
	sta     (sp),y
	ldx     #$20
	lda     #$EE
	jsr     _multi_vram_buffer_horz
;
; multi_vram_buffer_horz(" ^ ^ OR _ _   ", 0x0E, NTADR_A(0x0E, 0x08));
;
	jsr     decsp3
	lda     #<(L0EEF)
	ldy     #$01
	sta     (sp),y
	iny
	lda     #>(L0EEF)
	sta     (sp),y
	lda     #$0E
	ldy     #$00
	sta     (sp),y
	ldx     #$21
;
; break;
;
	jmp     L1296
;
; case 3: multi_vram_buffer_horz(" ABILITIES    ", 0x0E, NTADR_A(0x0E, 0x10));
;
L0EF9:	jsr     decsp3
	lda     #<(L0EFB)
	iny
	sta     (sp),y
	iny
	lda     #>(L0EFB)
	sta     (sp),y
	lda     #$0E
	ldy     #$00
	sta     (sp),y
	ldx     #$22
	jsr     _multi_vram_buffer_horz
;
; multi_vram_buffer_horz(" POWER[       ", 0x0E,  NTADR_A(0x0E, 0x11));
;
	jsr     decsp3
	lda     #<(L0F05)
	ldy     #$01
	sta     (sp),y
	iny
	lda     #>(L0F05)
	sta     (sp),y
	lda     #$0E
	ldy     #$00
	sta     (sp),y
	ldx     #$22
	lda     #$2E
;
; break;
;
	jmp     L1296
;
; case 4: multi_vram_buffer_horz(" POWER SLASH  ", 0x0E, NTADR_A(0x0E, 0x0A));
;
L0F0F:	jsr     decsp3
	lda     #<(L0F11)
	iny
	sta     (sp),y
	iny
	lda     #>(L0F11)
	sta     (sp),y
	lda     #$0E
	ldy     #$00
	sta     (sp),y
	ldx     #$21
	lda     #$4E
	jsr     _multi_vram_buffer_horz
;
; multi_vram_buffer_horz(" ] ] ]        ", 0x0E,  NTADR_A(0x0E, 0x0B));
;
	jsr     decsp3
	lda     #<(L0F1B)
	ldy     #$01
	sta     (sp),y
	iny
	lda     #>(L0F1B)
	sta     (sp),y
	lda     #$0E
	ldy     #$00
	sta     (sp),y
	ldx     #$21
	lda     #$6E
;
; break;
;
	jmp     L1296
;
; case 5: multi_vram_buffer_horz("[", 0x01,  NTADR_A(0x15, 0x11));
;
L0F25:	jsr     decsp3
	lda     #<(L0F27)
	iny
	sta     (sp),y
	iny
	lda     #>(L0F27)
	sta     (sp),y
	lda     #$01
	ldy     #$00
	sta     (sp),y
	ldx     #$22
	lda     #$35
	jsr     _multi_vram_buffer_horz
;
; if (player.abilities.list[ABILITY_MOVE_SPEED] == ABILITY_MAX_LEVEL) {
;
	lda     _player+20
	cmp     #$05
	bne     L0ECB
;
; multi_vram_buffer_horz(" MOVE AND CUT ", 0x0E,  NTADR_A(0x0E, 0x0D));
;
	jsr     decsp3
	lda     #<(L0F34)
	ldy     #$01
	sta     (sp),y
	iny
	lda     #>(L0F34)
	sta     (sp),y
	lda     #$0E
	ldy     #$00
	sta     (sp),y
	ldx     #$21
	lda     #$AE
	jsr     _multi_vram_buffer_horz
;
; multi_vram_buffer_horz(" ACTIVATED    ", 0x0E ,  NTADR_A(0x0E, 0x0E));
;
	jsr     decsp3
	lda     #<(L0F3E)
	ldy     #$01
	sta     (sp),y
	iny
	lda     #>(L0F3E)
	sta     (sp),y
	lda     #$0E
	ldy     #$00
	sta     (sp),y
	ldx     #$21
	lda     #$CE
L1296:	jsr     _multi_vram_buffer_horz
;
; }
;
L0ECB:	jmp     incsp1

.endproc

; ---------------------------------------------------------------
; void __near__ upgrade_draw_icon (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_upgrade_draw_icon: near

.segment	"CODE"

;
; vram_adr(adr);
;
	lda     _adr
	ldx     _adr+1
	jsr     _vram_adr
;
; vram_put(abilities_icons[index]);
;
	ldy     _index
	lda     _abilities_icons,y
	jsr     _vram_put
;
; ++index;
;
	inc     _index
;
; vram_put(abilities_icons[index]);
;
	ldy     _index
	lda     _abilities_icons,y
	jsr     _vram_put
;
; ++index;
;
	inc     _index
;
; vram_put(0x00);
;
	lda     #$00
	jmp     _vram_put

.endproc

; ---------------------------------------------------------------
; void __near__ upgrade_recalc_ability_cost (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_upgrade_recalc_ability_cost: near

.segment	"CODE"

;
; if (tmp < 5) {
;
	lda     _tmp
	cmp     #$05
	bcs     L1014
;
; index = upgrade_cost[player.abilities.selection * ABILITY_MAX_LEVEL + tmp];
;
	ldx     #$00
	lda     _player+16
	jsr     mulax5
	clc
	adc     _tmp
	bcc     L1297
	inx
L1297:	sta     ptr1
	txa
	clc
	adc     #>(_upgrade_cost)
	sta     ptr1+1
	ldy     #<(_upgrade_cost)
	lda     (ptr1),y
	sta     _index
;
; one_vram_buffer(CHR_ZERO + index, NTADR_A(0x0F, 0x19));
;
	clc
	adc     #$30
	jsr     pusha
	ldx     #$23
	lda     #$2F
	jmp     _one_vram_buffer
;
; one_vram_buffer(CHR_BG_BLANK, NTADR_A(0x0F, 0x19));
;
L1014:	lda     #$7F
	jsr     pusha
	ldx     #$23
	lda     #$2F
	jmp     _one_vram_buffer

.endproc

; ---------------------------------------------------------------
; void __near__ upgrade_show_ablity_desc (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_upgrade_show_ablity_desc: near

.segment	"CODE"

;
; adr = NTADR_A(0x04, 0x19);
;
	ldx     #$23
	lda     #$24
	sta     _adr
	stx     _adr+1
;
; switch(player.abilities.selection) {
;
	lda     _player+16
;
; }
;
	beq     L0FFA
	cmp     #$01
	beq     L0FF3
	cmp     #$02
	beq     L0FEC
	cmp     #$03
	beq     L1001
	cmp     #$04
	beq     L1008
	jmp     L0FEA
;
; case ABILITY_CUT_SIZE: multi_vram_buffer_horz("CUT WIDTH ", 0x0A, adr); break;
;
L0FEC:	jsr     decsp3
	lda     #<(L0FEE)
	ldy     #$01
	sta     (sp),y
	iny
	lda     #>(L0FEE)
	jmp     L129E
;
; case ABILITY_CUT_POWER: multi_vram_buffer_horz("CUT POWER ", 0x0A, adr); break;
;
L0FF3:	jsr     decsp3
	lda     #<(L0FF5)
	ldy     #$01
	sta     (sp),y
	iny
	lda     #>(L0FF5)
	jmp     L129E
;
; case ABILITY_CUT_SPEED: multi_vram_buffer_horz("CUT SPEED ", 0x0A, adr); break;
;
L0FFA:	jsr     decsp3
	lda     #<(L0FFC)
	ldy     #$01
	sta     (sp),y
	iny
	lda     #>(L0FFC)
	jmp     L129E
;
; case ABILITY_MOVE_SPEED: multi_vram_buffer_horz("MOVE SPEED", 0x0A, adr); break;
;
L1001:	jsr     decsp3
	lda     #<(L1003)
	ldy     #$01
	sta     (sp),y
	iny
	lda     #>(L1003)
	jmp     L129E
;
; case ABILITY_SPECIAL: multi_vram_buffer_horz("SPECIAL   ", 0x0A, adr); break;
;
L1008:	jsr     decsp3
	lda     #<(L100A)
	ldy     #$01
	sta     (sp),y
	iny
	lda     #>(L100A)
L129E:	sta     (sp),y
	lda     #$0A
	ldy     #$00
	sta     (sp),y
	lda     _adr
	ldx     _adr+1
	jsr     _multi_vram_buffer_horz
;
; tmp = player.abilities.list[player.abilities.selection];
;
L0FEA:	ldy     _player+16
	lda     _player+17,y
	sta     _tmp
;
; upgrade_recalc_ability_cost();
;
	jmp     _upgrade_recalc_ability_cost

.endproc

; ---------------------------------------------------------------
; void __near__ upgrade_show_current_points (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_upgrade_show_current_points: near

.segment	"CODE"

;
; one_vram_buffer(CHR_ZERO + points / 10, NTADR_A(0x1A, 0x19));
;
	lda     _points
	jsr     pusha0
	lda     #$0A
	jsr     tosudiva0
	clc
	adc     #$30
	jsr     pusha
	ldx     #$23
	lda     #$3A
	jsr     _one_vram_buffer
;
; one_vram_buffer(CHR_ZERO + points % 10, NTADR_A(0x1B, 0x19));
;
	lda     _points
	jsr     pusha0
	lda     #$0A
	jsr     tosumoda0
	clc
	adc     #$30
	jsr     pusha
	ldx     #$23
	lda     #$3B
	jmp     _one_vram_buffer

.endproc

; ---------------------------------------------------------------
; void __near__ title_draw_background (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_title_draw_background: near

.segment	"CODE"

;
; ppu_off();
;
	jsr     _ppu_off
;
; pal_bg(title_palette_bg);
;
	lda     #<(_title_palette_bg)
	ldx     #>(_title_palette_bg)
	jsr     _pal_bg
;
; pal_spr(title_palette_sp);
;
	lda     #<(_title_palette_sp)
	ldx     #>(_title_palette_sp)
	jsr     _pal_spr
;
; clear_screen();
;
	jsr     _clear_screen
;
; vram_adr(PPU_PALLETE);
;
	ldx     #$23
	lda     #$C0
	jsr     _vram_adr
;
; for(x = 0x00; x != 0x40; ++x) vram_put(0);
;
	lda     #$00
	sta     _x
L129F:	lda     _x
	cmp     #$40
	beq     L069D
	lda     #$00
	jsr     _vram_put
	inc     _x
	jmp     L129F
;
; ppu_on_all();
;
L069D:	jsr     _ppu_on_all
;
; delay(30);
;
	lda     #$1E
	jsr     _delay
;
; oam_clear();
;
	jsr     _oam_clear
;
; x = state = 0;
;
	lda     #$00
	sta     _state
	sta     _x
;
; y = 8;
;
	lda     #$08
	sta     _y
;
; sfx_play(SND_MENU_HIT, 0);
;
	lda     #$05
	jsr     pusha
	lda     #$00
	jsr     _sfx_play
;
; oam_spr(LOGO[0] + LOGO_X_OFFSET, LOGO[1] + LOGO_Y_OFFSET, LOGO[2], LOGO[3]);
;
	jsr     decsp3
	lda     _LOGO
	clc
	adc     #$48
	ldy     #$02
	sta     (sp),y
	lda     _LOGO+1
	clc
	adc     #$19
	dey
	sta     (sp),y
	lda     _LOGO+2
	dey
	sta     (sp),y
	lda     _LOGO+3
	jsr     _oam_spr
;
; delay_with_state_skip(40);
;
	lda     #$28
	jsr     _delay_with_state_skip
;
; sfx_play(SND_MENU_HIT, 0);
;
	lda     #$05
	jsr     pusha
	lda     #$00
	jsr     _sfx_play
;
; oam_spr(LOGO[4] + LOGO_X_OFFSET, LOGO[5] + LOGO_Y_OFFSET, LOGO[6], LOGO[7]);
;
	jsr     decsp3
	lda     _LOGO+4
	clc
	adc     #$48
	ldy     #$02
	sta     (sp),y
	lda     _LOGO+5
	clc
	adc     #$19
	dey
	sta     (sp),y
	lda     _LOGO+6
	dey
	sta     (sp),y
	lda     _LOGO+7
	jsr     _oam_spr
;
; delay_with_state_skip(40);
;
	lda     #$28
	jsr     _delay_with_state_skip
;
; nmi_wait_and_prepare();
;
L06CF:	jsr     _nmi_wait_and_prepare
;
; if (state == 1) break;
;
	lda     _state
	cmp     #$01
	jeq     L06D0
;
; if (pad1_new & PAD_START) state = 1;
;
	lda     _pad1_new
	and     #$10
	beq     L12A0
	lda     #$01
	sta     _state
;
; ++x;
;
L12A0:	inc     _x
;
; if (x == 0x05) {
;
	lda     _x
	cmp     #$05
	bne     L06CF
;
; x = 0;
;
	lda     #$00
	sta     _x
;
; sfx_play(SND_MENU_HIT, 0);
;
	lda     #$05
	jsr     pusha
	lda     #$00
	jsr     _sfx_play
;
; oam_spr(LOGO[y] + LOGO_X_OFFSET, LOGO[y + 1] + LOGO_Y_OFFSET, LOGO[y + 2], LOGO[y + 3]);
;
	jsr     decsp3
	ldy     _y
	lda     _LOGO,y
	clc
	adc     #$48
	ldy     #$02
	sta     (sp),y
	ldx     #$00
	lda     _y
	clc
	adc     #$01
	bcc     L06E9
	inx
L06E9:	sta     ptr1
	txa
	clc
	adc     #>(_LOGO)
	sta     ptr1+1
	ldy     #<(_LOGO)
	lda     (ptr1),y
	clc
	adc     #$19
	ldy     #$01
	sta     (sp),y
	ldx     #$00
	lda     _y
	clc
	adc     #$02
	bcc     L06ED
	inx
L06ED:	sta     ptr1
	txa
	clc
	adc     #>(_LOGO)
	sta     ptr1+1
	ldy     #<(_LOGO)
	lda     (ptr1),y
	ldy     #$00
	sta     (sp),y
	ldx     #$00
	lda     _y
	clc
	adc     #$03
	bcc     L06F0
	inx
L06F0:	sta     ptr1
	txa
	clc
	adc     #>(_LOGO)
	sta     ptr1+1
	ldy     #<(_LOGO)
	lda     (ptr1),y
	jsr     _oam_spr
;
; y += 4;
;
	lda     #$04
	clc
	adc     _y
	sta     _y
;
; if (y == LOGO_TILE_COUNT * 4) break;
;
	cmp     #$7C
	jne     L06CF
;
; delay_with_state_skip(60);
;
L06D0:	lda     #$3C
	jsr     _delay_with_state_skip
;
; if (state == 0) sfx_play(SND_GAME_LIGHTNING, 0);
;
	lda     _state
	bne     L06F7
	lda     #$09
	jsr     pusha
	lda     #$00
	jsr     _sfx_play
;
; multi_vram_buffer_horz("ONE THOUSAND MAN", 0x10, NTADR_A(0x08, 0x0C));
;
L06F7:	jsr     decsp3
	lda     #<(L06FD)
	ldy     #$01
	sta     (sp),y
	iny
	lda     #>(L06FD)
	sta     (sp),y
	lda     #$10
	ldy     #$00
	sta     (sp),y
	ldx     #$21
	lda     #$88
	jsr     _multi_vram_buffer_horz
;
; delay_with_state_skip(90);
;
	lda     #$5A
	jmp     _delay_with_state_skip

.endproc

; ---------------------------------------------------------------
; void __near__ title_draw_options (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_title_draw_options: near

.segment	"CODE"

;
; multi_vram_buffer_horz(game.effects.lightning_enabled == 0 ? "OFF": "ON ", 0x03, NTADR_A(0x14, 0x13));
;
	jsr     decsp3
	lda     _game+9
	bne     L05F6
	lda     #<(L05F5)
	ldx     #>(L05F5)
	jmp     L05F9
L05F6:	lda     #<(L05F8)
	ldx     #>(L05F8)
L05F9:	ldy     #$01
	sta     (sp),y
	iny
	txa
	sta     (sp),y
	lda     #$03
	ldy     #$00
	sta     (sp),y
	ldx     #$22
	lda     #$74
	jsr     _multi_vram_buffer_horz
;
; multi_vram_buffer_horz(game.last_level == 0 ? "ON" : "OFF ", 0x03, NTADR_A(0x14, 0x11));
;
	jsr     decsp3
	lda     _game+1
	bne     L0605
	lda     #<(L0604)
	ldx     #>(L0604)
	jmp     L0608
L0605:	lda     #<(L0607)
	ldx     #>(L0607)
L0608:	ldy     #$01
	sta     (sp),y
	iny
	txa
	sta     (sp),y
	lda     #$03
	ldy     #$00
	sta     (sp),y
	ldx     #$22
	lda     #$34
	jsr     _multi_vram_buffer_horz
;
; switch(game.difficulty) {
;
	lda     _game+6
;
; }
;
	beq     L0615
	cmp     #$01
	beq     L0621
	cmp     #$02
	beq     L062D
	rts
;
; case 0: multi_vram_buffer_horz("EASY  ", 0x06, NTADR_A(0x14, 0x0F)); break;
;
L0615:	jsr     decsp3
	lda     #<(L0617)
	ldy     #$01
	sta     (sp),y
	iny
	lda     #>(L0617)
	sta     (sp),y
	lda     #$06
	ldy     #$00
	sta     (sp),y
	ldx     #$21
	lda     #$F4
	jmp     _multi_vram_buffer_horz
;
; case 1: multi_vram_buffer_horz("NORMAL", 0x06, NTADR_A(0x14, 0x0F)); break;
;
L0621:	jsr     decsp3
	lda     #<(L0623)
	ldy     #$01
	sta     (sp),y
	iny
	lda     #>(L0623)
	sta     (sp),y
	lda     #$06
	ldy     #$00
	sta     (sp),y
	ldx     #$21
	lda     #$F4
	jmp     _multi_vram_buffer_horz
;
; case 2: multi_vram_buffer_horz("HARD  ", 0x06, NTADR_A(0x14, 0x0F)); break;
;
L062D:	jsr     decsp3
	lda     #<(L062F)
	ldy     #$01
	sta     (sp),y
	iny
	lda     #>(L062F)
	sta     (sp),y
	lda     #$06
	ldy     #$00
	sta     (sp),y
	ldx     #$21
	lda     #$F4
	jmp     _multi_vram_buffer_horz

.endproc

; ---------------------------------------------------------------
; void __near__ title_draw_menu (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_title_draw_menu: near

.segment	"CODE"

;
; for (index = 0; index != 4; ++index)
;
	lda     #$00
	sta     _index
L12A3:	lda     _index
	cmp     #$04
	beq     L063A
;
; multi_vram_buffer_horz("                    ", 0x14, NTADR_A(0x09, 0x0F + index + index));
;
	jsr     decsp3
	lda     #<(L0642)
	ldy     #$01
	sta     (sp),y
	iny
	lda     #>(L0642)
	sta     (sp),y
	lda     #$14
	ldy     #$00
	sta     (sp),y
	ldx     #$00
	lda     _index
	clc
	adc     #$0F
	bcc     L12A2
	inx
	clc
L12A2:	adc     _index
	bcc     L12A1
	inx
L12A1:	jsr     shlax4
	stx     tmp1
	asl     a
	rol     tmp1
	ora     #$09
	pha
	lda     tmp1
	ora     #$20
	tax
	pla
	jsr     _multi_vram_buffer_horz
;
; for (index = 0; index != 4; ++index)
;
	inc     _index
	jmp     L12A3
;
; nmi_wait_and_prepare();
;
L063A:	jsr     _nmi_wait_and_prepare
;
; switch (game.state) {
;
	lda     _game+3
;
; }
;
	beq     L0651
	cmp     #$04
	beq     L0667
	jmp     L12A4
;
; multi_vram_buffer_horz("START", 0x05, NTADR_A(0x0D, 0x0F));
;
L0651:	jsr     decsp3
	lda     #<(L0653)
	ldy     #$01
	sta     (sp),y
	iny
	lda     #>(L0653)
	sta     (sp),y
	lda     #$05
	ldy     #$00
	sta     (sp),y
	ldx     #$21
	lda     #$ED
	jsr     _multi_vram_buffer_horz
;
; multi_vram_buffer_horz("OPTIONS", 0x07, NTADR_A(0x0D, 0x11));
;
	jsr     decsp3
	lda     #<(L065D)
	ldy     #$01
	sta     (sp),y
	iny
	lda     #>(L065D)
	sta     (sp),y
	lda     #$07
	ldy     #$00
	sta     (sp),y
	ldx     #$22
	lda     #$2D
	jsr     _multi_vram_buffer_horz
;
; break;
;
	jmp     L12A4
;
; multi_vram_buffer_horz("LEVEL   ", 0x08, NTADR_A(0x09, 0x0F));
;
L0667:	jsr     decsp3
	lda     #<(L0669)
	ldy     #$01
	sta     (sp),y
	iny
	lda     #>(L0669)
	sta     (sp),y
	lda     #$08
	ldy     #$00
	sta     (sp),y
	ldx     #$21
	lda     #$E9
	jsr     _multi_vram_buffer_horz
;
; multi_vram_buffer_horz("ENDLESS ", 0x08, NTADR_A(0x09, 0x11));
;
	jsr     decsp3
	lda     #<(L0673)
	ldy     #$01
	sta     (sp),y
	iny
	lda     #>(L0673)
	sta     (sp),y
	lda     #$08
	ldy     #$00
	sta     (sp),y
	ldx     #$22
	lda     #$29
	jsr     _multi_vram_buffer_horz
;
; multi_vram_buffer_horz("FLASH   ", 0x08, NTADR_A(0x09, 0x13));
;
	jsr     decsp3
	lda     #<(L067D)
	ldy     #$01
	sta     (sp),y
	iny
	lda     #>(L067D)
	sta     (sp),y
	lda     #$08
	ldy     #$00
	sta     (sp),y
	ldx     #$22
	lda     #$69
	jsr     _multi_vram_buffer_horz
;
; multi_vram_buffer_horz("RETURN  ", 0x08, NTADR_A(0x09, 0x15));
;
	jsr     decsp3
	lda     #<(L0687)
	ldy     #$01
	sta     (sp),y
	iny
	lda     #>(L0687)
	sta     (sp),y
	lda     #$08
	ldy     #$00
	sta     (sp),y
	ldx     #$22
	lda     #$A9
	jsr     _multi_vram_buffer_horz
;
; title_draw_options();
;
	jsr     _title_draw_options
;
; index = 0;
;
L12A4:	lda     #$00
	sta     _index
;
; }
;
	rts

.endproc

; ---------------------------------------------------------------
; void __near__ title_check_cheat_code (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_title_check_cheat_code: near

.segment	"CODE"

;
; if (marker < 10) {
;
	lda     _marker
	cmp     #$0A
	jcs     L12BB
;
; if (pad1_new & PAD_UP) {
;
	lda     _pad1_new
	and     #$08
	beq     L12AB
;
; if (marker == 0 || marker == 1) ++marker; else marker = 0;
;
	lda     _marker
	beq     L12A8
	cmp     #$01
	beq     L12A8
	lda     #$00
	jmp     L12AA
L12A8:	inc     _marker
	jmp     L12AB
L12AA:	sta     _marker
;
; if (pad1_new & PAD_DOWN) {
;
L12AB:	lda     _pad1_new
	and     #$04
	beq     L12AF
;
; if (marker == 2 || marker == 3) ++marker; else marker = 0;
;
	lda     _marker
	cmp     #$02
	beq     L12AC
	cmp     #$03
	beq     L12AC
	lda     #$00
	jmp     L12AE
L12AC:	inc     _marker
	jmp     L12AF
L12AE:	sta     _marker
;
; if (pad1_new & PAD_LEFT) {
;
L12AF:	lda     _pad1_new
	and     #$02
	beq     L12B3
;
; if (marker == 4 || marker == 6) ++marker; else marker = 0;
;
	lda     _marker
	cmp     #$04
	beq     L12B0
	cmp     #$06
	beq     L12B0
	lda     #$00
	jmp     L12B2
L12B0:	inc     _marker
	jmp     L12B3
L12B2:	sta     _marker
;
; if (pad1_new & PAD_RIGHT) {
;
L12B3:	lda     _pad1_new
	and     #$01
	beq     L12B7
;
; if (marker == 5 || marker == 7) ++marker; else marker = 0;
;
	lda     _marker
	cmp     #$05
	beq     L12B4
	cmp     #$07
	beq     L12B4
	lda     #$00
	jmp     L12B6
L12B4:	inc     _marker
	jmp     L12B7
L12B6:	sta     _marker
;
; if (pad1_new & PAD_B) {
;
L12B7:	lda     _pad1_new
	and     #$40
	beq     L12B9
;
; if (marker == 8) ++marker; else marker = 0;
;
	lda     _marker
	cmp     #$08
	bne     L12B8
	inc     _marker
	jmp     L12B9
L12B8:	lda     #$00
	sta     _marker
;
; if (pad1_new & PAD_A) {
;
L12B9:	lda     _pad1_new
	and     #$80
	bne     L12CD
;
; }
;
	rts
;
; if (marker == 9) {
;
L12CD:	lda     _marker
	cmp     #$09
	bne     L12BA
;
; ++marker;
;
	inc     _marker
;
; sfx_play(SND_MENU_ERROR, 0);
;
	lda     #$03
	jsr     pusha
	lda     #$00
	jsr     _sfx_play
;
; multi_vram_buffer_horz("KONAMI CODE NOT FOUND", 0x15, NTADR_A(0x06, 0x17));
;
	jsr     decsp3
	lda     #<(L0740)
	ldy     #$01
	sta     (sp),y
	iny
	lda     #>(L0740)
	sta     (sp),y
	lda     #$15
	ldy     #$00
	sta     (sp),y
	ldx     #$22
	lda     #$E6
	jmp     _multi_vram_buffer_horz
;
; marker = 0;
;
L12BA:	lda     #$00
	sta     _marker
;
; } else if (marker < 249) {
;
	rts
L12BB:	lda     _marker
	cmp     #$F9
	bcc     L12CE
;
; }
;
	rts
;
; ++marker;
;
L12CE:	inc     _marker
;
; if ((marker - 10) % 20 == 0) {
;
	ldx     #$00
	lda     _marker
	sec
	sbc     #$0A
	bcs     L0753
	dex
L0753:	jsr     pushax
	lda     #$14
	jsr     tosumoda0
	cpx     #$00
	bne     L0762
	cmp     #$00
	bne     L0762
;
; if (marker > 130) {
;
	lda     _marker
	cmp     #$83
	bcc     L0755
;
; one_vram_buffer(CHR_DOT, NTADR_A(0x08 + (marker - 120) / 10, 0x19));
;
	lda     #$3B
	jsr     pusha
	lda     _marker
	sec
	sbc     #$78
	bcs     L0760
	dex
L0760:	jsr     pushax
;
; } else {
;
	jmp     L12CC
;
; one_vram_buffer(CHR_DOT, NTADR_A(0x08 + marker / 10, 0x19));
;
L0755:	lda     #$3B
	jsr     pusha
	lda     _marker
	jsr     pusha0
L12CC:	lda     #$0A
	jsr     tosudiva0
	clc
	adc     #$08
	bcc     L076B
	inx
L076B:	ora     #$20
	pha
	txa
	ora     #$03
	tax
	pla
	pha
	txa
	ora     #$20
	tax
	pla
	jsr     _one_vram_buffer
;
; if (marker == 140) {
;
L0762:	lda     _marker
	cmp     #$8C
	bne     L12BC
;
; multi_vram_buffer_horz("SEARCHING FOR ALTERNATIVES", 0x1A, NTADR_A(0x03, 0x17));
;
	jsr     decsp3
	lda     #<(L076F)
	ldy     #$01
	sta     (sp),y
	iny
	lda     #>(L076F)
	sta     (sp),y
	lda     #$1A
	ldy     #$00
	sta     (sp),y
	ldx     #$22
	lda     #$E3
	jsr     _multi_vram_buffer_horz
;
; multi_vram_buffer_horz("                 ", 0x11, NTADR_A(0x0A, 0x19));
;
	jsr     decsp3
	lda     #<(L0779)
	ldy     #$01
	sta     (sp),y
	iny
	lda     #>(L0779)
	sta     (sp),y
	lda     #$11
	ldy     #$00
	sta     (sp),y
	ldx     #$23
	lda     #$2A
	jsr     _multi_vram_buffer_horz
;
; if (marker == 249) {
;
L12BC:	lda     _marker
	cmp     #$F9
	bne     L0782
;
; multi_vram_buffer_horz("   KOSARI CODE ACTIVATED  ", 0x1A, NTADR_A(0x03, 0x17));
;
	jsr     decsp3
	lda     #<(L0785)
	ldy     #$01
	sta     (sp),y
	iny
	lda     #>(L0785)
	sta     (sp),y
	lda     #$1A
	ldy     #$00
	sta     (sp),y
	ldx     #$22
	lda     #$E3
	jsr     _multi_vram_buffer_horz
;
; multi_vram_buffer_horz("                 ", 0x11, NTADR_A(0x0B, 0x19));
;
	jsr     decsp3
	lda     #<(L078F)
	ldy     #$01
	sta     (sp),y
	iny
	lda     #>(L078F)
	sta     (sp),y
	lda     #$11
	ldy     #$00
	sta     (sp),y
	ldx     #$23
	lda     #$2B
	jsr     _multi_vram_buffer_horz
;
; sfx_play(SND_MENU_START, 0);
;
	lda     #$01
	jsr     pusha
	lda     #$00
	jsr     _sfx_play
;
; points = 99;
;
	lda     #$63
	sta     _points
;
; }
;
L0782:	rts

.endproc

; ---------------------------------------------------------------
; void __near__ process_title (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_process_title: near

.segment	"CODE"

;
; title_draw_background();
;
	jsr     _title_draw_background
;
; title_draw_menu();
;
	jsr     _title_draw_menu
;
; music_play(MSC_MENU);
;
	lda     #$00
	jsr     _music_play
;
; x = state = 0;
;
	lda     #$00
	sta     _state
	sta     _x
;
; y = 0x15;
;
	lda     #$15
	sta     _y
;
; nmi_wait_and_prepare();
;
L0525:	jsr     _nmi_wait_and_prepare
;
; oam_clear();
;
	jsr     _oam_clear
;
; for(tmp = 0x00; tmp != LOGO_TILE_COUNT * 4; tmp += 4) {
;
	lda     #$00
L12D0:	sta     _tmp
	cmp     #$7C
	beq     L12D4
;
; oam_spr(LOGO[tmp] + LOGO_X_OFFSET, LOGO[tmp + 1] + LOGO_Y_OFFSET, LOGO[tmp + 2], LOGO[tmp + 3]);
;
	jsr     decsp3
	ldy     _tmp
	lda     _LOGO,y
	clc
	adc     #$48
	ldy     #$02
	sta     (sp),y
	ldx     #$00
	lda     _tmp
	clc
	adc     #$01
	bcc     L053B
	inx
L053B:	sta     ptr1
	txa
	clc
	adc     #>(_LOGO)
	sta     ptr1+1
	ldy     #<(_LOGO)
	lda     (ptr1),y
	clc
	adc     #$19
	ldy     #$01
	sta     (sp),y
	ldx     #$00
	lda     _tmp
	clc
	adc     #$02
	bcc     L053F
	inx
L053F:	sta     ptr1
	txa
	clc
	adc     #>(_LOGO)
	sta     ptr1+1
	ldy     #<(_LOGO)
	lda     (ptr1),y
	ldy     #$00
	sta     (sp),y
	ldx     #$00
	lda     _tmp
	clc
	adc     #$03
	bcc     L0542
	inx
L0542:	sta     ptr1
	txa
	clc
	adc     #>(_LOGO)
	sta     ptr1+1
	ldy     #<(_LOGO)
	lda     (ptr1),y
	jsr     _oam_spr
;
; for(tmp = 0x00; tmp != LOGO_TILE_COUNT * 4; tmp += 4) {
;
	lda     #$04
	clc
	adc     _tmp
	jmp     L12D0
;
; ++x;
;
L12D4:	inc     _x
;
; if (x == 0x06) { 
;
	lda     _x
	cmp     #$06
	bne     L12D6
;
; x = 0;
;
	lda     #$00
	sta     _x
;
; if (state == 0) {
;
	lda     _state
	bne     L12D5
;
; ++y;
;
	inc     _y
;
; if (y == 0x18) state = 1;
;
	lda     _y
	cmp     #$18
	bne     L12D6
	lda     #$01
;
; } else {
;
	jmp     L12D1
;
; --y;
;
L12D5:	dec     _y
;
; if (y == 0x15) state = 0;
;
	lda     _y
	cmp     #$15
	bne     L12D6
	lda     #$00
L12D1:	sta     _state
;
; if (state == 0) oam_spr(game.state == GAME_ST_MENU ? 0x5E : 0x3C, 0x77 + (menu_position * 0x10), y, 0b00000001);
;
L12D6:	lda     _state
	bne     L0555
	jsr     decsp3
	lda     _game+3
	bne     L12D7
	lda     #$5E
	jmp     L12D8
L12D7:	lda     #$3C
L12D8:	ldy     #$02
	sta     (sp),y
	lda     _index
	asl     a
	asl     a
	asl     a
	asl     a
	clc
	adc     #$77
	dey
	sta     (sp),y
	lda     _y
	dey
	sta     (sp),y
	lda     #$01
;
; else oam_spr(game.state == GAME_ST_MENU ? 0x5E : 0x3C, 0x76 + (menu_position * 0x10), y, 0b10000001);
;
	jmp     L12D2
L0555:	jsr     decsp3
	lda     _game+3
	bne     L12D9
	lda     #$5E
	jmp     L12DA
L12D9:	lda     #$3C
L12DA:	ldy     #$02
	sta     (sp),y
	lda     _index
	asl     a
	asl     a
	asl     a
	asl     a
	clc
	adc     #$76
	dey
	sta     (sp),y
	lda     _y
	dey
	sta     (sp),y
	lda     #$81
L12D2:	jsr     _oam_spr
;
; if (game.state == GAME_ST_MENU) title_check_cheat_code();
;
	lda     _game+3
	bne     L12DB
	jsr     _title_check_cheat_code
;
; if (pad1_new & PAD_DOWN || pad1_new & PAD_UP) {
;
L12DB:	lda     _pad1_new
	and     #$04
	bne     L12DC
	lda     _pad1_new
	and     #$08
	beq     L12E5
;
; sfx_play(SND_MENU_MOVE, 0);
;
L12DC:	lda     #$00
	jsr     pusha
	jsr     _sfx_play
;
; menu_items = game.state == GAME_ST_MENU ? 1 : 3;
;
	lda     _game+3
	bne     L12DD
	lda     #$01
	jmp     L12DE
L12DD:	lda     #$03
L12DE:	sta     _tmp
;
; if (pad1_new & PAD_DOWN) menu_position = menu_position == menu_items ? 0 : ++menu_position;
;
	lda     _pad1_new
	and     #$04
	beq     L12E1
	lda     _tmp
	cmp     _index
	bne     L12DF
	lda     #$00
	jmp     L12E0
L12DF:	inc     _index
	lda     _index
L12E0:	sta     _index
;
; if (pad1_new & PAD_UP) menu_position = menu_position == 0 ? menu_items : --menu_position;
;
L12E1:	lda     _pad1_new
	and     #$08
	beq     L12E5
	lda     _index
	bne     L12E2
	lda     _tmp
	jmp     L12E4
L12E2:	dec     _index
	lda     _index
L12E4:	sta     _index
;
; if (pad1_new & PAD_START) {
;
L12E5:	lda     _pad1_new
	and     #$10
	jeq     L0525
;
; switch (game.state) {
;
	lda     _game+3
;
; }
;
	beq     L12E6
	cmp     #$04
	jeq     L12EC
	jmp     L0525
;
; switch (menu_position) {
;
L12E6:	lda     _index
;
; }
;
	beq     L12E8
	cmp     #$01
	beq     L12EB
	jmp     L12EC
;
; x = y = state = 0;
;
L12E8:	sta     _state
	sta     _y
	sta     _x
;
; music_stop();
;
	jsr     _music_stop
;
; sfx_play(SND_MENU_START, 0);
;
	lda     #$01
	jsr     pusha
	lda     #$00
	jsr     _sfx_play
;
; ppu_wait_nmi();
;
L05A1:	jsr     _ppu_wait_nmi
;
; clear_vram_buffer();
;
	jsr     _clear_vram_buffer
;
; ++x;
;
	inc     _x
;
; if (x == 3) {
;
	lda     _x
	cmp     #$03
	bne     L05A1
;
; multi_vram_buffer_horz(state == 0 ? "START" : "     ", 0x05, NTADR_A(0x0D,0x0F));
;
	jsr     decsp3
	lda     _state
	bne     L05AD
	lda     #<(L05AC)
	ldx     #>(L05AC)
	jmp     L05B0
L05AD:	lda     #<(L05AF)
	ldx     #>(L05AF)
L05B0:	ldy     #$01
	sta     (sp),y
	iny
	txa
	sta     (sp),y
	lda     #$05
	ldy     #$00
	sta     (sp),y
	ldx     #$21
	lda     #$ED
	jsr     _multi_vram_buffer_horz
;
; state = state == 0 ? 1 : 0;
;
	lda     _state
	bne     L12E9
	lda     #$01
	jmp     L12EA
L12E9:	lda     #$00
L12EA:	sta     _state
;
; x = 0;
;
	lda     #$00
	sta     _x
;
; ++y;
;
	inc     _y
;
; if (y == 0x12) return;
;
	lda     _y
	cmp     #$12
	bne     L05A1
	rts
;
; game.state = GAME_ST_OPTIONS;
;
L12EB:	lda     #$04
	sta     _game+3
;
; menu_position = 0;
;
	lda     #$00
	sta     _index
;
; title_draw_menu();
;
	jsr     _title_draw_menu
;
; switch (menu_position) {
;
L12EC:	lda     _index
;
; }
;
	beq     L12ED
	cmp     #$01
	beq     L12F0
	cmp     #$02
	beq     L12F3
	cmp     #$03
	beq     L12F6
	jmp     L0525
;
; game.difficulty = game.difficulty == 2 ? 0 : ++game.difficulty;
;
L12ED:	lda     _game+6
	cmp     #$02
	bne     L12EE
	lda     #$00
	jmp     L12EF
L12EE:	inc     _game+6
	lda     _game+6
L12EF:	sta     _game+6
;
; title_draw_options();
;
	jsr     _title_draw_options
;
; break;
;
	jmp     L0525
;
; game.last_level = game.last_level == GAME_MAX_LEVEL ? 0 : GAME_MAX_LEVEL; 
;
L12F0:	lda     _game+1
	cmp     #$0C
	bne     L12F1
	lda     #$00
	jmp     L12F2
L12F1:	lda     #$0C
L12F2:	sta     _game+1
;
; title_draw_options();
;
	jsr     _title_draw_options
;
; break; 
;
	jmp     L0525
;
; game.effects.lightning_enabled = game.effects.lightning_enabled == 0 ? 1 : 0; 
;
L12F3:	lda     _game+9
	bne     L12F4
	lda     #$01
	jmp     L12F5
L12F4:	lda     #$00
L12F5:	sta     _game+9
;
; title_draw_options();
;
	jsr     _title_draw_options
;
; break;
;
	jmp     L0525
;
; game.state = GAME_ST_MENU;
;
L12F6:	lda     #$00
	sta     _game+3
;
; menu_position = 0;
;
	sta     _index
;
; title_draw_menu();
;
	jsr     _title_draw_menu
;
; break;
;
	jmp     L0525

.endproc

; ---------------------------------------------------------------
; void __near__ process_upgrades (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_process_upgrades: near

.segment	"CODE"

;
; upgrade_draw_background();
;
	jsr     _upgrade_draw_background
;
; upgrade_show_ablity_desc();
;
	jsr     _upgrade_show_ablity_desc
;
; nmi_wait_and_prepare();
;
L0E2A:	jsr     _nmi_wait_and_prepare
;
; upgrade_draw_sprites();
;
	jsr     _upgrade_draw_sprites
;
; upgrade_movement_and_actions();
;
	jsr     _upgrade_movement_and_actions
;
; if (state == 1) break;
;
	lda     _state
	cmp     #$01
	bne     L0E2A
	rts

.endproc

; ---------------------------------------------------------------
; void __near__ process_main_game (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_process_main_game: near

.segment	"CODE"

;
; game_process_next_level();
;
L07D4:	jsr     _game_process_next_level
;
; game_draw_background();
;
	jsr     _game_draw_background
;
; game_draw_points();
;
	jsr     _game_draw_points
;
; game_draw_time();
;
	jsr     _game_draw_time
;
; nmi_wait_and_prepare();
;
L07DC:	jsr     _nmi_wait_and_prepare
;
; if (game.paused == GAME_UNPAUSED) {
;
	lda     _game+2
	jne     L12FF
;
; game_small_scythe_processing();
;
	jsr     _game_small_scythe_processing
;
; game_draw_sprites();
;
	jsr     _game_draw_sprites
;
; game_enemy_processing();
;
	jsr     _game_enemy_processing
;
; game_draw_rain();
;
	jsr     _game_draw_rain
;
; game_draw_effects();
;
	jsr     _game_draw_effects
;
; if (game.state == GAME_ST_LEVEL_LOSE) {
;
	lda     _game+3
	cmp     #$04
	bne     L12F9
;
; game_grass_overgrow();
;
	jsr     _game_grass_overgrow
;
; if (game.state == GAME_ST_LEVEL_END_LOSE) break;
;
	lda     _game+3
	cmp     #$05
	bne     L07DC
	jmp     L07DD
;
; if (game.state == GAME_ST_LEVEL_WIN) {
;
L12F9:	lda     _game+3
	cmp     #$02
	bne     L07EE
;
; game_grass_fading();
;
	jsr     _game_grass_fading
;
; if (game.state == GAME_ST_LEVEL_END_WIN) break;
;
	lda     _game+3
	cmp     #$03
	bne     L07DC
	jmp     L07DD
;
; game_movement_and_actions();
;
L07EE:	jsr     _game_movement_and_actions
;
; game_grass_grow();
;
	jsr     _game_grass_grow
;
; ++frame_tick;
;
	inc     _frame_tick
;
; if (frame_tick == FRAME_COUNT_SEC) {
;
	lda     _frame_tick
	cmp     #$3C
	jne     L12FE
;
; frame_tick = 0;
;
	lda     #$00
	sta     _frame_tick
;
; --game.play_time;
;
	dec     _game+4
;
; if (game.play_time == 0) {
;
	lda     _game+4
	bne     L12FA
;
; sfx_play(SND_GAME_WIN, 0);
;
	lda     #$08
	jsr     pusha
	lda     #$00
	jsr     _sfx_play
;
; game.state = GAME_ST_LEVEL_WIN;
;
	lda     #$02
	sta     _game+3
;
; adr = 0;
;
	lda     #$00
	sta     _adr
	sta     _adr+1
;
; } else {
;
	jmp     L0815
;
; if ((game.max_play_time - game.play_time) % 0x0A == 0) game.effects.lightning = 1;
;
L12FA:	lda     _game+5
	sec
	sbc     _game+4
	jsr     pusha0
	lda     #$0A
	jsr     tosumoda0
	cpx     #$00
	bne     L0806
	cmp     #$00
	bne     L0806
	lda     #$01
	sta     _game+8
;
; if ((game.max_play_time - game.play_time) % 0x0E == 0) game.effects.wind = 1;
;
L0806:	lda     _game+5
	sec
	sbc     _game+4
	jsr     pusha0
	lda     #$0E
	jsr     tosumoda0
	cpx     #$00
	bne     L080C
	cmp     #$00
	bne     L080C
	lda     #$01
	sta     _game+10
;
; tmp = 1;
;
L080C:	lda     #$01
	sta     _tmp
;
; for (x = 0; x < BIRDS_COUNT; ++x) {
;
	lda     #$00
	sta     _x
L12FB:	lda     _x
	cmp     #$04
	bcs     L0815
;
; if (bird_state[x] == 0) {
;
	ldy     _x
	lda     _bird_state,y
	bne     L12FD
;
; if (game.level > 8) tmp = rand8() % 0x01;
;
	lda     _game
	cmp     #$09
	bcc     L12FC
	jsr     _rand8
	lda     #$00
;
; else if(game.level > 5) tmp = rand8() % 0x02;
;
	jmp     L12F8
L12FC:	lda     _game
	cmp     #$06
	bcc     L0825
	jsr     _rand8
	and     #$01
;
; else tmp = rand8() % 0x03;
;
	jmp     L12F8
L0825:	jsr     _rand8
	jsr     pushax
	lda     #$03
	jsr     tosumoda0
L12F8:	sta     _tmp
;
; if (tmp == 0) game_create_enemy(x);
;
	lda     _tmp
	bne     L0815
	lda     _x
	jsr     _game_create_enemy
;
; break;
;
	jmp     L0815
;
; for (x = 0; x < BIRDS_COUNT; ++x) {
;
L12FD:	inc     _x
	jmp     L12FB
;
; game_draw_time();
;
L0815:	jsr     _game_draw_time
;
; if (pad1_new & PAD_START) game.paused = GAME_PAUSED;
;
L12FE:	lda     _pad1_new
	and     #$10
	jeq     L07DC
	lda     #$01
	sta     _game+2
;
; } else {
;
	jmp     L07DC
;
; if (pad1_new & PAD_START) game.paused = GAME_UNPAUSED;
;
L12FF:	lda     _pad1_new
	and     #$10
	jeq     L07DC
	lda     #$00
	sta     _game+2
;
; while(1) {
;
	jmp     L07DC
;
; clear_vram_buffer();
;
L07DD:	jsr     _clear_vram_buffer
;
; if (game.lives == 0x00 || game.level == game.last_level) break;
;
	lda     _game+7
	beq     L1300
	lda     _game+1
	cmp     _game
	bne     L083B
L1300:	rts
;
; else process_upgrades();
;
L083B:	jsr     _process_upgrades
;
; while(1) {
;
	jmp     L07D4

.endproc

; ---------------------------------------------------------------
; void __near__ process_end_game_string_print (unsigned char, unsigned char, __near__ const unsigned char *, unsigned char)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_process_end_game_string_print: near

.segment	"CODE"

;
; void process_end_game_string_print(unsigned char xpos, unsigned char ypos, const char *str, unsigned char extra_blank) {
;
	jsr     pusha
;
; unsigned char npos = 0;
;
	lda     #$00
	jsr     pusha
;
; if (tmp == 0) {
;
	lda     _tmp
	jne     L1304
;
; if (index == 0) {
;
	lda     _index
	bne     L1301
;
; multi_vram_buffer_horz("                                ", 0x20, NTADR_A(0, ypos));
;
	jsr     decsp3
	lda     #<(L1032)
	ldy     #$01
	sta     (sp),y
	iny
	lda     #>(L1032)
	sta     (sp),y
	lda     #$20
	ldy     #$00
	sta     (sp),y
	ldy     #$07
	ldx     #$00
	lda     (sp),y
	jsr     aslax4
	stx     tmp1
	asl     a
	rol     tmp1
	pha
	lda     tmp1
	ora     #$20
	tax
	pla
	jsr     _multi_vram_buffer_horz
;
; if (extra_blank != 0)
;
	ldy     #$01
	lda     (sp),y
	beq     L1301
;
; multi_vram_buffer_horz("                                ", 0x20, NTADR_A(0, extra_blank));
;
	jsr     decsp3
	lda     #<(L103E)
	sta     (sp),y
	iny
	lda     #>(L103E)
	sta     (sp),y
	lda     #$20
	ldy     #$00
	sta     (sp),y
	ldy     #$04
	ldx     #$00
	lda     (sp),y
	jsr     aslax4
	stx     tmp1
	asl     a
	rol     tmp1
	pha
	lda     tmp1
	ora     #$20
	tax
	pla
	jsr     _multi_vram_buffer_horz
;
; if (state == EG_PRINT_DELAY) {
;
L1301:	lda     _state
	cmp     #$05
	jne     L1303
;
; state = 0;
;
	lda     #$00
	sta     _state
;
; for (y = 0; y < index; ++y) {
;
	sta     _y
L1302:	lda     _y
	cmp     _index
	bcs     L104C
;
; *str++;
;
	ldy     #$03
	lda     (sp),y
	tax
	dey
	lda     (sp),y
	clc
	adc     #$01
	bcc     L1054
	inx
L1054:	jsr     staxysp
;
; ++xpos;
;
	ldy     #$05
	clc
	lda     #$01
	adc     (sp),y
	sta     (sp),y
;
; for (y = 0; y < index; ++y) {
;
	inc     _y
	jmp     L1302
;
; if (!*str) {
;
L104C:	ldy     #$03
	lda     (sp),y
	sta     ptr1+1
	dey
	lda     (sp),y
	sta     ptr1
	ldy     #$00
	lda     (ptr1),y
	bne     L1056
;
; ++marker;
;
	inc     _marker
;
; index = 0;
;
	sta     _index
;
; tmp = 60;
;
	lda     #$3C
	sta     _tmp
;
; } else {
;
	jmp     incsp6
;
; ++index;
;
L1056:	inc     _index
;
; one_vram_buffer(*str, NTADR_A(xpos, ypos));
;
	ldy     #$03
	lda     (sp),y
	sta     ptr1+1
	dey
	lda     (sp),y
	sta     ptr1
	ldy     #$00
	lda     (ptr1),y
	jsr     pusha
	ldy     #$05
	ldx     #$00
	lda     (sp),y
	jsr     aslax4
	stx     tmp1
	asl     a
	rol     tmp1
	sta     ptr1
	iny
	lda     (sp),y
	ora     ptr1
	pha
	lda     tmp1
	ora     #$20
	tax
	pla
	jsr     _one_vram_buffer
;
; } else {
;
	jmp     incsp6
;
; ++state;
;
L1303:	inc     _state
;
; } else {
;
	jmp     incsp6
;
; --tmp;
;
L1304:	dec     _tmp
;
; }
;
	jmp     incsp6

.endproc

; ---------------------------------------------------------------
; void __near__ process_game_win (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_process_game_win: near

.segment	"CODE"

;
; fade_in();
;
	jsr     _fade_in
;
; ppu_off();
;
	jsr     _ppu_off
;
; vram_adr(NAMETABLE_A + 0x20 * 0x1C);
;
	ldx     #$23
	lda     #$80
	jsr     _vram_adr
;
; for (x = 0x00; x != 0x20; ++x) vram_put(CHR_BG_BLANK);
;
	lda     #$00
	sta     _x
L1306:	lda     _x
	cmp     #$20
	beq     L1071
	lda     #$7F
	jsr     _vram_put
	inc     _x
	jmp     L1306
;
; ppu_on_all();
;
L1071:	jsr     _ppu_on_all
;
; music_play(MSC_GAME_WIN);
;
	lda     #$01
	jsr     _music_play
;
; fade_out();
;
	jsr     _fade_out
;
; x = 1;
;
	lda     #$01
	sta     _x
;
; player.x = 50;
;
	lda     #$32
	sta     _player
;
; player.y = PLAYER_DEF_Y;
;
	lda     #$8C
	sta     _player+1
;
; index = 0;
;
	lda     #$00
	sta     _index
;
; state = 0;
;
	sta     _state
;
; marker = 0;
;
	sta     _marker
;
; tmp = 200;
;
	lda     #$C8
	sta     _tmp
;
; nmi_wait_and_prepare();
;
L108C:	jsr     _nmi_wait_and_prepare
;
; oam_clear();
;
	jsr     _oam_clear
;
; oam_meta_spr(player.x, player.y, x == 1 ? OTM_R : OTM_L);
;
	jsr     decsp2
	lda     _player
	ldy     #$01
	sta     (sp),y
	lda     _player+1
	dey
	sta     (sp),y
	lda     _x
	cmp     #$01
	bne     L1096
	lda     #<(_OTM_R)
	ldx     #>(_OTM_R)
	jmp     L1098
L1096:	lda     #<(_OTM_L)
	ldx     #>(_OTM_L)
L1098:	jsr     _oam_meta_spr
;
; player.x += x;
;
	lda     _x
	clc
	adc     _player
	sta     _player
;
; if (player.x > 180) x = -1;
;
	cmp     #$B5
	bcc     L1307
	lda     #$FF
	sta     _x
;
; if (player.x < 50) x = 1;
;
L1307:	lda     _player
	cmp     #$32
	bcs     L1308
	lda     #$01
	sta     _x
;
; if (marker < 0x0A) {
;
L1308:	lda     _marker
	cmp     #$0A
	jcs     L130C
;
; if (tmp < 5 && marker == 0) {
;
	lda     _tmp
	cmp     #$05
	bcs     L130B
	lda     _marker
	bne     L130B
;
; multi_vram_buffer_horz("                                ", 0x20, NTADR_A(0, 0x09 + tmp));
;
	jsr     decsp3
	lda     #<(L10AB)
	ldy     #$01
	sta     (sp),y
	iny
	lda     #>(L10AB)
	sta     (sp),y
	lda     #$20
	ldy     #$00
	sta     (sp),y
	ldx     #$00
	lda     _tmp
	clc
	adc     #$09
	bcc     L10B3
	inx
L10B3:	jsr     shlax4
	stx     tmp1
	asl     a
	rol     tmp1
	pha
	lda     tmp1
	ora     #$20
	tax
	pla
	jsr     _multi_vram_buffer_horz
;
; switch (marker) {
;
L130B:	lda     _marker
;
; }
;
	beq     L10B9
	cmp     #$01
	beq     L10C1
	cmp     #$02
	beq     L10C9
	cmp     #$03
	jeq     L10D1
	cmp     #$04
	jeq     L10D9
	cmp     #$05
	jeq     L10E1
	cmp     #$06
	jeq     L10E9
	cmp     #$07
	jeq     L10F1
	cmp     #$08
	jeq     L10F9
	cmp     #$09
	jeq     L1101
	jmp     L130C
;
; case 0: process_end_game_string_print(0x09, 0x0B, "ONE THOUSAND MAN", 0); break;
;
L10B9:	jsr     decsp4
	lda     #$09
	ldy     #$03
	sta     (sp),y
	lda     #$0B
	dey
	sta     (sp),y
	lda     #<(L10BD)
	ldy     #$00
	sta     (sp),y
	iny
	lda     #>(L10BD)
	jmp     L130E
;
; case 1: process_end_game_string_print(0x09, 0x0A, "GAME CREATED BY", 0x0B); break;
;
L10C1:	jsr     decsp4
	lda     #$09
	ldy     #$03
	sta     (sp),y
	lda     #$0A
	dey
	sta     (sp),y
	lda     #<(L10C5)
	ldy     #$00
	sta     (sp),y
	iny
	lda     #>(L10C5)
	sta     (sp),y
	lda     #$0B
	jmp     L1305
;
; case 2: process_end_game_string_print(0x0A, 0x0C, "SPERLINGSKAUZ", 0); break;
;
L10C9:	jsr     decsp4
	lda     #$0A
	ldy     #$03
	sta     (sp),y
	lda     #$0C
	dey
	sta     (sp),y
	lda     #<(L10CD)
	ldy     #$00
	sta     (sp),y
	iny
	lda     #>(L10CD)
	jmp     L130E
;
; case 3: process_end_game_string_print(0x08, 0x0A, "ORIGINAL COMICS BY", 0x0C); break;
;
L10D1:	jsr     decsp4
	lda     #$08
	ldy     #$03
	sta     (sp),y
	lda     #$0A
	dey
	sta     (sp),y
	lda     #<(L10D5)
	ldy     #$00
	sta     (sp),y
	iny
	lda     #>(L10D5)
	sta     (sp),y
	lda     #$0C
	jmp     L1305
;
; case 4: process_end_game_string_print(0x0A, 0x0C, "CYNIC MANSION", 0); break;
;
L10D9:	jsr     decsp4
	lda     #$0A
	ldy     #$03
	sta     (sp),y
	lda     #$0C
	dey
	sta     (sp),y
	lda     #<(L10DD)
	ldy     #$00
	sta     (sp),y
	iny
	lda     #>(L10DD)
	jmp     L130E
;
; case 5: process_end_game_string_print(0x08, 0x0A, "SPECIAL THANKS TO", 0x0C); break;
;
L10E1:	jsr     decsp4
	lda     #$08
	ldy     #$03
	sta     (sp),y
	lda     #$0A
	dey
	sta     (sp),y
	lda     #<(L10E5)
	ldy     #$00
	sta     (sp),y
	iny
	lda     #>(L10E5)
	sta     (sp),y
	lda     #$0C
	jmp     L1305
;
; case 6: process_end_game_string_print(0x0E, 0x0C, "SHIRU", 0); break;
;
L10E9:	jsr     decsp4
	lda     #$0E
	ldy     #$03
	sta     (sp),y
	lda     #$0C
	dey
	sta     (sp),y
	lda     #<(L10ED)
	ldy     #$00
	sta     (sp),y
	iny
	lda     #>(L10ED)
	jmp     L130E
;
; case 7: process_end_game_string_print(0x0D, 0x0C, "NESDOUG", 0); break;
;
L10F1:	jsr     decsp4
	lda     #$0D
	ldy     #$03
	sta     (sp),y
	lda     #$0C
	dey
	sta     (sp),y
	lda     #<(L10F5)
	ldy     #$00
	sta     (sp),y
	iny
	lda     #>(L10F5)
	jmp     L130E
;
; case 8: process_end_game_string_print(0x06, 0x0A, " ", 0x0C); break;
;
L10F9:	jsr     decsp4
	lda     #$06
	ldy     #$03
	sta     (sp),y
	lda     #$0A
	dey
	sta     (sp),y
	lda     #<(L10FD)
	ldy     #$00
	sta     (sp),y
	iny
	lda     #>(L10FD)
	sta     (sp),y
	lda     #$0C
	jmp     L1305
;
; case 9: process_end_game_string_print(0x06, 0x0B, "THANK YOU FOR PLAYING!", 0); break;
;
L1101:	jsr     decsp4
	lda     #$06
	ldy     #$03
	sta     (sp),y
	lda     #$0B
	dey
	sta     (sp),y
	lda     #<(L1105)
	ldy     #$00
	sta     (sp),y
	iny
	lda     #>(L1105)
L130E:	sta     (sp),y
	lda     #$00
L1305:	jsr     _process_end_game_string_print
;
; if (pad1_new & PAD_START) break;
;
L130C:	lda     _pad1_new
	and     #$10
	jeq     L108C
	jmp     _music_stop

.endproc

; ---------------------------------------------------------------
; void __near__ process_game_end (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_process_game_end: near

.segment	"CODE"

;
; if (game.state == GAME_ST_LEVEL_END_WIN) process_game_win();
;
	lda     _game+3
	cmp     #$03
	bne     L110C
	jsr     _process_game_win
;
; pal_bg(game_palette_bg);
;
L110C:	lda     #<(_game_palette_bg)
	ldx     #>(_game_palette_bg)
	jsr     _pal_bg
;
; pal_spr(game_palette_sp);
;
	lda     #<(_game_palette_sp)
	ldx     #>(_game_palette_sp)
	jsr     _pal_spr
;
; fade_in();
;
	jsr     _fade_in
;
; ppu_off();
;
	jsr     _ppu_off
;
; vram_adr(PPU_PALLETE);
;
	ldx     #$23
	lda     #$C0
	jsr     _vram_adr
;
; for (x = 0x00; x != 0x40; ++x) vram_put(0);
;
	lda     #$00
	sta     _x
L130F:	lda     _x
	cmp     #$40
	beq     L1118
	lda     #$00
	jsr     _vram_put
	inc     _x
	jmp     L130F
;
; vram_adr(NAMETABLE_A);
;
L1118:	ldx     #$20
	lda     #$00
	jsr     _vram_adr
;
; for (x = 0x00; x != 0x20; ++x) 
;
	lda     #$00
	sta     _x
L1310:	lda     _x
	cmp     #$20
	beq     L1124
;
; for(y = 0x00; y != 0x1D; ++y) 
;
	lda     #$00
	sta     _y
L1311:	lda     _y
	cmp     #$1D
	beq     L1312
;
; vram_put(CHR_BG_BLANK);
;
	lda     #$7F
	jsr     _vram_put
;
; for(y = 0x00; y != 0x1D; ++y) 
;
	inc     _y
	jmp     L1311
;
; for (x = 0x00; x != 0x20; ++x) 
;
L1312:	inc     _x
	jmp     L1310
;
; put_str(NTADR_A(0x0B, 0x0B), "GAME OVER");
;
L1124:	ldx     #$21
	lda     #$6B
	jsr     pushax
	lda     #<(L113C)
	ldx     #>(L113C)
	jsr     _put_str
;
; put_str(NTADR_A(0x05, 0x10), "PRESS START TO RETURN");
;
	ldx     #$22
	lda     #$05
	jsr     pushax
	lda     #<(L1145)
	ldx     #>(L1145)
	jsr     _put_str
;
; put_str(NTADR_A(0x09, 0x11), "TO MAIN MENU");
;
	ldx     #$22
	lda     #$29
	jsr     pushax
	lda     #<(L114E)
	ldx     #>(L114E)
	jsr     _put_str
;
; put_str(NTADR_A(0x06, 0x0D), "FINAL SCORE");
;
	ldx     #$21
	lda     #$A6
	jsr     pushax
	lda     #<(L1157)
	ldx     #>(L1157)
	jsr     _put_str
;
; put_number(NTADR_A(0x11, 0x0D), score, 2);
;
	jsr     decsp4
	lda     #$B1
	ldy     #$02
	sta     (sp),y
	iny
	lda     #$21
	sta     (sp),y
	lda     _score
	ldy     #$00
	sta     (sp),y
	iny
	lda     _score+1
	sta     (sp),y
	lda     #$02
	jsr     _put_number
;
; ppu_on_all();
;
	jsr     _ppu_on_all
;
; oam_clear();
;
	jsr     _oam_clear
;
; fade_out();
;
	jsr     _fade_out
;
; nmi_wait_and_prepare();
;
L1165:	jsr     _nmi_wait_and_prepare
;
; if (pad1_new & PAD_START) break;
;
	lda     _pad1_new
	and     #$10
	beq     L1165
;
; game.state = GAME_ST_MENU;
;
	lda     #$00
	sta     _game+3
;
; fade_in();
;
	jsr     _fade_in
;
; ppu_off();
;
	jsr     _ppu_off
;
; vram_adr(NAMETABLE_A + SCREEN_TILES_X * 0x0B + 0x0B);
;
	ldx     #$21
	lda     #$6B
	jsr     _vram_adr
;
; for(x = 0x00; x != 0x09; ++x) vram_put(CHR_BG_BLANK);
;
	lda     #$00
	sta     _x
L1314:	lda     _x
	cmp     #$09
	beq     L1173
	lda     #$7F
	jsr     _vram_put
	inc     _x
	jmp     L1314
;
; ppu_on_all();
;
L1173:	jsr     _ppu_on_all
;
; fade_out();
;
	jmp     _fade_out

.endproc

; ---------------------------------------------------------------
; void __near__ set_bg_pallete (__near__ const unsigned char *)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_set_bg_pallete: near

.segment	"CODE"

;
; void set_bg_pallete(const char *pallete) {
;
	jsr     pushax
;
; vram_adr(PPU_PALLETE);
;
	ldx     #$23
	lda     #$C0
	jsr     _vram_adr
;
; for(x = 0x00; x != 0x40; ++x) {
;
	lda     #$00
	sta     _x
L1316:	lda     _x
	cmp     #$40
	beq     L0511
;
; vram_put(pallete[x]);
;
	ldy     #$01
	lda     (sp),y
	tax
	dey
	lda     (sp),y
	ldy     _x
	sta     ptr1
	stx     ptr1+1
	lda     (ptr1),y
	jsr     _vram_put
;
; for(x = 0x00; x != 0x40; ++x) {
;
	inc     _x
	jmp     L1316
;
; }
;
L0511:	jmp     incsp2

.endproc

; ---------------------------------------------------------------
; void __near__ main (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_main: near

.segment	"CODE"

;
; game_initial_values_set();
;
L117F:	jsr     _game_initial_values_set
;
; process_title();
;
	jsr     _process_title
;
; if (points == 99) process_upgrades();
;
	lda     _points
	cmp     #$63
	bne     L1185
	jsr     _process_upgrades
;
; process_main_game();
;
L1185:	jsr     _process_main_game
;
; process_game_end();
;
	jsr     _process_game_end
;
; while (1) {
;
	jmp     L117F

.endproc

