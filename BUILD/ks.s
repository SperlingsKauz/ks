;
; File generated by cc65 v 2.18 - Git 5b56c6e
;
	.fopt		compiler,"cc65 v 2.18 - Git 5b56c6e"
	.setcpu		"6502"
	.smart		on
	.autoimport	on
	.case		on
	.debuginfo	off
	.importzp	sp, sreg, regsave, regbank
	.importzp	tmp1, tmp2, tmp3, tmp4, ptr1, ptr2, ptr3, ptr4
	.macpack	longbranch
	.forceimport	__STARTUP__
	.import		_pal_bg
	.import		_pal_spr
	.import		_pal_col
	.import		_ppu_wait_nmi
	.import		_ppu_off
	.import		_ppu_on_all
	.import		_oam_clear
	.import		_oam_spr
	.import		_oam_meta_spr
	.import		_music_play
	.import		_music_stop
	.import		_sfx_play
	.import		_pad_poll
	.import		_bank_spr
	.import		_rand8
	.import		_set_rand
	.import		_vram_adr
	.import		_vram_put
	.import		_delay
	.import		_set_vram_buffer
	.import		_one_vram_buffer
	.import		_multi_vram_buffer_horz
	.import		_clear_vram_buffer
	.import		_get_pad_new
	.import		_get_frame_count
	.import		_pal_fade_to
	.export		_title_palette_bg
	.export		_title_palette_sp
	.export		_game_palette_bg
	.export		_game_palette_sp
	.export		_upgrade_palette_bg
	.export		_upgrade_palette_sp
	.export		_upgrade_cost
	.export		_BlueSpr
	.export		_CURSOR
	.export		_LOGO
	.export		_STATUS_BAR
	.export		_SCYTHE_STATE
	.export		_OTM_R
	.export		_OTM_RC_1
	.export		_OTM_RC_2
	.export		_OTM_RC_3
	.export		_OTM_L
	.export		_initial_pallete
	.export		_abilities_icons
	.export		_set_breakpoint
	.export		_tasm
	.export		_d
	.export		_d2
	.export		_nmi_wait_and_prepare
	.export		_clear_screen
	.export		_fade_in
	.export		_fade_out
	.export		_delay_with_state_skip
	.export		_put_str
	.export		_put_char
	.export		_put_number
	.export		_game_initial_values_set
	.export		_game_process_next_level
	.export		_game_grass_grow
	.export		_game_grass_cf_prepare
	.export		_game_grass_cf_finalize
	.export		_game_grass_fading
	.export		_game_grass_overgrow
	.export		_game_grass_cut
	.export		_game_check_for_extra_point
	.export		_game_draw_rain
	.export		_game_draw_sprites
	.export		_game_draw_background
	.export		_game_draw_time
	.export		_game_draw_points
	.export		_game_draw_effects
	.export		_game_movement_and_actions
	.export		_game_check_specials_keys
	.export		_game_small_scythe_processing
	.export		_game_create_enemy
	.export		_game_enemy_processing
	.export		_upgrade_draw_sprites
	.export		_upgrade_draw_background
	.export		_upgrade_movement_and_actions
	.export		_upgrade_draw_desc
	.export		_upgrade_draw_icon
	.export		_upgrade_recalc_ability_cost
	.export		_upgrade_show_ablity_desc
	.export		_upgrade_show_current_points
	.export		_title_draw_background
	.export		_title_draw_options
	.export		_title_draw_menu
	.export		_title_check_cheat_code
	.export		_process_title
	.export		_process_upgrades
	.export		_process_main_game
	.export		_process_end_game_string_print
	.export		_process_game_win
	.export		_process_game_end
	.export		_pad1
	.export		_pad1_new
	.export		_tmp
	.export		_state
	.export		_index
	.export		_marker
	.export		_x
	.export		_y
	.export		_adr
	.export		_frame_tick
	.export		_rain_delay
	.export		_rain_drop_x
	.export		_rain_drop_y
	.export		_grass
	.export		_points
	.export		_score
	.export		_game_calc_state
	.export		_bird_x
	.export		_bird_y
	.export		_bird_sprite
	.export		_bird_x_sprite
	.export		_bird_anim
	.export		_bird_state
	.export		_bird_health
	.export		_bird_tag
	.export		_bird_speed_delay
	.export		_bird_x_speed
	.export		_bird_pallete
	.export		_player
	.export		_small_scythe
	.export		_game
	.export		_set_bg_pallete
	.export		_main

.segment	"DATA"

_rain_delay:
	.byte	$06
_grass:
	.byte	$00
	.byte	$14
	.byte	$01
	.byte	$12
	.res	32,$00
_points:
	.byte	$00
_score:
	.word	$0000
_game_calc_state:
	.byte	$00
_player:
	.byte	$20
	.byte	$8C
	.byte	$20
	.byte	$40
	.byte	$00
	.byte	$02
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$01
	.byte	$02
	.byte	$00
	.byte	$0A
	.byte	$0A
	.byte	$00
	.res	1,$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
_small_scythe:
	.byte	$00
	.byte	$00
	.byte	$10
	.byte	$08
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$03
_game:
	.byte	$01
	.byte	$0C
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$0A
	.byte	$00
	.byte	$03
	.byte	$00
	.byte	$01
	.byte	$00

.segment	"RODATA"

_title_palette_bg:
	.byte	$0F
	.byte	$0F
	.byte	$21
	.byte	$20
	.byte	$0F
	.byte	$01
	.byte	$21
	.byte	$20
	.byte	$0F
	.byte	$0F
	.byte	$08
	.byte	$0A
	.byte	$0F
	.byte	$00
	.byte	$09
	.byte	$0A
_title_palette_sp:
	.byte	$0F
	.byte	$13
	.byte	$23
	.byte	$03
	.byte	$0F
	.byte	$13
	.byte	$23
	.byte	$03
	.byte	$0F
	.byte	$12
	.byte	$22
	.byte	$03
	.byte	$0F
	.byte	$00
	.byte	$00
	.byte	$00
_game_palette_bg:
	.byte	$0C
	.byte	$0E
	.byte	$06
	.byte	$1B
	.byte	$0C
	.byte	$01
	.byte	$21
	.byte	$20
	.byte	$0C
	.byte	$0F
	.byte	$08
	.byte	$0A
	.byte	$0F
	.byte	$00
	.byte	$09
	.byte	$0A
_game_palette_sp:
	.byte	$0C
	.byte	$00
	.byte	$0F
	.byte	$30
	.byte	$0C
	.byte	$0F
	.byte	$0F
	.byte	$10
	.byte	$0C
	.byte	$01
	.byte	$21
	.byte	$31
	.byte	$0C
	.byte	$00
	.byte	$00
	.byte	$00
_upgrade_palette_bg:
	.byte	$0C
	.byte	$0F
	.byte	$10
	.byte	$30
	.byte	$0C
	.byte	$01
	.byte	$21
	.byte	$20
	.byte	$0C
	.byte	$0F
	.byte	$08
	.byte	$0A
	.byte	$0C
	.byte	$00
	.byte	$09
	.byte	$0A
_upgrade_palette_sp:
	.byte	$0C
	.byte	$00
	.byte	$0F
	.byte	$30
	.byte	$0C
	.byte	$0F
	.byte	$0F
	.byte	$10
	.byte	$0C
	.byte	$01
	.byte	$21
	.byte	$31
	.byte	$0C
	.byte	$00
	.byte	$00
	.byte	$00
_upgrade_cost:
	.byte	$03
	.byte	$05
	.byte	$07
	.byte	$08
	.byte	$09
	.byte	$03
	.byte	$03
	.byte	$05
	.byte	$05
	.byte	$09
	.byte	$03
	.byte	$04
	.byte	$05
	.byte	$07
	.byte	$09
	.byte	$01
	.byte	$02
	.byte	$03
	.byte	$04
	.byte	$09
	.byte	$01
	.byte	$03
	.byte	$05
	.byte	$07
	.byte	$09
_BlueSpr:
	.byte	$00
	.byte	$00
	.byte	$50
	.byte	$01
	.byte	$00
	.byte	$08
	.byte	$60
	.byte	$01
	.byte	$08
	.byte	$00
	.byte	$50
	.byte	$41
	.byte	$08
	.byte	$08
	.byte	$60
	.byte	$41
	.byte	$80
_CURSOR:
	.byte	$00
	.byte	$00
	.byte	$14
	.byte	$02
	.byte	$00
	.byte	$0D
	.byte	$14
	.byte	$82
	.byte	$0C
	.byte	$00
	.byte	$14
	.byte	$42
	.byte	$0C
	.byte	$0D
	.byte	$14
	.byte	$C2
	.byte	$80
_LOGO:
	.byte	$20
	.byte	$08
	.byte	$08
	.byte	$01
	.byte	$40
	.byte	$08
	.byte	$08
	.byte	$41
	.byte	$40
	.byte	$18
	.byte	$0D
	.byte	$41
	.byte	$18
	.byte	$18
	.byte	$0A
	.byte	$01
	.byte	$20
	.byte	$20
	.byte	$09
	.byte	$01
	.byte	$40
	.byte	$30
	.byte	$07
	.byte	$01
	.byte	$58
	.byte	$18
	.byte	$0D
	.byte	$01
	.byte	$20
	.byte	$30
	.byte	$06
	.byte	$C1
	.byte	$48
	.byte	$20
	.byte	$06
	.byte	$41
	.byte	$50
	.byte	$20
	.byte	$06
	.byte	$01
	.byte	$38
	.byte	$08
	.byte	$0A
	.byte	$01
	.byte	$10
	.byte	$20
	.byte	$09
	.byte	$01
	.byte	$10
	.byte	$18
	.byte	$06
	.byte	$01
	.byte	$48
	.byte	$28
	.byte	$06
	.byte	$81
	.byte	$30
	.byte	$18
	.byte	$09
	.byte	$01
	.byte	$58
	.byte	$28
	.byte	$09
	.byte	$01
	.byte	$40
	.byte	$28
	.byte	$09
	.byte	$01
	.byte	$30
	.byte	$08
	.byte	$0B
	.byte	$01
	.byte	$58
	.byte	$30
	.byte	$07
	.byte	$01
	.byte	$40
	.byte	$20
	.byte	$0C
	.byte	$01
	.byte	$30
	.byte	$28
	.byte	$07
	.byte	$01
	.byte	$20
	.byte	$18
	.byte	$06
	.byte	$41
	.byte	$10
	.byte	$30
	.byte	$06
	.byte	$81
	.byte	$10
	.byte	$28
	.byte	$09
	.byte	$01
	.byte	$50
	.byte	$28
	.byte	$06
	.byte	$C1
	.byte	$18
	.byte	$30
	.byte	$0A
	.byte	$01
	.byte	$20
	.byte	$28
	.byte	$09
	.byte	$01
	.byte	$58
	.byte	$20
	.byte	$0C
	.byte	$41
	.byte	$30
	.byte	$10
	.byte	$09
	.byte	$01
	.byte	$28
	.byte	$08
	.byte	$0A
	.byte	$01
	.byte	$30
	.byte	$20
	.byte	$09
	.byte	$01
_STATUS_BAR:
	.byte	$00
	.byte	$A7
	.byte	$2F
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$A9
	.byte	$2F
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$A8
	.byte	$00
	.byte	$30
	.byte	$30
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$AA
	.byte	$00
	.byte	$00
	.byte	$AB
_SCYTHE_STATE:
	.byte	$00
	.byte	$00
	.byte	$70
	.byte	$00
	.byte	$08
	.byte	$00
	.byte	$71
	.byte	$00
	.byte	$00
	.byte	$08
	.byte	$72
	.byte	$00
	.byte	$08
	.byte	$08
	.byte	$73
	.byte	$00
	.byte	$80
	.byte	$00
	.byte	$00
	.byte	$74
	.byte	$00
	.byte	$08
	.byte	$00
	.byte	$75
	.byte	$00
	.byte	$00
	.byte	$08
	.byte	$0F
	.byte	$00
	.byte	$08
	.byte	$08
	.byte	$76
	.byte	$00
	.byte	$80
	.byte	$00
	.byte	$00
	.byte	$77
	.byte	$00
	.byte	$08
	.byte	$00
	.byte	$78
	.byte	$00
	.byte	$00
	.byte	$08
	.byte	$79
	.byte	$00
	.byte	$08
	.byte	$08
	.byte	$7A
	.byte	$00
	.byte	$80
	.byte	$00
	.byte	$00
	.byte	$7F
	.byte	$00
	.byte	$08
	.byte	$00
	.byte	$7B
	.byte	$00
	.byte	$00
	.byte	$08
	.byte	$7C
	.byte	$00
	.byte	$08
	.byte	$08
	.byte	$7D
	.byte	$00
	.byte	$80
	.byte	$00
	.byte	$00
	.byte	$73
	.byte	$C0
	.byte	$08
	.byte	$00
	.byte	$72
	.byte	$C0
	.byte	$00
	.byte	$08
	.byte	$71
	.byte	$C0
	.byte	$08
	.byte	$08
	.byte	$70
	.byte	$C0
	.byte	$80
	.byte	$00
	.byte	$00
	.byte	$76
	.byte	$C0
	.byte	$08
	.byte	$00
	.byte	$0F
	.byte	$C0
	.byte	$00
	.byte	$08
	.byte	$75
	.byte	$C0
	.byte	$08
	.byte	$08
	.byte	$74
	.byte	$C0
	.byte	$80
	.byte	$00
	.byte	$00
	.byte	$7A
	.byte	$C0
	.byte	$08
	.byte	$00
	.byte	$79
	.byte	$C0
	.byte	$00
	.byte	$08
	.byte	$78
	.byte	$C0
	.byte	$08
	.byte	$08
	.byte	$77
	.byte	$C0
	.byte	$80
	.byte	$00
	.byte	$00
	.byte	$7D
	.byte	$C0
	.byte	$08
	.byte	$00
	.byte	$7C
	.byte	$C0
	.byte	$00
	.byte	$08
	.byte	$7B
	.byte	$C0
	.byte	$08
	.byte	$08
	.byte	$0F
	.byte	$C0
	.byte	$80
_OTM_R:
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$20
	.byte	$00
	.byte	$08
	.byte	$10
	.byte	$20
	.byte	$00
	.byte	$10
	.byte	$20
	.byte	$20
	.byte	$00
	.byte	$18
	.byte	$30
	.byte	$20
	.byte	$08
	.byte	$00
	.byte	$01
	.byte	$20
	.byte	$08
	.byte	$08
	.byte	$11
	.byte	$20
	.byte	$08
	.byte	$10
	.byte	$21
	.byte	$20
	.byte	$08
	.byte	$18
	.byte	$31
	.byte	$20
	.byte	$08
	.byte	$20
	.byte	$41
	.byte	$20
	.byte	$08
	.byte	$28
	.byte	$51
	.byte	$20
	.byte	$08
	.byte	$30
	.byte	$61
	.byte	$20
	.byte	$10
	.byte	$00
	.byte	$02
	.byte	$20
	.byte	$10
	.byte	$08
	.byte	$12
	.byte	$20
	.byte	$10
	.byte	$10
	.byte	$22
	.byte	$20
	.byte	$10
	.byte	$18
	.byte	$32
	.byte	$20
	.byte	$10
	.byte	$20
	.byte	$42
	.byte	$20
	.byte	$10
	.byte	$28
	.byte	$52
	.byte	$20
	.byte	$10
	.byte	$30
	.byte	$62
	.byte	$20
	.byte	$18
	.byte	$00
	.byte	$03
	.byte	$20
	.byte	$18
	.byte	$08
	.byte	$13
	.byte	$20
	.byte	$18
	.byte	$10
	.byte	$23
	.byte	$20
	.byte	$18
	.byte	$18
	.byte	$33
	.byte	$20
	.byte	$18
	.byte	$20
	.byte	$43
	.byte	$20
	.byte	$18
	.byte	$28
	.byte	$53
	.byte	$20
	.byte	$18
	.byte	$30
	.byte	$63
	.byte	$20
	.byte	$80
_OTM_RC_1:
	.byte	$00
	.byte	$18
	.byte	$B0
	.byte	$20
	.byte	$00
	.byte	$20
	.byte	$C0
	.byte	$20
	.byte	$08
	.byte	$10
	.byte	$A1
	.byte	$20
	.byte	$08
	.byte	$18
	.byte	$B1
	.byte	$20
	.byte	$10
	.byte	$08
	.byte	$92
	.byte	$20
	.byte	$10
	.byte	$10
	.byte	$A2
	.byte	$20
	.byte	$10
	.byte	$18
	.byte	$B2
	.byte	$20
	.byte	$10
	.byte	$20
	.byte	$C2
	.byte	$20
	.byte	$10
	.byte	$28
	.byte	$D2
	.byte	$20
	.byte	$10
	.byte	$30
	.byte	$E2
	.byte	$20
	.byte	$18
	.byte	$00
	.byte	$83
	.byte	$20
	.byte	$18
	.byte	$08
	.byte	$93
	.byte	$20
	.byte	$18
	.byte	$10
	.byte	$A3
	.byte	$20
	.byte	$18
	.byte	$18
	.byte	$B3
	.byte	$20
	.byte	$18
	.byte	$20
	.byte	$C3
	.byte	$20
	.byte	$18
	.byte	$28
	.byte	$D3
	.byte	$20
	.byte	$18
	.byte	$30
	.byte	$E3
	.byte	$20
	.byte	$20
	.byte	$00
	.byte	$84
	.byte	$20
	.byte	$20
	.byte	$08
	.byte	$94
	.byte	$20
	.byte	$20
	.byte	$10
	.byte	$A4
	.byte	$20
	.byte	$20
	.byte	$18
	.byte	$B4
	.byte	$20
	.byte	$20
	.byte	$20
	.byte	$C4
	.byte	$20
	.byte	$20
	.byte	$28
	.byte	$D4
	.byte	$20
	.byte	$20
	.byte	$30
	.byte	$E4
	.byte	$20
	.byte	$80
_OTM_RC_2:
	.byte	$00
	.byte	$28
	.byte	$D5
	.byte	$20
	.byte	$00
	.byte	$30
	.byte	$E5
	.byte	$20
	.byte	$08
	.byte	$08
	.byte	$96
	.byte	$20
	.byte	$08
	.byte	$10
	.byte	$A6
	.byte	$20
	.byte	$08
	.byte	$18
	.byte	$B6
	.byte	$20
	.byte	$08
	.byte	$20
	.byte	$C6
	.byte	$20
	.byte	$08
	.byte	$28
	.byte	$D6
	.byte	$20
	.byte	$08
	.byte	$30
	.byte	$E6
	.byte	$20
	.byte	$10
	.byte	$00
	.byte	$87
	.byte	$20
	.byte	$10
	.byte	$08
	.byte	$97
	.byte	$20
	.byte	$10
	.byte	$10
	.byte	$A7
	.byte	$20
	.byte	$10
	.byte	$18
	.byte	$B7
	.byte	$20
	.byte	$10
	.byte	$20
	.byte	$C7
	.byte	$20
	.byte	$10
	.byte	$28
	.byte	$D7
	.byte	$20
	.byte	$10
	.byte	$30
	.byte	$E7
	.byte	$20
	.byte	$18
	.byte	$00
	.byte	$88
	.byte	$20
	.byte	$18
	.byte	$08
	.byte	$98
	.byte	$20
	.byte	$18
	.byte	$10
	.byte	$A8
	.byte	$20
	.byte	$18
	.byte	$18
	.byte	$B8
	.byte	$20
	.byte	$18
	.byte	$20
	.byte	$C8
	.byte	$20
	.byte	$18
	.byte	$28
	.byte	$D8
	.byte	$20
	.byte	$18
	.byte	$30
	.byte	$E8
	.byte	$20
	.byte	$80
_OTM_RC_3:
	.byte	$00
	.byte	$08
	.byte	$9A
	.byte	$20
	.byte	$00
	.byte	$10
	.byte	$AA
	.byte	$20
	.byte	$00
	.byte	$18
	.byte	$BA
	.byte	$20
	.byte	$00
	.byte	$20
	.byte	$CA
	.byte	$20
	.byte	$00
	.byte	$28
	.byte	$DA
	.byte	$20
	.byte	$00
	.byte	$30
	.byte	$EA
	.byte	$20
	.byte	$08
	.byte	$00
	.byte	$8B
	.byte	$20
	.byte	$08
	.byte	$08
	.byte	$9B
	.byte	$20
	.byte	$08
	.byte	$10
	.byte	$AB
	.byte	$20
	.byte	$08
	.byte	$18
	.byte	$BB
	.byte	$20
	.byte	$08
	.byte	$20
	.byte	$CB
	.byte	$20
	.byte	$08
	.byte	$28
	.byte	$DB
	.byte	$20
	.byte	$08
	.byte	$30
	.byte	$EB
	.byte	$20
	.byte	$10
	.byte	$00
	.byte	$8C
	.byte	$20
	.byte	$10
	.byte	$08
	.byte	$9C
	.byte	$20
	.byte	$10
	.byte	$10
	.byte	$AC
	.byte	$20
	.byte	$10
	.byte	$18
	.byte	$BC
	.byte	$20
	.byte	$10
	.byte	$20
	.byte	$CC
	.byte	$20
	.byte	$10
	.byte	$28
	.byte	$DC
	.byte	$20
	.byte	$10
	.byte	$30
	.byte	$EC
	.byte	$20
	.byte	$18
	.byte	$18
	.byte	$BD
	.byte	$20
	.byte	$18
	.byte	$20
	.byte	$CD
	.byte	$20
	.byte	$18
	.byte	$28
	.byte	$DD
	.byte	$20
	.byte	$80
_OTM_L:
	.byte	$18
	.byte	$00
	.byte	$00
	.byte	$60
	.byte	$18
	.byte	$08
	.byte	$10
	.byte	$60
	.byte	$18
	.byte	$10
	.byte	$20
	.byte	$60
	.byte	$18
	.byte	$18
	.byte	$30
	.byte	$60
	.byte	$10
	.byte	$00
	.byte	$01
	.byte	$60
	.byte	$10
	.byte	$08
	.byte	$11
	.byte	$60
	.byte	$10
	.byte	$10
	.byte	$21
	.byte	$60
	.byte	$10
	.byte	$18
	.byte	$31
	.byte	$60
	.byte	$10
	.byte	$20
	.byte	$41
	.byte	$60
	.byte	$10
	.byte	$28
	.byte	$51
	.byte	$60
	.byte	$10
	.byte	$30
	.byte	$61
	.byte	$60
	.byte	$08
	.byte	$00
	.byte	$02
	.byte	$60
	.byte	$08
	.byte	$08
	.byte	$12
	.byte	$60
	.byte	$08
	.byte	$10
	.byte	$22
	.byte	$60
	.byte	$08
	.byte	$18
	.byte	$32
	.byte	$60
	.byte	$08
	.byte	$20
	.byte	$42
	.byte	$60
	.byte	$08
	.byte	$28
	.byte	$52
	.byte	$60
	.byte	$08
	.byte	$30
	.byte	$62
	.byte	$60
	.byte	$00
	.byte	$00
	.byte	$03
	.byte	$60
	.byte	$00
	.byte	$08
	.byte	$13
	.byte	$60
	.byte	$00
	.byte	$10
	.byte	$23
	.byte	$60
	.byte	$00
	.byte	$18
	.byte	$33
	.byte	$60
	.byte	$00
	.byte	$20
	.byte	$43
	.byte	$60
	.byte	$00
	.byte	$28
	.byte	$53
	.byte	$60
	.byte	$00
	.byte	$30
	.byte	$63
	.byte	$60
	.byte	$80
_initial_pallete:
	.byte	$55
	.byte	$55
	.byte	$55
	.byte	$55
	.byte	$55
	.byte	$55
	.byte	$55
	.byte	$55
	.byte	$55
	.byte	$55
	.byte	$55
	.byte	$55
	.byte	$55
	.byte	$55
	.byte	$55
	.byte	$55
	.byte	$55
	.byte	$55
	.byte	$55
	.byte	$55
	.byte	$55
	.byte	$55
	.byte	$55
	.byte	$55
	.byte	$55
	.byte	$55
	.byte	$55
	.byte	$55
	.byte	$55
	.byte	$55
	.byte	$55
	.byte	$55
	.byte	$FF
	.byte	$FF
	.byte	$FF
	.byte	$FF
	.byte	$FF
	.byte	$FF
	.byte	$FF
	.byte	$FF
	.byte	$FF
	.byte	$FF
	.byte	$FF
	.byte	$FF
	.byte	$FF
	.byte	$FF
	.byte	$FF
	.byte	$FF
	.byte	$AA
	.byte	$AA
	.byte	$AA
	.byte	$AA
	.byte	$AA
	.byte	$AA
	.byte	$AA
	.byte	$AA
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
_abilities_icons:
	.byte	$80
	.byte	$81
	.byte	$90
	.byte	$91
	.byte	$82
	.byte	$83
	.byte	$92
	.byte	$93
	.byte	$84
	.byte	$85
	.byte	$94
	.byte	$95
	.byte	$86
	.byte	$87
	.byte	$96
	.byte	$97
	.byte	$88
	.byte	$89
	.byte	$98
	.byte	$99
L10B4:
	.byte	$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20
	.byte	$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20
	.byte	$00
L1047	:=	L10B4+0
L103B	:=	L10B4+0
L0EAF:
	.byte	$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20
	.byte	$50,$4F,$49,$4E,$54,$53,$20,$20,$20,$20,$00
L0783:
	.byte	$20,$20,$20,$4B,$4F,$53,$41,$52,$49,$20,$43,$4F,$44,$45,$20,$41
	.byte	$43,$54,$49,$56,$41,$54,$45,$44,$20,$20,$00
L076D:
	.byte	$53,$45,$41,$52,$43,$48,$49,$4E,$47,$20,$46,$4F,$52,$20,$41,$4C
	.byte	$54,$45,$52,$4E,$41,$54,$49,$56,$45,$53,$00
L110E:
	.byte	$54,$48,$41,$4E,$4B,$20,$59,$4F,$55,$20,$46,$4F,$52,$20,$50,$4C
	.byte	$41,$59,$49,$4E,$47,$21,$00
L073E:
	.byte	$4B,$4F,$4E,$41,$4D,$49,$20,$43,$4F,$44,$45,$20,$4E,$4F,$54,$20
	.byte	$46,$4F,$55,$4E,$44,$00
L114E:
	.byte	$50,$52,$45,$53,$53,$20,$53,$54,$41,$52,$54,$20,$54,$4F,$20,$52
	.byte	$45,$54,$55,$52,$4E,$00
L0640	:=	L10B4+12
L10DE:
	.byte	$4F,$52,$49,$47,$49,$4E,$41,$4C,$20,$43,$4F,$4D,$49,$43,$53,$20
	.byte	$42,$59,$00
L078D	:=	L10B4+15
L10EE:
	.byte	$53,$50,$45,$43,$49,$41,$4C,$20,$54,$48,$41,$4E,$4B,$53,$20,$54
	.byte	$4F,$00
L0777	:=	L10B4+15
L10C6:
	.byte	$4F,$4E,$45,$20,$54,$48,$4F,$55,$53,$41,$4E,$44,$20,$4D,$41,$4E
	.byte	$00
L06FB	:=	L10C6+0
L10CE:
	.byte	$47,$41,$4D,$45,$20,$43,$52,$45,$41,$54,$45,$44,$20,$42,$59,$00
L0F47:
	.byte	$20,$41,$43,$54,$49,$56,$41,$54,$45,$44,$20,$20,$20,$20,$00
L0F3D:
	.byte	$20,$4D,$4F,$56,$45,$20,$41,$4E,$44,$20,$43,$55,$54,$20,$00
L0F04:
	.byte	$20,$41,$42,$49,$4C,$49,$54,$49,$45,$53,$20,$20,$20,$20,$00
L0F1A:
	.byte	$20,$50,$4F,$57,$45,$52,$20,$53,$4C,$41,$53,$48,$20,$20,$00
L0ED8:
	.byte	$20,$53,$4D,$41,$4C,$4C,$20,$53,$43,$59,$54,$48,$45,$20,$00
L0F0E:
	.byte	$20,$50,$4F,$57,$45,$52,$5B,$20,$20,$20,$20,$20,$20,$20,$00
L0EE2:
	.byte	$20,$5C,$20,$5B,$20,$41,$20,$20,$20,$20,$20,$20,$20,$20,$00
L0EF8:
	.byte	$20,$5E,$20,$5E,$20,$4F,$52,$20,$5F,$20,$5F,$20,$20,$20,$00
L0F24:
	.byte	$20,$5D,$20,$5D,$20,$5D,$20,$20,$20,$20,$20,$20,$20,$20,$00
L0EEE:
	.byte	$20,$44,$41,$53,$48,$20,$20,$20,$20,$20,$20,$20,$20,$20,$00
L10E6:
	.byte	$43,$59,$4E,$49,$43,$20,$4D,$41,$4E,$53,$49,$4F,$4E,$00
L10D6:
	.byte	$53,$50,$45,$52,$4C,$49,$4E,$47,$53,$4B,$41,$55,$5A,$00
L1157:
	.byte	$54,$4F,$20,$4D,$41,$49,$4E,$20,$4D,$45,$4E,$55,$00
L1160:
	.byte	$46,$49,$4E,$41,$4C,$20,$53,$43,$4F,$52,$45,$00
L1005:
	.byte	$43,$55,$54,$20,$53,$50,$45,$45,$44,$20,$00
L0FFE:
	.byte	$43,$55,$54,$20,$50,$4F,$57,$45,$52,$20,$00
L0FF7:
	.byte	$43,$55,$54,$20,$57,$49,$44,$54,$48,$20,$00
L1013:
	.byte	$53,$50,$45,$43,$49,$41,$4C,$20,$20,$20,$00
L100C:
	.byte	$4D,$4F,$56,$45,$20,$53,$50,$45,$45,$44,$00
L1145:
	.byte	$47,$41,$4D,$45,$20,$4F,$56,$45,$52,$00
L0667:
	.byte	$4C,$45,$56,$45,$4C,$20,$20,$20,$00
L067B:
	.byte	$46,$4C,$41,$53,$48,$20,$20,$20,$00
L0685:
	.byte	$52,$45,$54,$55,$52,$4E,$20,$20,$00
L0671:
	.byte	$45,$4E,$44,$4C,$45,$53,$53,$20,$00
L10FE:
	.byte	$4E,$45,$53,$44,$4F,$55,$47,$00
L065B:
	.byte	$4F,$50,$54,$49,$4F,$4E,$53,$00
L0621:
	.byte	$4E,$4F,$52,$4D,$41,$4C,$00
L0615:
	.byte	$45,$41,$53,$59,$20,$20,$00
L062D:
	.byte	$48,$41,$52,$44,$20,$20,$00
L08C8	:=	L1160+6
L08DA:
	.byte	$4C,$45,$56,$45,$4C,$00
L05AD	:=	L10B4+27
L10F6:
	.byte	$53,$48,$49,$52,$55,$00
L05AA:
	.byte	$53,$54,$41,$52,$54,$00
L0651	:=	L05AA+0
L0605:
	.byte	$4F,$46,$46,$20,$00
L05F6:
	.byte	$4F,$4E,$20,$00
L05F3:
	.byte	$4F,$46,$46,$00
L0602	:=	L10E6+11
L1106	:=	L10B4+31
L0F30:
	.byte	$5B,$00

.segment	"BSS"

.segment	"ZEROPAGE"
_pad1:
	.res	1,$00
_pad1_new:
	.res	1,$00
_tmp:
	.res	1,$00
_state:
	.res	1,$00
_index:
	.res	1,$00
_marker:
	.res	1,$00
_x:
	.res	1,$00
_y:
	.res	1,$00
_adr:
	.res	2,$00
_frame_tick:
	.res	1,$00
_rain_drop_x:
	.res	8,$00
_rain_drop_y:
	.res	8,$00
.segment	"BSS"
_bird_x:
	.res	4,$00
_bird_y:
	.res	4,$00
_bird_sprite:
	.res	1,$00
_bird_x_sprite:
	.res	1,$00
_bird_anim:
	.res	1,$00
_bird_state:
	.res	4,$00
_bird_health:
	.res	4,$00
_bird_tag:
	.res	4,$00
_bird_speed_delay:
	.res	4,$00
_bird_x_speed:
	.res	4,$00
_bird_pallete:
	.res	4,$00

; ---------------------------------------------------------------
; void __near__ set_breakpoint (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_set_breakpoint: near

.segment	"CODE"

;
; *(unsigned char*)0x00ff=1;
;
	lda     #$01
	sta     $00FF
;
; }
;
	rts

.endproc

; ---------------------------------------------------------------
; void __near__ tasm (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_tasm: near

.segment	"CODE"

;
; }
;
	rts

.endproc

; ---------------------------------------------------------------
; void __near__ d (unsigned int)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_d: near

.segment	"CODE"

;
; void d(unsigned int dt) {
;
	jsr     pushax
;
; one_vram_buffer(CHR_ZERO + dt / 100, NTADR_A(0, 1));
;
	jsr     pushw0sp
	lda     #$64
	jsr     tosudiva0
	clc
	adc     #$30
	jsr     pusha
	ldx     #$20
	txa
	jsr     _one_vram_buffer
;
; one_vram_buffer(CHR_ZERO + dt / 10 % 10, NTADR_A(1, 1));
;
	jsr     pushw0sp
	lda     #$0A
	jsr     tosudiva0
	jsr     pushax
	lda     #$0A
	jsr     tosumoda0
	clc
	adc     #$30
	jsr     pusha
	ldx     #$20
	lda     #$21
	jsr     _one_vram_buffer
;
; one_vram_buffer(CHR_ZERO + dt % 10, NTADR_A(2, 1));
;
	jsr     pushw0sp
	lda     #$0A
	jsr     tosumoda0
	clc
	adc     #$30
	jsr     pusha
	ldx     #$20
	lda     #$22
	jsr     _one_vram_buffer
;
; }
;
	jmp     incsp2

.endproc

; ---------------------------------------------------------------
; void __near__ d2 (unsigned int)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_d2: near

.segment	"CODE"

;
; void d2(unsigned int dt) {
;
	jsr     pushax
;
; one_vram_buffer(CHR_ZERO + dt / 100, NTADR_A(6, 1));
;
	jsr     pushw0sp
	lda     #$64
	jsr     tosudiva0
	clc
	adc     #$30
	jsr     pusha
	ldx     #$20
	lda     #$26
	jsr     _one_vram_buffer
;
; one_vram_buffer(CHR_ZERO + dt / 10 % 10, NTADR_A(7, 1));
;
	jsr     pushw0sp
	lda     #$0A
	jsr     tosudiva0
	jsr     pushax
	lda     #$0A
	jsr     tosumoda0
	clc
	adc     #$30
	jsr     pusha
	ldx     #$20
	lda     #$27
	jsr     _one_vram_buffer
;
; one_vram_buffer(CHR_ZERO + dt % 10, NTADR_A(8, 1));
;
	jsr     pushw0sp
	lda     #$0A
	jsr     tosumoda0
	clc
	adc     #$30
	jsr     pusha
	ldx     #$20
	lda     #$28
	jsr     _one_vram_buffer
;
; }
;
	jmp     incsp2

.endproc

; ---------------------------------------------------------------
; void __near__ nmi_wait_and_prepare (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_nmi_wait_and_prepare: near

.segment	"CODE"

;
; ppu_wait_nmi();
;
	jsr     _ppu_wait_nmi
;
; pad1 = pad_poll(0);
;
	lda     #$00
	jsr     _pad_poll
	sta     _pad1
;
; pad1_new = get_pad_new(0);
;
	lda     #$00
	jsr     _get_pad_new
	sta     _pad1_new
;
; clear_vram_buffer();
;
	jmp     _clear_vram_buffer

.endproc

; ---------------------------------------------------------------
; void __near__ clear_screen (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_clear_screen: near

.segment	"CODE"

;
; clear_vram_buffer();
;
	jsr     _clear_vram_buffer
;
; vram_adr(NAMETABLE_A);
;
	ldx     #$20
	lda     #$00
	jsr     _vram_adr
;
; for(x = 0x00; x != 0x20; ++x) {
;
	lda     #$00
	sta     _x
L1193:	lda     _x
	cmp     #$20
	beq     L048B
;
; for(y = 0x00; y != 0x1D; ++y) {
;
	lda     #$00
	sta     _y
L1194:	lda     _y
	cmp     #$1D
	beq     L1195
;
; vram_put(0x00);
;
	lda     #$00
	jsr     _vram_put
;
; for(y = 0x00; y != 0x1D; ++y) {
;
	inc     _y
	jmp     L1194
;
; for(x = 0x00; x != 0x20; ++x) {
;
L1195:	inc     _x
	jmp     L1193
;
; oam_clear();
;
L048B:	jmp     _oam_clear

.endproc

; ---------------------------------------------------------------
; void __near__ fade_in (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_fade_in: near

.segment	"CODE"

;
; pal_fade_to(5, 0);
;
	lda     #$05
	jsr     pusha
	lda     #$00
	jsr     _pal_fade_to
;
; delay(10);
;
	lda     #$0A
	jmp     _delay

.endproc

; ---------------------------------------------------------------
; void __near__ fade_out (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_fade_out: near

.segment	"CODE"

;
; delay(10);
;
	lda     #$0A
	jsr     _delay
;
; pal_fade_to(0, 4);
;
	lda     #$00
	jsr     pusha
	lda     #$04
	jmp     _pal_fade_to

.endproc

; ---------------------------------------------------------------
; void __near__ delay_with_state_skip (unsigned char)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_delay_with_state_skip: near

.segment	"CODE"

;
; void delay_with_state_skip(unsigned char delay_length) {
;
	jsr     pusha
;
; for(tmp = 1; tmp != delay_length; ++tmp) {
;
	lda     #$01
	sta     _tmp
L04AA:	ldy     #$00
	lda     (sp),y
	cmp     _tmp
	beq     L04AB
;
; nmi_wait_and_prepare();
;
	jsr     _nmi_wait_and_prepare
;
; if (state == 1) break;
;
	lda     _state
	cmp     #$01
	beq     L04AB
;
; if (pad1_new & PAD_START) state = 1;
;
	lda     _pad1_new
	and     #$10
	beq     L1197
	lda     #$01
	sta     _state
;
; for(tmp = 1; tmp != delay_length; ++tmp) {
;
L1197:	inc     _tmp
	jmp     L04AA
;
; }
;
L04AB:	jmp     incsp1

.endproc

; ---------------------------------------------------------------
; void __near__ put_str (unsigned int, __near__ const unsigned char *)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_put_str: near

.segment	"CODE"

;
; void put_str(unsigned int address, const char *str) {
;
	jsr     pushax
;
; vram_adr(address);
;
	ldy     #$03
	lda     (sp),y
	tax
	dey
	lda     (sp),y
	jsr     _vram_adr
;
; if (!*str) break;
;
L04BC:	ldy     #$01
	lda     (sp),y
	sta     ptr1+1
	dey
	lda     (sp),y
	sta     ptr1
	lda     (ptr1),y
	beq     L04BD
;
; vram_put((*str++) - 0x00);
;
	iny
	lda     (sp),y
	tax
	dey
	lda     (sp),y
	sta     regsave
	stx     regsave+1
	clc
	adc     #$01
	bcc     L04C5
	inx
L04C5:	jsr     stax0sp
	ldy     #$00
	lda     (regsave),y
	jsr     _vram_put
;
; while(1) {
;
	jmp     L04BC
;
; } 
;
L04BD:	jmp     incsp4

.endproc

; ---------------------------------------------------------------
; void __near__ put_char (unsigned int, __near__ const unsigned char *, unsigned char)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_put_char: near

.segment	"CODE"

;
; void put_char(unsigned int address, const char *str, unsigned char num) {
;
	jsr     pusha
;
; unsigned char npos = 0;
;
	lda     #$00
	jsr     pusha
;
; if (!*str) break;
;
L04C8:	ldy     #$03
	lda     (sp),y
	sta     ptr1+1
	dey
	lda     (sp),y
	sta     ptr1
	ldy     #$00
	lda     (ptr1),y
	beq     L04C9
;
; if (npos == num) {
;
	lda     (sp),y
	iny
	cmp     (sp),y
	bne     L04CE
;
; one_vram_buffer(*str, address);
;
	ldy     #$03
	lda     (sp),y
	sta     ptr1+1
	dey
	lda     (sp),y
	sta     ptr1
	ldy     #$00
	lda     (ptr1),y
	jsr     pusha
	ldy     #$06
	lda     (sp),y
	tax
	dey
	lda     (sp),y
	jsr     _one_vram_buffer
;
; break;
;
	jmp     incsp6
;
; *str++;
;
L04CE:	ldy     #$03
	lda     (sp),y
	tax
	dey
	lda     (sp),y
	clc
	adc     #$01
	bcc     L04D5
	inx
L04D5:	jsr     staxysp
;
; ++npos;
;
	ldy     #$00
	clc
	lda     #$01
	adc     (sp),y
	sta     (sp),y
;
; while(1) {
;
	jmp     L04C8
;
; } 
;
L04C9:	jmp     incsp6

.endproc

; ---------------------------------------------------------------
; void __near__ put_number (unsigned int, unsigned int, unsigned char)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_put_number: near

.segment	"CODE"

;
; void put_number(unsigned int address, unsigned int number, unsigned char zero_count) {
;
	jsr     pusha
;
; adr = number;
;
	ldy     #$02
	lda     (sp),y
	sta     _adr+1
	dey
	lda     (sp),y
	sta     _adr
;
; x = 0;
;
	lda     #$00
	sta     _x
;
; while(adr != 0) {
;
	jmp     L04DE
;
; ++x;
;
L04DC:	inc     _x
;
; adr /= 10;
;
	lda     _adr
	ldx     _adr+1
	jsr     pushax
	lda     #$0A
	jsr     tosudiva0
	sta     _adr
	stx     _adr+1
;
; while(adr != 0) {
;
L04DE:	lda     _adr
	ora     _adr+1
	bne     L04DC
;
; if(number == 0) {
;
	ldy     #$01
	lda     (sp),y
	iny
	ora     (sp),y
	bne     L04E4
;
; vram_adr(address + 1);
;
	ldy     #$04
	lda     (sp),y
	tax
	dey
	lda     (sp),y
	clc
	adc     #$01
	bcc     L04E9
	inx
L04E9:	jsr     _vram_adr
;
; vram_put(CHR_ZERO);
;
	lda     #$30
	jsr     _vram_put
;
; } else {
;
	jmp     incsp5
;
; for(y = 0x00; y != x; ++y) {
;
L04E4:	lda     #$00
	sta     _y
L119E:	lda     _x
	cmp     _y
	beq     L04EE
;
; adr = number % 10;
;
	ldy     #$04
	jsr     pushwysp
	lda     #$0A
	jsr     tosumoda0
	sta     _adr
	stx     _adr+1
;
; number /= 10;
;
	ldy     #$04
	jsr     pushwysp
	lda     #$0A
	jsr     tosudiva0
	ldy     #$01
	jsr     staxysp
;
; vram_adr(address + x - y);
;
	ldy     #$04
	lda     (sp),y
	tax
	dey
	lda     (sp),y
	clc
	adc     _x
	bcc     L1199
	inx
L1199:	sec
	sbc     _y
	pha
	txa
	sbc     #$00
	tax
	pla
	jsr     _vram_adr
;
; vram_put(CHR_ZERO + adr);
;
	lda     _adr
	clc
	adc     #$30
	jsr     _vram_put
;
; for(y = 0x00; y != x; ++y) {
;
	inc     _y
	jmp     L119E
;
; vram_adr(address + x + 1);
;
L04EE:	ldy     #$04
	lda     (sp),y
	tax
	dey
	lda     (sp),y
	clc
	adc     _x
	bcc     L119D
	inx
	clc
L119D:	adc     #$01
	bcc     L0500
	inx
L0500:	jsr     _vram_adr
;
; for(y = 0x00; y != zero_count; ++y) {
;
	lda     #$00
	sta     _y
L0501:	ldy     #$00
	lda     (sp),y
	cmp     _y
	beq     L0502
;
; vram_put(CHR_ZERO);
;
	lda     #$30
	jsr     _vram_put
;
; for(y = 0x00; y != zero_count; ++y) {
;
	inc     _y
	jmp     L0501
;
; }
;
L0502:	jmp     incsp5

.endproc

; ---------------------------------------------------------------
; void __near__ game_initial_values_set (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_game_initial_values_set: near

.segment	"CODE"

;
; for(x = 0x00; x != RAIN_COUNT; ++x) {
;
	lda     #$00
	sta     _x
L119F:	lda     _x
	cmp     #$08
	beq     L11A0
;
; rain_drop_x[x] = 0;
;
	ldy     _x
	lda     #$00
	sta     _rain_drop_x,y
;
; rain_drop_y[x] = 0;
;
	ldy     _x
	sta     _rain_drop_y,y
;
; for(x = 0x00; x != RAIN_COUNT; ++x) {
;
	inc     _x
	jmp     L119F
;
; points = 1;
;
L11A0:	lda     #$01
	sta     _points
;
; score = 0;
;
	lda     #$00
	sta     _score
	sta     _score+1
;
; game.level = 1;
;
	lda     #$01
	sta     _game
;
; game.lives = 3;
;
	lda     #$03
	sta     _game+7
;
; game.max_play_time = 10;
;
	lda     #$0A
	sta     _game+5
;
; grass.delay_max = 20;
;
	lda     #$14
	sta     _grass+1
;
; grass.instant_count = 1;
;
	lda     #$01
	sta     _grass+2
;
; grass.col_for_point = 18;
;
	lda     #$12
	sta     _grass+3
;
; player.move_delay = 0; 
;
	lda     #$00
	sta     _player+4
;
; player.move_max_delay = 2;
;
	lda     #$02
	sta     _player+5
;
; player.move_increase = 0;
;
	lda     #$00
	sta     _player+6
;
; player.move_max_increase = 0;
;
	sta     _player+7
;
; player.abilities.selection = 0;
;
	sta     _player+16
;
; player.abilities.list[ABILITY_CUT_SPEED] = 0;
;
	sta     _player+17
;
; player.abilities.list[ABILITY_CUT_POWER] = 0;
;
	sta     _player+18
;
; player.abilities.list[ABILITY_CUT_SIZE] = 0;
;
	sta     _player+19
;
; player.abilities.list[ABILITY_MOVE_SPEED] = 0;
;
	sta     _player+20
;
; player.abilities.list[ABILITY_SPECIAL] = 0;
;
	sta     _player+21
;
; player.abilities.elevel = 0;
;
	sta     _player+22
;
; player.cut.power = 1;
;
	lda     #$01
	sta     _player+9
;
; player.cut.size = 2;
;
	lda     #$02
	sta     _player+10
;
; player.cut.delay = 10;
;
	lda     #$0A
	sta     _player+12
;
; player.cut.max_delay = 10;
;
	sta     _player+13
;
; player.cut.count = 0;
;
	lda     #$00
	sta     _player+15
;
; set_vram_buffer(); 
;
	jsr     _set_vram_buffer
;
; ppu_off();
;
	jsr     _ppu_off
;
; bank_spr(1);
;
	lda     #$01
	jsr     _bank_spr
;
; ppu_on_all();
;
	jmp     _ppu_on_all

.endproc

; ---------------------------------------------------------------
; void __near__ game_process_next_level (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_game_process_next_level: near

.segment	"CODE"

;
; fade_in();
;
	jsr     _fade_in
;
; ppu_off();
;
	jsr     _ppu_off
;
; pal_bg(game_palette_bg);
;
	lda     #<(_game_palette_bg)
	ldx     #>(_game_palette_bg)
	jsr     _pal_bg
;
; pal_spr(game_palette_sp);
;
	lda     #<(_game_palette_sp)
	ldx     #>(_game_palette_sp)
	jsr     _pal_spr
;
; clear_vram_buffer();
;
	jsr     _clear_vram_buffer
;
; if (game.state == GAME_ST_LEVEL_END_WIN) {
;
	lda     _game+3
	cmp     #$03
	jne     L11AF
;
; ++game.level;
;
	inc     _game
;
; switch(game.difficulty) {
;
	lda     _game+6
;
; }
;
	beq     L11A3
	cmp     #$01
	beq     L11A7
	cmp     #$02
	beq     L11AC
	jmp     L11AF
;
; if (grass.delay_max != 10) --grass.delay_max;
;
L11A3:	lda     _grass+1
	cmp     #$0A
	beq     L11A4
	dec     _grass+1
;
; if (game.level % 3 == 0 && grass.instant_count != 10) ++grass.instant_count;
;
L11A4:	lda     _game
	jsr     pusha0
	lda     #$03
	jsr     tosumoda0
	cpx     #$00
	bne     L11A6
	cmp     #$00
	bne     L11A6
	lda     _grass+2
	cmp     #$0A
	beq     L11A6
	inc     _grass+2
;
; if (game.max_play_time != 60) game.max_play_time += 2;
;
L11A6:	lda     _game+5
	cmp     #$3C
	beq     L11AF
	lda     #$02
;
; break;
;
	jmp     L11BA
;
; if (grass.delay_max != 8) --grass.delay_max;
;
L11A7:	lda     _grass+1
	cmp     #$08
	beq     L11A8
	dec     _grass+1
;
; if (game.level % 2 == 0 && grass.instant_count != 10) ++grass.instant_count;
;
L11A8:	lda     _game
	and     #$01
	bne     L11AB
	lda     _grass+2
	cmp     #$0A
	beq     L11AB
	inc     _grass+2
;
; if (game.max_play_time != 60) game.max_play_time += 4;
;
L11AB:	lda     _game+5
	cmp     #$3C
	beq     L11AF
	lda     #$04
;
; break;
;
	jmp     L11BA
;
; if (grass.delay_max != 6) --grass.delay_max;
;
L11AC:	lda     _grass+1
	cmp     #$06
	beq     L11AD
	dec     _grass+1
;
; if (grass.instant_count != 10) ++grass.instant_count;
;
L11AD:	lda     _grass+2
	cmp     #$0A
	beq     L11AE
	inc     _grass+2
;
; if (game.max_play_time != 60) game.max_play_time += 6;
;
L11AE:	lda     _game+5
	cmp     #$3C
	beq     L11AF
	lda     #$06
L11BA:	clc
	adc     _game+5
	sta     _game+5
;
; game.play_time = game.max_play_time;
;
L11AF:	lda     _game+5
	sta     _game+4
;
; game.state = GAME_ST_LEVEL_PLAYING;
;
	lda     #$01
	sta     _game+3
;
; grass.delay = grass.delay_max;
;
	lda     _grass+1
	sta     _grass
;
; vram_adr(NAMETABLE_A);
;
	ldx     #$20
	lda     #$00
	jsr     _vram_adr
;
; for(x = 0x00; x != 0x20; ++x) 
;
	lda     #$00
	sta     _x
L11B0:	lda     _x
	cmp     #$20
	beq     L11B3
;
; for(y = 0x00; y != 0x1D; ++y) 
;
	lda     #$00
	sta     _y
L11B1:	lda     _y
	cmp     #$1D
	beq     L11B2
;
; vram_put(CHR_BG_BLANK);
;
	lda     #$7F
	jsr     _vram_put
;
; for(y = 0x00; y != 0x1D; ++y) 
;
	inc     _y
	jmp     L11B1
;
; for(x = 0x00; x != 0x20; ++x) 
;
L11B2:	inc     _x
	jmp     L11B0
;
; for(x = 0x00; x != BIRDS_COUNT; ++x) 
;
L11B3:	lda     #$00
	sta     _x
L11B4:	lda     _x
	cmp     #$04
	beq     L11B5
;
; bird_state[x] = 0;
;
	ldy     _x
	lda     #$00
	sta     _bird_state,y
;
; for(x = 0x00; x != BIRDS_COUNT; ++x) 
;
	inc     _x
	jmp     L11B4
;
; for (x = 0x00; x < RAIN_COUNT; ++x) {
;
L11B5:	lda     #$00
	sta     _x
L11B6:	lda     _x
	cmp     #$08
	bcs     L08B2
;
; rain_drop_x[x] = rand8();
;
	lda     #<(_rain_drop_x)
	ldx     #>(_rain_drop_x)
	clc
	adc     _x
	bcc     L08BB
	inx
L08BB:	jsr     pushax
	jsr     _rand8
	ldy     #$00
	jsr     staspidx
;
; rain_drop_y[x] = rand8();
;
	lda     #<(_rain_drop_y)
	ldx     #>(_rain_drop_y)
	clc
	adc     _x
	bcc     L08BF
	inx
L08BF:	jsr     pushax
	jsr     _rand8
	ldy     #$00
	jsr     staspidx
;
; for (x = 0x00; x < RAIN_COUNT; ++x) {
;
	inc     _x
	jmp     L11B6
;
; put_str(NTADR_A(0x0D, 0x09), "SCORE");
;
L08B2:	ldx     #$21
	lda     #$2D
	jsr     pushax
	lda     #<(L08C8)
	ldx     #>(L08C8)
	jsr     _put_str
;
; put_number(NTADR_A(0x12, 0x09), score, 2);
;
	jsr     decsp4
	lda     #$32
	ldy     #$02
	sta     (sp),y
	iny
	lda     #$21
	sta     (sp),y
	lda     _score
	ldy     #$00
	sta     (sp),y
	iny
	lda     _score+1
	sta     (sp),y
	lda     #$02
	jsr     _put_number
;
; put_str(NTADR_A(0x0D, 0x0B), "LEVEL");
;
	ldx     #$21
	lda     #$6D
	jsr     pushax
	lda     #<(L08DA)
	ldx     #>(L08DA)
	jsr     _put_str
;
; vram_adr(NTADR_A(0x13, 0x0B));
;
	ldx     #$21
	lda     #$73
	jsr     _vram_adr
;
; if (game.level >= 10) {
;
	lda     _game
	cmp     #$0A
	bcc     L11B7
;
; vram_put(CHR_ZERO + game.level / 10);
;
	lda     _game
	jsr     pusha0
	lda     #$0A
	jsr     tosudiva0
	clc
	adc     #$30
	jsr     _vram_put
;
; vram_put(CHR_ZERO + game.level % 10);
;
	lda     _game
	jsr     pusha0
	lda     #$0A
	jsr     tosumoda0
;
; } else {
;
	jmp     L11BB
;
; vram_put(CHR_ZERO + game.level);
;
L11B7:	lda     _game
L11BB:	clc
	adc     #$30
	jsr     _vram_put
;
; vram_adr(NTADR_A(0x0F, 0x0D));
;
	ldx     #$21
	lda     #$AF
	jsr     _vram_adr
;
; vram_put(CHR_LIVE);
;
	lda     #$A7
	jsr     _vram_put
;
; vram_put(CHR_CROSS);
;
	lda     #$2F
	jsr     _vram_put
;
; vram_put(CHR_ZERO + game.lives);
;
	lda     _game+7
	clc
	adc     #$30
	jsr     _vram_put
;
; oam_clear();
;
	jsr     _oam_clear
;
; ppu_on_all();
;
	jsr     _ppu_on_all
;
; fade_out();
;
	jsr     _fade_out
;
; delay(120);
;
	lda     #$78
	jmp     _delay

.endproc

; ---------------------------------------------------------------
; void __near__ game_grass_grow (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_game_grass_grow: near

.segment	"CODE"

;
; if (game_calc_state == GCS_CHECK) {
;
	lda     _game_calc_state
	cmp     #$01
	jne     L11C1
;
; game_calc_state = GCS_NORMAL;
;
	lda     #$00
	sta     _game_calc_state
;
; total_height = 0;
;
	sta     _adr
	sta     _adr+1
;
; for(x = 0x00; x != 0x20; ++x) total_height += grass.height[x];
;
	sta     _x
L11BE:	lda     _x
	cmp     #$20
	beq     L0A97
	ldy     _x
	lda     _grass+4,y
	clc
	adc     _adr
	sta     _adr
	lda     #$00
	adc     _adr+1
	sta     _adr+1
	inc     _x
	jmp     L11BE
;
; if (total_height > GRASS_SBLOCK * 6) {
;
L0A97:	lda     _adr
	cmp     #$D3
	lda     _adr+1
	sbc     #$00
	bcc     L0AA2
;
; one_vram_buffer(0xA6, NTADR_A(0x1D, Y_EDGE));
;
	lda     #$A6
	jsr     pusha
	ldx     #$23
	lda     #$9D
	jsr     _one_vram_buffer
;
; one_vram_buffer(0x9E + total_height / GRASS_SBLOCK, NTADR_A(0x1E, Y_EDGE));
;
	lda     _adr
	ldx     _adr+1
	jsr     pushax
	lda     #$23
	jsr     tosudiva0
	clc
	adc     #$9E
	jsr     pusha
	ldx     #$23
	lda     #$9E
	jsr     _one_vram_buffer
;
; if (total_height > GRASS_SBLOCK * 8) {
;
	lda     _adr
	cmp     #$19
	lda     _adr+1
	sbc     #$01
	bcc     L0AD6
;
; sfx_play(SND_GAME_LOSE, 0);
;
	lda     #$07
	jsr     pusha
	lda     #$00
	jsr     _sfx_play
;
; game.state = GAME_ST_LEVEL_LOSE;
;
	lda     #$04
	sta     _game+3
;
; player.cut.state = 0;
;
	lda     #$00
	sta     _player+11
;
; --game.lives;
;
	dec     _game+7
;
; } else {
;
	rts
;
; if (total_height > GRASS_SBLOCK * 4) {
;
L0AA2:	lda     _adr
	cmp     #$8D
	lda     _adr+1
	sbc     #$00
	bcc     L0AC0
;
; one_vram_buffer(0xA3, NTADR_A(0x1D, Y_EDGE));
;
	lda     #$A3
	jsr     pusha
	ldx     #$23
	lda     #$9D
	jsr     _one_vram_buffer
;
; one_vram_buffer(total_height > GRASS_SBLOCK * 5 ? 0xA0 : 0x7F, NTADR_A(0x1E, Y_EDGE));
;
	lda     _adr
	cmp     #$B0
	lda     _adr+1
	sbc     #$00
	bcc     L11BF
	lda     #$A0
	jmp     L11C0
L11BF:	lda     #$7F
L11C0:	jsr     pusha
	ldx     #$23
	lda     #$9E
	jmp     _one_vram_buffer
;
; one_vram_buffer(0x9F + total_height / GRASS_SBLOCK, NTADR_A(0x1D, Y_EDGE));
;
L0AC0:	lda     _adr
	ldx     _adr+1
	jsr     pushax
	lda     #$23
	jsr     tosudiva0
	clc
	adc     #$9F
	jsr     pusha
	ldx     #$23
	lda     #$9D
	jsr     _one_vram_buffer
;
; one_vram_buffer(0x7F, NTADR_A(0x1E, Y_EDGE));
;
	lda     #$7F
	jsr     pusha
	ldx     #$23
	lda     #$9E
	jmp     _one_vram_buffer
;
; } else {
;
L0AD6:	rts
;
; --grass.delay;
;
L11C1:	dec     _grass
;
; if (grass.delay == 0x00) {
;
	beq     L11C7
;
; }
;
	rts
;
; game_calc_state = GCS_CHECK;
;
L11C7:	lda     #$01
	sta     _game_calc_state
;
; grass.delay = grass.delay_max;
;
	lda     _grass+1
	sta     _grass
;
; for (y = 0x00; ; ++y) {
;
	lda     #$00
	sta     _y
;
; x = (rand8() >> 3);
;
L0AF3:	jsr     _rand8
	jsr     asrax3
	sta     _x
;
; single_sprout = grass.height[x];
;
	ldy     _x
	lda     _grass+4,y
	sta     _tmp
;
; if (single_sprout != 12) {
;
	cmp     #$0C
	jeq     L11C6
;
; ++single_sprout;
;
	inc     _tmp
;
; if (single_sprout == 5) one_vram_buffer(5, NTADR_A(x, GRASS_BORDER));
;
	lda     _tmp
	cmp     #$05
	bne     L11C2
	jsr     pusha
	lda     _x
	ora     #$E0
	ldx     #$22
	jsr     _one_vram_buffer
;
; if (single_sprout == 9) one_vram_buffer(5, NTADR_A(x, GRASS_BORDER - 1));
;
L11C2:	lda     _tmp
	cmp     #$09
	bne     L11C3
	lda     #$05
	jsr     pusha
	lda     _x
	ora     #$C0
	ldx     #$22
	jsr     _one_vram_buffer
;
; if (single_sprout > 8) index = 2; 
;
L11C3:	lda     _tmp
	cmp     #$09
	bcc     L11C4
	lda     #$02
;
; else if (single_sprout > 4) index = 1; 
;
	jmp     L11BD
L11C4:	lda     _tmp
	cmp     #$05
	lda     #$00
	bcc     L11BD
	lda     #$01
;
; else index = 0;
;
L11BD:	sta     _index
;
; grass.height[x] = single_sprout;
;
	ldy     _x
	lda     _tmp
	sta     _grass+4,y
;
; one_vram_buffer(single_sprout - index * 4, NTADR_A(x, GRASS_BORDER - index));
;
	lda     _tmp
	jsr     pusha0
	lda     _index
	jsr     shlax2
	jsr     tossubax
	jsr     pusha
	lda     #$17
	sec
	sbc     _index
	ldx     #$00
	jsr     shlax4
	stx     tmp1
	asl     a
	rol     tmp1
	sta     ptr1
	lda     _x
	ora     ptr1
	pha
	lda     tmp1
	ora     #$20
	tax
	pla
	jsr     _one_vram_buffer
;
; if (y == grass.instant_count) break;
;
L11C6:	lda     _grass+2
	cmp     _y
	beq     L0AF1
;
; for (y = 0x00; ; ++y) {
;
	inc     _y
	jmp     L0AF3
;
; }
;
L0AF1:	rts

.endproc

; ---------------------------------------------------------------
; void __near__ game_grass_cf_prepare (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_game_grass_cf_prepare: near

.segment	"CODE"

;
; if (single_sprout > 8) index = 2; 
;
	lda     _tmp
	cmp     #$09
	bcc     L11C9
	lda     #$02
;
; else if (single_sprout > 4) index = 1; 
;
	jmp     L11C8
L11C9:	lda     _tmp
	cmp     #$05
	lda     #$00
	bcc     L11C8
	lda     #$01
;
; else index = 0;
;
L11C8:	sta     _index
;
; }
;
	rts

.endproc

; ---------------------------------------------------------------
; void __near__ game_grass_cf_finalize (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_game_grass_cf_finalize: near

.segment	"CODE"

;
; if (index == 2) {
;
	lda     _index
	cmp     #$02
	bne     L11CC
;
; if (single_sprout < 9) one_vram_buffer(0, NTADR_A(x, GRASS_BORDER - 2));
;
	lda     _tmp
	cmp     #$09
	bcs     L11CC
	lda     #$00
	jsr     pusha
	lda     _x
	ora     #$A0
	ldx     #$22
	jsr     _one_vram_buffer
;
; if (index == 1 || index == 2) {
;
L11CC:	lda     _index
	cmp     #$01
	beq     L11CF
	cmp     #$02
	bne     L11D0
;
; if (single_sprout < 5) one_vram_buffer(0, NTADR_A(x, GRASS_BORDER - 1));
;
L11CF:	lda     _tmp
	cmp     #$05
	bcs     L11D0
	lda     #$00
	jsr     pusha
	lda     _x
	ora     #$C0
	ldx     #$22
	jsr     _one_vram_buffer
;
; if (single_sprout > 8) index = 2; 
;
L11D0:	lda     _tmp
	cmp     #$09
	bcc     L11D1
	lda     #$02
;
; else if (single_sprout > 4) index = 1; 
;
	jmp     L11CB
L11D1:	lda     _tmp
	cmp     #$05
	lda     #$00
	bcc     L11CB
	lda     #$01
;
; else index = 0;
;
L11CB:	sta     _index
;
; one_vram_buffer(single_sprout - index * 4, NTADR_A(x, GRASS_BORDER - index));  
;
	lda     _tmp
	jsr     pusha0
	lda     _index
	jsr     shlax2
	jsr     tossubax
	jsr     pusha
	lda     #$17
	sec
	sbc     _index
	ldx     #$00
	jsr     shlax4
	stx     tmp1
	asl     a
	rol     tmp1
	sta     ptr1
	lda     _x
	ora     ptr1
	pha
	lda     tmp1
	ora     #$20
	tax
	pla
	jsr     _one_vram_buffer
;
; grass.height[x] = single_sprout;
;
	ldy     _x
	lda     _tmp
	sta     _grass+4,y
;
; }
;
	rts

.endproc

; ---------------------------------------------------------------
; void __near__ game_grass_fading (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_game_grass_fading: near

.segment	"CODE"

;
; x = (rand8() >> 3);
;
	jsr     _rand8
	jsr     asrax3
	sta     _x
;
; single_sprout = grass.height[x];
;
	ldy     _x
	lda     _grass+4,y
	sta     _tmp
;
; if (single_sprout > 2) {
;
	cmp     #$03
	bcc     L0BA0
;
; game_grass_cf_prepare();
;
	jsr     _game_grass_cf_prepare
;
; --single_sprout;
;
	dec     _tmp
;
; game_grass_cf_finalize();
;
	jsr     _game_grass_cf_finalize
;
; ++adr;
;
L0BA0:	inc     _adr
	bne     L0BA6
	inc     _adr+1
;
; if (adr == GAME_WIN_TIME) game.state = GAME_ST_LEVEL_END_WIN;
;
L0BA6:	lda     _adr+1
	bne     L0BA7
	lda     _adr
	cmp     #$80
	bne     L0BA7
	lda     #$03
	sta     _game+3
;
; }
;
L0BA7:	rts

.endproc

; ---------------------------------------------------------------
; void __near__ game_grass_overgrow (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_game_grass_overgrow: near

.segment	"CODE"

;
; --grass.delay;
;
	dec     _grass
;
; if (grass.delay == 0x00) {
;
	beq     L11DA
;
; }
;
	rts
;
; game_calc_state = GCS_CHECK;
;
L11DA:	lda     #$01
	sta     _game_calc_state
;
; grass.delay = 0x14;
;
	lda     #$14
	sta     _grass
;
; state = (player.x & 0xF8) / 8;
;
	lda     _player
	and     #$F8
	lsr     a
	lsr     a
	lsr     a
	sta     _state
;
; index = 0;
;
	lda     #$00
	sta     _index
;
; for (x = state; x != state + 6; ++x) {
;
	lda     _state
	sta     _x
	ldx     #$00
L11D5:	lda     _state
	clc
	adc     #$06
	bcc     L0BC0
	inx
L0BC0:	cpx     #$00
	bne     L11D9
	cmp     _x
	jeq     L0BBA
;
; single_sprout = grass.height[x];
;
L11D9:	ldy     _x
	lda     _grass+4,y
	sta     _tmp
;
; for (y = 0x01; y != 0x07; ++y) {
;
	lda     #$01
	sta     _y
L11D6:	lda     _y
	cmp     #$07
	beq     L11D7
;
; if (single_sprout <= y * 4) {
;
	lda     _tmp
	jsr     pusha0
	lda     _y
	jsr     shlax2
	jsr     tosicmp
	beq     L11D4
	bcs     L0BC8
;
; one_vram_buffer(0xA3, NTADR_A(x, GRASS_BORDER - y + 1));
;
L11D4:	lda     #$A3
	jsr     pusha
	lda     #$17
	sec
	sbc     _y
	ldx     #$00
	clc
	adc     #$01
	bcc     L0BD7
	inx
L0BD7:	jsr     shlax4
	stx     tmp1
	asl     a
	rol     tmp1
	sta     ptr1
	lda     _x
	ora     ptr1
	pha
	lda     tmp1
	ora     #$20
	tax
	pla
	jsr     _one_vram_buffer
;
; one_vram_buffer(0x01, NTADR_A(x, GRASS_BORDER - y));
;
	lda     #$01
	jsr     pusha
	lda     #$17
	sec
	sbc     _y
	ldx     #$00
	jsr     shlax4
	stx     tmp1
	asl     a
	rol     tmp1
	sta     ptr1
	lda     _x
	ora     ptr1
	pha
	lda     tmp1
	ora     #$20
	tax
	pla
	jsr     _one_vram_buffer
;
; break;
;
	jmp     L11D7
;
; for (y = 0x01; y != 0x07; ++y) {
;
L0BC8:	inc     _y
	jmp     L11D6
;
; single_sprout += 4;
;
L11D7:	lda     #$04
	clc
	adc     _tmp
	sta     _tmp
;
; grass.height[x] = single_sprout;
;
	ldy     _x
	lda     _tmp
	sta     _grass+4,y
;
; if (y == 0x07) ++index;
;
	ldx     #$00
	lda     _y
	cmp     #$07
	bne     L11D8
	inc     _index
;
; for (x = state; x != state + 6; ++x) {
;
L11D8:	inc     _x
	jmp     L11D5
;
; if (index == 0x06) game.state = GAME_ST_LEVEL_END_LOSE;
;
L0BBA:	lda     _index
	cmp     #$06
	bne     L0BEA
	lda     #$05
	sta     _game+3
;
; }
;
L0BEA:	rts

.endproc

; ---------------------------------------------------------------
; void __near__ game_grass_cut (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_game_grass_cut: near

.segment	"CODE"

;
; x = (player.x / 8) + 2;
;
	lda     _player
	lsr     a
	lsr     a
	lsr     a
	clc
	adc     #$02
	sta     _x
;
; state = 0;
;
	lda     #$00
	sta     _state
;
; corr_power = player.cut.power;
;
	lda     _player+9
	sta     _marker
;
; if (game.effects.lightning == 0 && game.effects.wind == 0) sfx_play(SND_GAME_CUT, 1);
;
	lda     _game+8
	bne     L11E6
	lda     _game+10
	bne     L11E6
	lda     #$04
	jsr     pusha
	lda     #$01
	jsr     _sfx_play
;
; for (y = 0; y != player.cut.size; ++y) {
;
L11E6:	lda     #$00
	sta     _y
L11E1:	lda     _player+10
	cmp     _y
	jeq     L11E5
;
; if (state == 0) {
;
	lda     _state
	bne     L11E3
;
; x += y;
;
	lda     _y
	clc
	adc     _x
	sta     _x
;
; state = 1; 
;
	lda     #$01
	sta     _state
;
; if (player.abilities.list[ABILITY_CUT_POWER] < ABILITY_MAX_LEVEL) {
;
	lda     _player+18
	cmp     #$05
	bcs     L0B59
;
; if (corr_power > (player.abilities.list[ABILITY_CUT_POWER] < ABILITY_EX_LEVEL ? 1 : 2)) --corr_power;
;
	lda     _marker
	jsr     pusha0
	lda     _player+18
	cmp     #$03
	bcs     L11E2
	lda     #$01
	jmp     L0B56
L11E2:	lda     #$02
L0B56:	jsr     tosicmp0
	bcc     L0B59
	beq     L0B59
	dec     _marker
;
; } else {
;
	jmp     L0B59
;
; x -= y;
;
L11E3:	lda     _y
	eor     #$FF
	sec
	adc     _x
	sta     _x
;
; state = 0;
;
	lda     #$00
	sta     _state
;
; single_sprout = grass.height[x];
;
L0B59:	ldy     _x
	lda     _grass+4,y
	sta     _tmp
;
; game_grass_cf_prepare();
;
	jsr     _game_grass_cf_prepare
;
; if (corr_power >= single_sprout) {
;
	ldx     #$00
	lda     _marker
	cmp     _tmp
	bcc     L11E4
;
; single_sprout = 1;
;
	lda     #$01
	sta     _tmp
;
; score += (corr_power - single_sprout);
;
	lda     _marker
	sec
	sbc     _tmp
	clc
	adc     _score
	sta     _score
	txa
	adc     _score+1
	sta     _score+1
;
; player.cut.count += (corr_power - single_sprout);
;
	lda     _marker
	sec
	sbc     _tmp
;
; } else {
;
	jmp     L11E8
;
; single_sprout -= corr_power;
;
L11E4:	lda     _marker
	eor     #$FF
	sec
	adc     _tmp
	sta     _tmp
;
; score += corr_power;
;
	lda     _marker
	clc
	adc     _score
	sta     _score
	txa
	adc     _score+1
	sta     _score+1
;
; player.cut.count += corr_power;
;
	lda     _marker
L11E8:	clc
	adc     _player+15
	sta     _player+15
;
; game_check_for_extra_point();
;
	jsr     _game_check_for_extra_point
;
; game_grass_cf_finalize();
;
	jsr     _game_grass_cf_finalize
;
; for (y = 0; y != player.cut.size; ++y) {
;
	inc     _y
	jmp     L11E1
;
; if (player.specials.active[SP_SLASH] != 0) {
;
L11E5:	lda     _player+26
	beq     L0B7B
;
; --player.specials.active[SP_SLASH];
;
	dec     _player+26
;
; if (player.specials.active[SP_SLASH] == 0) {
;
	bne     L0B7B
;
; player.cut.max_delay = player.cut.temp_store;
;
	lda     _player+14
	sta     _player+13
;
; } 
;
L0B7B:	rts

.endproc

; ---------------------------------------------------------------
; void __near__ game_check_for_extra_point (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_game_check_for_extra_point: near

.segment	"CODE"

;
; if (points < GAME_MAX_POINTS && player.cut.count > grass.col_for_point) {
;
	lda     _points
	cmp     #$63
	bcs     L11EB
	lda     _player+15
	sec
	sbc     _grass+3
	sta     tmp1
	lda     tmp1
	beq     L11EB
	bcs     L11EC
L11EB:	rts
;
; player.cut.count = 0;
;
L11EC:	lda     #$00
	sta     _player+15
;
; switch (game.difficulty) {
;
	lda     _game+6
;
; }
;
	beq     L11ED
	cmp     #$01
	beq     L11EE
	cmp     #$02
	beq     L11EF
	jmp     L11F0
;
; case GAME_DF_EASY :   grass.col_for_point += 1; break;
;
L11ED:	inc     _grass+3
	jmp     L11F0
;
; case GAME_DF_MEDIUM : grass.col_for_point += 3; break;
;
L11EE:	lda     #$03
	jmp     L11F2
;
; case GAME_DF_HARD :   grass.col_for_point += 5; break;
;
L11EF:	lda     #$05
L11F2:	clc
	adc     _grass+3
	sta     _grass+3
;
; ++points;
;
L11F0:	inc     _points
;
; game_draw_points();
;
	jmp     _game_draw_points

.endproc

; ---------------------------------------------------------------
; void __near__ game_draw_rain (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_game_draw_rain: near

.segment	"CODE"

;
; --rain_delay;
;
	dec     _rain_delay
;
; if (rain_delay == 0) {
;
	bne     L11F6
;
; rain_delay = DEFAULT_RAIN_DELAY;
;
	lda     #$06
	sta     _rain_delay
;
; for (index = 0x00; index != RAIN_COUNT; ++index) {
;
	lda     #$00
	sta     _index
L11F4:	lda     _index
	cmp     #$08
	beq     L11F6
;
; rain_drop_x[index] += rain_drop_y[index];
;
	lda     #<(_rain_drop_x)
	ldx     #>(_rain_drop_x)
	clc
	adc     _index
	bcc     L0A2F
	inx
L0A2F:	jsr     pushax
	sta     ptr1
	stx     ptr1+1
	ldy     #$00
	lda     (ptr1),y
	sta     ptr1
	ldy     _index
	lda     _rain_drop_y,y
	clc
	adc     ptr1
	ldy     #$00
	jsr     staspidx
;
; rain_drop_y[index] += 0x10;
;
	lda     #<(_rain_drop_y)
	ldx     #>(_rain_drop_y)
	clc
	adc     _index
	bcc     L0A35
	inx
L0A35:	sta     ptr1
	stx     ptr1+1
	ldy     #$00
	lda     (ptr1),y
	clc
	adc     #$10
	sta     (ptr1),y
;
; if (rain_drop_y[index] > 200) rain_drop_y[index] = 10;
;
	ldy     _index
	lda     _rain_drop_y,y
	cmp     #$C9
	bcc     L11F5
	ldy     _index
	lda     #$0A
	sta     _rain_drop_y,y
;
; for (index = 0x00; index != RAIN_COUNT; ++index) {
;
L11F5:	inc     _index
	jmp     L11F4
;
; for (index = 0x00; index != RAIN_COUNT; ++index) {
;
L11F6:	lda     #$00
	sta     _index
L11F7:	lda     _index
	cmp     #$08
	beq     L0A40
;
; oam_spr(rain_drop_x[index], rain_drop_y[index], 0x04, 0b00000010);
;
	jsr     decsp3
	ldy     _index
	lda     _rain_drop_x,y
	ldy     #$02
	sta     (sp),y
	ldy     _index
	lda     _rain_drop_y,y
	ldy     #$01
	sta     (sp),y
	lda     #$04
	dey
	sta     (sp),y
	lda     #$02
	jsr     _oam_spr
;
; for (index = 0x00; index != RAIN_COUNT; ++index) {
;
	inc     _index
	jmp     L11F7
;
; }
;
L0A40:	rts

.endproc

; ---------------------------------------------------------------
; void __near__ game_draw_sprites (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_game_draw_sprites: near

.segment	"CODE"

;
; oam_clear();
;
	jsr     _oam_clear
;
; if (player.cut.state == 0 || player.cut.state == CUT_ST_RECOVER) {
;
	lda     _player+11
	beq     L11F9
	cmp     #$05
	bne     L11FA
;
; if (player.direction == DIR_LEFT) oam_meta_spr(player.x, player.y, OTM_L);
;
L11F9:	lda     _player+8
	bne     L09B6
	jsr     decsp2
	lda     _player
	ldy     #$01
	sta     (sp),y
	lda     _player+1
	dey
	sta     (sp),y
	lda     #<(_OTM_L)
	ldx     #>(_OTM_L)
;
; else oam_meta_spr(player.x, player.y, OTM_R);
;
	jmp     L11F8
L09B6:	jsr     decsp2
	lda     _player
	ldy     #$01
	sta     (sp),y
	lda     _player+1
	dey
	sta     (sp),y
	lda     #<(_OTM_R)
	ldx     #>(_OTM_R)
;
; } else {
;
	jmp     L11F8
;
; --player.cut.delay;
;
L11FA:	dec     _player+12
;
; if (player.cut.delay == 0) {
;
	bne     L11FC
;
; player.cut.delay = player.cut.max_delay;
;
	lda     _player+13
	sta     _player+12
;
; if (player.cut.state == CUT_ST_C3) {
;
	lda     _player+11
	cmp     #$03
	bne     L11FB
;
; player.cut.state = CUT_ST_RECOVER;
;
	lda     #$05
	sta     _player+11
;
; game_grass_cut();
;
	jsr     _game_grass_cut
;
; } else {
;
	jmp     L11FC
;
; ++player.cut.state;
;
L11FB:	inc     _player+11
;
; if (player.cut.state == CUT_ST_C1 || player.cut.state == CUT_ST_RECOVER) oam_meta_spr(player.x - 8, player.y, OTM_RC_1);
;
L11FC:	lda     _player+11
	cmp     #$01
	beq     L11FE
	cmp     #$05
	bne     L11FF
L11FE:	jsr     decsp2
	lda     _player
	sec
	sbc     #$08
	ldy     #$01
	sta     (sp),y
	lda     _player+1
	dey
	sta     (sp),y
	lda     #<(_OTM_RC_1)
	ldx     #>(_OTM_RC_1)
	jsr     _oam_meta_spr
;
; if (player.cut.state == CUT_ST_C2) oam_meta_spr(player.x, player.y, OTM_RC_2);
;
L11FF:	lda     _player+11
	cmp     #$02
	bne     L1200
	jsr     decsp2
	lda     _player
	ldy     #$01
	sta     (sp),y
	lda     _player+1
	dey
	sta     (sp),y
	lda     #<(_OTM_RC_2)
	ldx     #>(_OTM_RC_2)
	jsr     _oam_meta_spr
;
; if (player.cut.state == CUT_ST_C3) oam_meta_spr(player.x + 8, player.y, OTM_RC_3);
;
L1200:	lda     _player+11
	cmp     #$03
	bne     L1201
	jsr     decsp2
	lda     _player
	clc
	adc     #$08
	ldy     #$01
	sta     (sp),y
	lda     _player+1
	dey
	sta     (sp),y
	lda     #<(_OTM_RC_3)
	ldx     #>(_OTM_RC_3)
L11F8:	jsr     _oam_meta_spr
;
; if (small_scythe.state != 0) {
;
L1201:	lda     _small_scythe+5
	beq     L09E3
;
; oam_meta_spr(small_scythe.x, small_scythe.y, SCYTHE_STATE[small_scythe.sprite]);
;
	jsr     decsp2
	lda     _small_scythe
	ldy     #$01
	sta     (sp),y
	lda     _small_scythe+1
	dey
	sta     (sp),y
	lda     _small_scythe+4
	jsr     pusha0
	lda     #$11
	jsr     tosmula0
	clc
	adc     #<(_SCYTHE_STATE)
	tay
	txa
	adc     #>(_SCYTHE_STATE)
	tax
	tya
	jmp     _oam_meta_spr
;
; }
;
L09E3:	rts

.endproc

; ---------------------------------------------------------------
; void __near__ game_draw_background (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_game_draw_background: near

.segment	"CODE"

;
; set_rand(get_frame_count());
;
	jsr     _get_frame_count
	ldx     #$00
	jsr     _set_rand
;
; fade_in();
;
	jsr     _fade_in
;
; ppu_off();
;
	jsr     _ppu_off
;
; clear_vram_buffer();
;
	jsr     _clear_vram_buffer
;
; clear_screen();
;
	jsr     _clear_screen
;
; set_bg_pallete(initial_pallete);
;
	lda     #<(_initial_pallete)
	ldx     #>(_initial_pallete)
	jsr     _set_bg_pallete
;
; for(x = 0x00; x != STARS_COUNT; ++x) {
;
	lda     #$00
	sta     _x
L1202:	lda     _x
	cmp     #$20
	beq     L1203
;
; vram_adr(NAMETABLE_A + rand8() * 3 - SCREEN_TILES_X * 5);
;
	jsr     _rand8
	jsr     mulax3
	pha
	txa
	clc
	adc     #$20
	tax
	pla
	sec
	sbc     #$A0
	bcs     L0915
	dex
L0915:	jsr     _vram_adr
;
; vram_put(0x2B);
;
	lda     #$2B
	jsr     _vram_put
;
; vram_adr(NAMETABLE_A + rand8() * 3 - SCREEN_TILES_X * 5);
;
	jsr     _rand8
	jsr     mulax3
	pha
	txa
	clc
	adc     #$20
	tax
	pla
	sec
	sbc     #$A0
	bcs     L091A
	dex
L091A:	jsr     _vram_adr
;
; vram_put(0x2D);
;
	lda     #$2D
	jsr     _vram_put
;
; for(x = 0x00; x != STARS_COUNT; ++x) {
;
	inc     _x
	jmp     L1202
;
; index = 0x10;
;
L1203:	lda     #$10
	sta     _index
;
; for(y = MOON_Y; y != MOON_Y + 0x04; ++y) {
;
	lda     #$03
	sta     _y
L1204:	lda     _y
	cmp     #$07
	beq     L0920
;
; vram_adr(NAMETABLE_A + y * SCREEN_TILES_X + MOON_X);
;
	ldx     #$00
	lda     _y
	jsr     shlax4
	stx     tmp1
	asl     a
	rol     tmp1
	pha
	lda     tmp1
	clc
	adc     #$20
	tax
	pla
	clc
	adc     #$18
	bcc     L0929
	inx
L0929:	jsr     _vram_adr
;
; for(x = 0x00; x != 0x04; ++x) {
;
	lda     #$00
	sta     _x
L1205:	lda     _x
	cmp     #$04
	beq     L1206
;
; vram_put(index);
;
	lda     _index
	jsr     _vram_put
;
; ++index;
;
	inc     _index
;
; for(x = 0x00; x != 0x04; ++x) {
;
	inc     _x
	jmp     L1205
;
; for(y = MOON_Y; y != MOON_Y + 0x04; ++y) {
;
L1206:	inc     _y
	jmp     L1204
;
; vram_adr(NAMETABLE_A + 0x20 * GRASS_BORDER);
;
L0920:	ldx     #$22
	lda     #$E0
	jsr     _vram_adr
;
; for(x = 0x00; x != GRASS_WIDTH; ++x) {
;
	lda     #$00
	sta     _x
L1207:	lda     _x
	cmp     #$20
	beq     L1208
;
; grass.height[x] = rand8() % 0x03 + 1;
;
	lda     #<(_grass+4)
	ldx     #>(_grass+4)
	clc
	adc     _x
	bcc     L0941
	inx
L0941:	jsr     pushax
	jsr     _rand8
	jsr     pushax
	lda     #$03
	jsr     tosumoda0
	clc
	adc     #$01
	ldy     #$00
	jsr     staspidx
;
; vram_put(grass.height[x]);
;
	ldy     _x
	lda     _grass+4,y
	jsr     _vram_put
;
; for(x = 0x00; x != GRASS_WIDTH; ++x) {
;
	inc     _x
	jmp     L1207
;
; for(x = 0x00; x != GRASS_WIDTH; ++x) vram_put(0x06 + (rand8() % 4));
;
L1208:	lda     #$00
	sta     _x
L1209:	lda     _x
	cmp     #$20
	beq     L120A
	jsr     _rand8
	and     #$03
	clc
	adc     #$06
	jsr     _vram_put
	inc     _x
	jmp     L1209
;
; for(x = 0x00; x != GRASS_WIDTH * 2; ++x) vram_put(0x0A + (rand8() % 4));
;
L120A:	lda     #$00
	sta     _x
L120B:	lda     _x
	cmp     #$40
	beq     L120C
	jsr     _rand8
	and     #$03
	clc
	adc     #$0A
	jsr     _vram_put
	inc     _x
	jmp     L120B
;
; for(x = 0x00; x != GRASS_WIDTH; ++x) {
;
L120C:	lda     #$00
	sta     _x
L120D:	lda     _x
	cmp     #$20
	beq     L0961
;
; state = state == 0x0E ? 0x0F : 0x0E;
;
	lda     _state
	cmp     #$0E
	bne     L120E
	lda     #$0F
	jmp     L120F
L120E:	lda     #$0E
L120F:	sta     _state
;
; vram_put(state);
;
	jsr     _vram_put
;
; for(x = 0x00; x != GRASS_WIDTH; ++x) {
;
	inc     _x
	jmp     L120D
;
; vram_adr(NAMETABLE_A + SCREEN_TILES_X * 0x1C);
;
L0961:	ldx     #$23
	lda     #$80
	jsr     _vram_adr
;
; for (x = 0x00; x != 0x20; ++x) 
;
	lda     #$00
	sta     _x
L1210:	lda     _x
	cmp     #$20
	beq     L0973
;
; vram_put(STATUS_BAR[x] == 0 ? CHR_BG_BLANK : STATUS_BAR[x]);
;
	ldy     _x
	lda     _STATUS_BAR,y
	bne     L097E
	lda     #$7F
	jmp     L1211
L097E:	ldy     _x
	lda     _STATUS_BAR,y
L1211:	jsr     _vram_put
;
; for (x = 0x00; x != 0x20; ++x) 
;
	inc     _x
	jmp     L1210
;
; vram_adr(NAMETABLE_A + SCREEN_TILES_X * 0x1C + 0x03);
;
L0973:	ldx     #$23
	lda     #$83
	jsr     _vram_adr
;
; vram_put(CHR_ZERO + game.lives);
;
	lda     _game+7
	clc
	adc     #$30
	jsr     _vram_put
;
; ppu_on_all();
;
	jsr     _ppu_on_all
;
; fade_out();
;
	jmp     _fade_out

.endproc

; ---------------------------------------------------------------
; void __near__ game_draw_time (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_game_draw_time: near

.segment	"CODE"

;
; one_vram_buffer(CHR_ZERO + game.play_time / 10, NTADR_A(0x15, Y_EDGE));
;
	lda     _game+4
	jsr     pusha0
	lda     #$0A
	jsr     tosudiva0
	clc
	adc     #$30
	jsr     pusha
	ldx     #$23
	lda     #$95
	jsr     _one_vram_buffer
;
; one_vram_buffer(CHR_ZERO + game.play_time % 10, NTADR_A(0x16, Y_EDGE));
;
	lda     _game+4
	jsr     pusha0
	lda     #$0A
	jsr     tosumoda0
	clc
	adc     #$30
	jsr     pusha
	ldx     #$23
	lda     #$96
	jmp     _one_vram_buffer

.endproc

; ---------------------------------------------------------------
; void __near__ game_draw_points (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_game_draw_points: near

.segment	"CODE"

;
; one_vram_buffer(CHR_ZERO + points / 10, NTADR_A(0x0B, Y_EDGE));
;
	lda     _points
	jsr     pusha0
	lda     #$0A
	jsr     tosudiva0
	clc
	adc     #$30
	jsr     pusha
	ldx     #$23
	lda     #$8B
	jsr     _one_vram_buffer
;
; one_vram_buffer(CHR_ZERO + points % 10, NTADR_A(0x0C, Y_EDGE));
;
	lda     _points
	jsr     pusha0
	lda     #$0A
	jsr     tosumoda0
	clc
	adc     #$30
	jsr     pusha
	ldx     #$23
	lda     #$8C
	jmp     _one_vram_buffer

.endproc

; ---------------------------------------------------------------
; void __near__ game_draw_effects (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_game_draw_effects: near

.segment	"CODE"

;
; if (game.effects.lightning != 0 && game.effects.lightning_enabled) {
;
	lda     _game+8
	beq     L1216
	lda     _game+9
	beq     L1216
;
; ++game.effects.lightning;
;
	inc     _game+8
;
; switch (game.effects.lightning) {
;
	lda     _game+8
;
; }
;
	cmp     #$02
	beq     L09F4
	cmp     #$08
	beq     L09F9
	cmp     #$10
	beq     L09FE
	cmp     #$18
	beq     L0A03
	cmp     #$20
	beq     L0A08
	cmp     #$3C
	beq     L1215
	jmp     L1216
;
; case 2: sfx_play(SND_GAME_LIGHTNING, 0);
;
L09F4:	lda     #$09
	jsr     pusha
	lda     #$00
	jsr     _sfx_play
;
; break;
;
	jmp     L1216
;
; case 8: pal_col(0, 0x30);
;
L09F9:	lda     #$00
	jsr     pusha
	lda     #$30
	jsr     _pal_col
;
; break;
;
	jmp     L1216
;
; case 16: pal_col(0, 0x0F);
;
L09FE:	lda     #$00
	jsr     pusha
	lda     #$0F
	jsr     _pal_col
;
; break;
;
	jmp     L1216
;
; case 24: pal_col(0, 0x30);
;
L0A03:	lda     #$00
	jsr     pusha
	lda     #$30
	jsr     _pal_col
;
; break;
;
	jmp     L1216
;
; case 32: pal_col(0, GAME_BG_COLOR);
;
L0A08:	lda     #$00
	jsr     pusha
	lda     #$0C
	jsr     _pal_col
;
; break;
;
	jmp     L1216
;
; case 60: game.effects.lightning = 0;
;
L1215:	lda     #$00
	sta     _game+8
;
; if (game.effects.wind != 0) {
;
L1216:	lda     _game+10
	beq     L0A15
;
; ++game.effects.wind;
;
	inc     _game+10
;
; switch (game.effects.wind) {
;
	lda     _game+10
;
; }
;
	cmp     #$02
	beq     L0A17
	cmp     #$5A
	beq     L1217
	rts
;
; case 2 : sfx_play(SND_GAME_WIND, 0);
;
L0A17:	lda     #$0A
	jsr     pusha
	lda     #$00
	jmp     _sfx_play
;
; case 90: game.effects.wind = 0;
;
L1217:	lda     #$00
	sta     _game+10
;
; }
;
L0A15:	rts

.endproc

; ---------------------------------------------------------------
; void __near__ game_movement_and_actions (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_game_movement_and_actions: near

.segment	"CODE"

;
; if (player.specials.active[SP_DASH] != 0) {
;
	lda     _player+25
	jeq     L1221
;
; if (ability_max) x = SP_DASH_SPEED_MAX;
;
	lda     _player+22
	cmp     #$05
	bne     L121C
	lda     #$04
;
; else if (ability_ex) x = SP_DASH_SPEED_MED;
;
	jmp     L121A
L121C:	lda     _player+22
	cmp     #$03
	bcc     L121D
	lda     #$03
;
; else x = SP_DASH_SPEED_LOW;
;
	jmp     L121A
L121D:	lda     #$02
L121A:	sta     _x
;
; if (player.specials.state[SP_DASH] == SP_DASH_LEFT) {
;
	lda     _player+28
	cmp     #$01
	bne     L121E
;
; if (player.x < x + 3) player.x = 3; else player.x -= x;
;
	lda     _player
	jsr     pusha0
	lda     _x
	clc
	adc     #$03
	bcc     L0C05
	ldx     #$01
L0C05:	jsr     tosicmp
	bcs     L0C03
	lda     #$03
	jmp     L121B
L0C03:	lda     _x
	eor     #$FF
	sec
	adc     _player
;
; } else {
;
	jmp     L121B
;
; player.x += x;
;
L121E:	lda     _x
	clc
	adc     _player
	sta     _player
;
; if (player.x > RIGHT_EDGE - PLAYER_WIDTH) player.x = RIGHT_EDGE - PLAYER_WIDTH;
;
	cmp     #$DB
	bcc     L121F
	lda     #$DA
L121B:	sta     _player
;
; --player.specials.active[SP_DASH];
;
L121F:	dec     _player+25
;
; player.y += player.specials.active[SP_DASH] > SP_DASH_JUMP ? -1 : 1;
;
	lda     _player+25
	cmp     #$06
	bcc     L1220
	lda     #$FF
	jmp     L0C19
L1220:	lda     #$01
L0C19:	clc
	adc     _player+1
	sta     _player+1
;
; if (player.specials.active[SP_DASH] == 0) player.specials.state[SP_DASH] = SP_IDLE;
;
	lda     _player+25
	jne     L122F
	sta     _player+28
;
; } else {
;
	jmp     L122F
;
; if (pad1 & PAD_LEFT || pad1 & PAD_RIGHT) {
;
L1221:	lda     _pad1
	and     #$02
	bne     L1222
	lda     _pad1
	and     #$01
	jeq     L122F
;
; if ((ability_max && player.abilities.list[ABILITY_MOVE_SPEED] == ABILITY_MAX_LEVEL) || player.cut.state == CUT_ST_IDLE) {
;
L1222:	lda     _player+22
	cmp     #$05
	bne     L1225
	lda     _player+20
	cmp     #$05
	beq     L1228
L1225:	lda     _player+11
	bne     L122F
;
; if (player.move_delay == 0) {
;
L1228:	lda     _player+4
	bne     L122E
;
; if (player.move_max_delay != 0) player.move_delay = player.move_max_delay;
;
	lda     _player+5
	beq     L1229
	sta     _player+4
;
; x = 1;
;
L1229:	lda     #$01
	sta     _x
;
; if (player.cut.state == CUT_ST_IDLE) {
;
	lda     _player+11
	bne     L122A
;
; if (player.move_max_increase != 0) {
;
	lda     _player+7
	beq     L122A
;
; --player.move_increase;
;
	dec     _player+6
;
; if (player.move_increase == 0) {
;
	bne     L122A
;
; player.move_increase = player.move_max_increase;
;
	lda     _player+7
	sta     _player+6
;
; ++x;
;
	inc     _x
;
; if (pad1 & PAD_LEFT) {
;
L122A:	lda     _pad1
	and     #$02
	beq     L122C
;
; player.x = (player.x - 3) < x ? 3 : player.x - x;
;
	ldx     #$00
	lda     _player
	sec
	sbc     #$03
	bcs     L0C44
	dex
L0C44:	cmp     _x
	txa
	sbc     #$00
	bcs     L0C45
	lda     #$03
	jmp     L122B
L0C45:	lda     _player
	sec
	sbc     _x
L122B:	sta     _player
;
; player.direction = DIR_LEFT;
;
	lda     #$00
	sta     _player+8
;
; } else {
;
	jmp     L122F
;
; player.x += x;
;
L122C:	lda     _x
	clc
	adc     _player
	sta     _player
;
; if (player.x > RIGHT_EDGE - PLAYER_WIDTH) player.x = RIGHT_EDGE - PLAYER_WIDTH;
;
	cmp     #$DB
	bcc     L122D
	lda     #$DA
	sta     _player
;
; player.direction = DIR_RIGHT;
;
L122D:	lda     #$01
	sta     _player+8
;
; } else {
;
	jmp     L122F
;
; --player.move_delay;
;
L122E:	dec     _player+4
;
; if (game.state == GAME_ST_LEVEL_PLAYING ) {
;
L122F:	lda     _game+3
	cmp     #$01
	bne     L0C6A
;
; if (pad1 & PAD_B || player.specials.active[SP_SLASH] != 0) {
;
	lda     _pad1
	and     #$40
	bne     L1230
	lda     _player+26
	beq     L123A
;
; if (player.cut.state == CUT_ST_IDLE || (player.specials.active[SP_SLASH] != 0 && player.cut.state == CUT_ST_RECOVER)) {
;
L1230:	lda     _player+11
	beq     L1236
	lda     _player+26
	beq     L0C6A
	lda     _player+11
	cmp     #$05
	jne     _game_check_specials_keys
;
; player.cut.state = CUT_ST_C1;
;
L1236:	lda     #$01
	sta     _player+11
;
; if (player.direction == DIR_LEFT) player.direction = DIR_RIGHT;
;
	lda     _player+8
	bne     L0C6A
	lda     #$01
	sta     _player+8
;
; } else {
;
	jmp     _game_check_specials_keys
;
; if (player.cut.state == CUT_ST_RECOVER) player.cut.state = CUT_ST_IDLE;
;
L123A:	lda     _player+11
	cmp     #$05
	bne     L0C6A
	lda     #$00
	sta     _player+11
;
; game_check_specials_keys();
;
L0C6A:	jmp     _game_check_specials_keys

.endproc

; ---------------------------------------------------------------
; void __near__ game_check_specials_keys (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_game_check_specials_keys: near

.segment	"CODE"

;
; if (player.specials.delayed > 0) {
;
	lda     _player+23
	beq     L123D
;
; --player.specials.delayed;
;
	dec     _player+23
;
; if (player.specials.delayed == 0) {
;
	lda     _player+23
	bne     L123D
;
; player.specials.state[SP_DASH] = SP_IDLE;
;
	sta     _player+28
;
; player.specials.state[SP_SLASH] = SP_IDLE;
;
	sta     _player+29
;
; if (player.abilities.elevel >= SP_SSCYTHE_ALEVEL) {
;
L123D:	lda     _player+22
	beq     L1245
;
; if (pad1 & PAD_A && pad1 & PAD_UP && small_scythe.state == 0) {
;
	lda     _pad1
	and     #$80
	beq     L1245
	lda     _pad1
	and     #$08
	beq     L1245
	lda     _small_scythe+5
	bne     L1245
;
; tmp = ability_max ? SP_SSCYTHE_SPEED_EX : SP_SSCYTHE_SPEED;
;
	lda     _player+22
	cmp     #$05
	beq     L1242
	lda     #$03
L1242:	sta     _tmp
;
; small_scythe.x = player.x + 0x0A;
;
	lda     _player
	clc
	adc     #$0A
	sta     _small_scythe
;
; small_scythe.y = player.y;
;
	lda     _player+1
	sta     _small_scythe+1
;
; small_scythe.y_speed = tmp;
;
	lda     _tmp
	sta     _small_scythe+7
;
; if (pad1 & PAD_LEFT) small_scythe.x_speed = -tmp;
;
	lda     _pad1
	and     #$02
	beq     L1243
	lda     _tmp
	eor     #$FF
	clc
	adc     #$01
;
; else if (pad1 & PAD_RIGHT) small_scythe.x_speed = tmp;
;
	jmp     L123B
L1243:	lda     _pad1
	and     #$01
	beq     L123B
	lda     _tmp
;
; else small_scythe.x_speed = 0;
;
L123B:	sta     _small_scythe+6
;
; small_scythe.state = small_scythe.sprite = 1;
;
	lda     #$01
	sta     _small_scythe+4
	sta     _small_scythe+5
;
; if (player.abilities.elevel >= SP_DASH_ALEVEL && player.specials.active[SP_DASH] == 0) {
;
L1245:	lda     _player+22
	cmp     #$02
	bcc     L124D
	lda     _player+25
	bne     L124D
;
; switch (player.specials.state[SP_DASH]) {
;
	lda     _player+28
;
; }
;
	beq     L1249
	cmp     #$01
	beq     L124B
	cmp     #$02
	beq     L124C
	jmp     L124D
;
; if (pad1_new & PAD_RIGHT) {
;
L1249:	lda     _pad1_new
	and     #$01
	beq     L124A
;
; player.specials.state[SP_DASH] = SP_DASH_RIGHT;
;
	lda     #$02
	sta     _player+28
;
; player.specials.delayed = SP_MAX_DELAY;
;
	lda     #$10
	sta     _player+23
;
; if (pad1_new & PAD_LEFT) {
;
L124A:	lda     _pad1_new
	and     #$02
	beq     L124D
;
; player.specials.state[SP_DASH] = SP_DASH_LEFT;
;
	lda     #$01
	sta     _player+28
;
; player.specials.delayed = SP_MAX_DELAY;
;
	lda     #$10
;
; break;
;
	jmp     L123C
;
; if (pad1_new & PAD_LEFT) {
;
L124B:	lda     _pad1_new
	and     #$02
;
; break;
;
	jmp     L1259
;
; if (pad1_new & PAD_RIGHT) {
;
L124C:	lda     _pad1_new
	and     #$01
L1259:	beq     L124D
;
; player.specials.active[SP_DASH] = SP_DASH_LENGTH;
;
	lda     #$0C
	sta     _player+25
;
; player.specials.delayed = 0;
;
	lda     #$00
L123C:	sta     _player+23
;
; if (pad1_new & PAD_DOWN) {
;
L124D:	lda     _pad1_new
	and     #$04
	beq     L0CE9
;
; if (player.abilities.elevel >= SP_SLASH_ALEVEL && player.specials.active[SP_SLASH] == 0) {
;
	lda     _player+22
	cmp     #$04
	bcc     L124F
	lda     _player+26
	beq     L1250
L124F:	rts
;
; ++player.specials.state[SP_SLASH];
;
L1250:	inc     _player+29
;
; if (player.specials.state[SP_SLASH] == SP_SLASH_TRIPLE_DOWN) {
;
	lda     _player+29
	cmp     #$03
	bne     L1255
;
; player.specials.active[SP_SLASH] = ability_max ? SP_SLASH_COUNT_EX : SP_SLASH_COUNT;
;
	lda     _player+22
	cmp     #$05
	beq     L1252
	lda     #$03
L1252:	sta     _player+26
;
; player.specials.state[SP_SLASH] = SP_IDLE;
;
	lda     #$00
	sta     _player+29
;
; player.cut.temp_store = player.cut.max_delay;
;
	lda     _player+13
	sta     _player+14
;
; player.cut.max_delay = ability_max ? SP_SLASH_FAST_DELAY_EX : SP_SLASH_FAST_DELAY;
;
	lda     _player+22
	cmp     #$05
	bne     L1253
	lda     #$01
	jmp     L1254
L1253:	lda     #$03
L1254:	sta     _player+13
;
; } else {
;
	rts
;
; player.specials.delayed = SP_MAX_DELAY;
;
L1255:	lda     #$10
	sta     _player+23
;
; }
;
L0CE9:	rts

.endproc

; ---------------------------------------------------------------
; void __near__ game_small_scythe_processing (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_game_small_scythe_processing: near

.segment	"CODE"

;
; if (small_scythe.state != 0) {
;
	lda     _small_scythe+5
	beq     L0CFE
;
; x = small_scythe.x + small_scythe.x_speed;
;
	lda     _small_scythe
	clc
	adc     _small_scythe+6
	sta     _x
;
; y = small_scythe.y - small_scythe.y_speed;
;
	lda     _small_scythe+1
	sec
	sbc     _small_scythe+7
	sta     _y
;
; if (x > RIGHT_EDGE || y > BOTTOM_EDGE) {
;
	lda     _x
	cmp     #$FB
	bcs     L125B
	lda     _y
	cmp     #$E7
	bcc     L125C
;
; small_scythe.state = 0;
;
L125B:	lda     #$00
	sta     _small_scythe+5
;
; } else {
;
	rts
;
; ++small_scythe.state;
;
L125C:	inc     _small_scythe+5
;
; small_scythe.x = x;
;
	lda     _x
	sta     _small_scythe
;
; small_scythe.y = y;
;
	lda     _y
	sta     _small_scythe+1
;
; if (small_scythe.state == CHR_SC_ANIM_DELAY) {
;
	lda     _small_scythe+5
	cmp     #$04
	bne     L0CFE
;
; small_scythe.state = 1;
;
	lda     #$01
	sta     _small_scythe+5
;
; small_scythe.sprite = small_scythe.sprite == 7 ? 0 : small_scythe.sprite + 1;
;
	lda     _small_scythe+4
	cmp     #$07
	bne     L125D
	lda     #$00
	jmp     L125E
L125D:	lda     _small_scythe+4
	clc
	adc     #$01
L125E:	sta     _small_scythe+4
;
; }
;
L0CFE:	rts

.endproc

; ---------------------------------------------------------------
; void __near__ game_create_enemy (unsigned char)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_game_create_enemy: near

.segment	"CODE"

;
; void game_create_enemy(char bird_num) {
;
	jsr     pusha
;
; if (bird_state[bird_num] == 0) {
;
	ldy     #$00
	lda     (sp),y
	tay
	lda     _bird_state,y
	beq     L1262
;
; }
;
	jmp     incsp1
;
; bird_state[bird_num] = 1;
;
L1262:	tay
	lda     (sp),y
	tay
	lda     #$01
	sta     _bird_state,y
;
; if (rand8() % 2 == 0) {
;
	jsr     _rand8
	and     #$01
	bne     L0D12
;
; bird_x[bird_num] = 2;
;
	tay
	lda     (sp),y
	tay
	lda     #$02
	sta     _bird_x,y
;
; bird_x_speed[bird_num] = 1;
;
	ldy     #$00
	lda     (sp),y
	tay
	lda     #$01
;
; } else {
;
	jmp     L125F
;
; bird_x[bird_num] = 235;
;
L0D12:	ldy     #$00
	lda     (sp),y
	tay
	lda     #$EB
	sta     _bird_x,y
;
; bird_x_speed[bird_num] = -1;
;
	ldy     #$00
	lda     (sp),y
	tay
	lda     #$FF
L125F:	sta     _bird_x_speed,y
;
; bird_tag[bird_num] = 0;
;
	ldy     #$00
	lda     (sp),y
	tay
	lda     #$00
	sta     _bird_tag,y
;
; bird_y[bird_num] = 30 + (rand8() >> 3);
;
	lda     #<(_bird_y)
	ldx     #>(_bird_y)
	ldy     #$00
	clc
	adc     (sp),y
	bcc     L0D2C
	inx
L0D2C:	jsr     pushax
	jsr     _rand8
	jsr     asrax3
	clc
	adc     #$1E
	ldy     #$00
	jsr     staspidx
;
; bird_pallete[bird_num] = rand8() % 3 + 1;
;
	lda     #<(_bird_pallete)
	ldx     #>(_bird_pallete)
	ldy     #$00
	clc
	adc     (sp),y
	bcc     L0D32
	inx
L0D32:	jsr     pushax
	jsr     _rand8
	jsr     pushax
	lda     #$03
	jsr     tosumoda0
	clc
	adc     #$01
	ldy     #$00
	jsr     staspidx
;
; bird_health[bird_num] = bird_pallete[bird_num] == 3 ? 4 : bird_pallete[bird_num];
;
	lda     #<(_bird_health)
	ldx     #>(_bird_health)
	ldy     #$00
	clc
	adc     (sp),y
	bcc     L0D37
	inx
L0D37:	sta     ptr1
	stx     ptr1+1
	lda     (sp),y
	tay
	lda     _bird_pallete,y
	cmp     #$03
	bne     L0D3B
	lda     #$04
	jmp     L1260
L0D3B:	ldy     #$00
	lda     (sp),y
	tay
	lda     _bird_pallete,y
L1260:	ldy     #$00
	sta     (ptr1),y
;
; if (game.level >= 5) ++bird_health[bird_num];
;
	lda     _game
	cmp     #$05
	bcc     L1261
	lda     #<(_bird_health)
	ldx     #>(_bird_health)
	clc
	adc     (sp),y
	bcc     L0D45
	inx
L0D45:	sta     ptr1
	stx     ptr1+1
	lda     #$01
	clc
	adc     (ptr1),y
	sta     (ptr1),y
;
; if (game.level >= 10) ++bird_health[bird_num];
;
L1261:	lda     _game
	cmp     #$0A
	bcc     L0D46
	lda     #<(_bird_health)
	ldx     #>(_bird_health)
	clc
	adc     (sp),y
	bcc     L0D4A
	inx
L0D4A:	sta     ptr1
	stx     ptr1+1
	lda     #$01
	clc
	adc     (ptr1),y
	sta     (ptr1),y
;
; bird_speed_delay[bird_num] = bird_health[bird_num];
;
L0D46:	lda     #<(_bird_speed_delay)
	ldx     #>(_bird_speed_delay)
	clc
	adc     (sp),y
	bcc     L0D4D
	inx
L0D4D:	jsr     pushax
	ldy     #$02
	lda     (sp),y
	tay
	lda     _bird_health,y
	ldy     #$00
	jsr     staspidx
;
; }
;
	jmp     incsp1

.endproc

; ---------------------------------------------------------------
; void __near__ game_enemy_processing (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_game_enemy_processing: near

.segment	"CODE"

;
; ++bird_anim;
;
	inc     _bird_anim
;
; if (bird_anim == BIRDS_ANIM_DELAY) {
;
	lda     _bird_anim
	cmp     #$05
	bne     L126B
;
; bird_anim = 1;
;
	lda     #$01
	sta     _bird_anim
;
; bird_sprite += bird_x_sprite;
;
	lda     _bird_x_sprite
	clc
	adc     _bird_sprite
	sta     _bird_sprite
;
; if (bird_sprite == BIRDS_ANIM_LENGTH) bird_x_sprite = -1;
;
	cmp     #$04
	bne     L126A
	lda     #$FF
	sta     _bird_x_sprite
;
; if (bird_sprite == 0) bird_x_sprite = 1;
;
L126A:	lda     _bird_sprite
	bne     L126B
	lda     #$01
	sta     _bird_x_sprite
;
; for (x = 0; x < BIRDS_COUNT; ++x) {
;
L126B:	lda     #$00
	sta     _x
L126C:	lda     _x
	cmp     #$04
	bcc     L127B
;
; }
;
	rts
;
; if (bird_state[x] != 0) {
;
L127B:	ldy     _x
	lda     _bird_state,y
	jeq     L127A
;
; --bird_speed_delay[x];
;
	lda     #<(_bird_speed_delay)
	ldx     #>(_bird_speed_delay)
	clc
	adc     _x
	bcc     L0D6F
	inx
L0D6F:	sta     ptr1
	stx     ptr1+1
	ldy     #$00
	lda     (ptr1),y
	sec
	sbc     #$01
	sta     (ptr1),y
;
; if (bird_speed_delay[x] == 0) {
;
	ldy     _x
	lda     _bird_speed_delay,y
	bne     L0D70
;
; bird_x[x] += bird_x_speed[x];
;
	lda     #<(_bird_x)
	ldx     #>(_bird_x)
	clc
	adc     _x
	bcc     L0D76
	inx
L0D76:	jsr     pushax
	sta     ptr1
	stx     ptr1+1
	ldy     #$00
	lda     (ptr1),y
	sta     ptr1
	ldy     _x
	lda     _bird_x_speed,y
	clc
	adc     ptr1
	ldy     #$00
	jsr     staspidx
;
; bird_speed_delay[x] = bird_health[x];
;
	lda     #<(_bird_speed_delay)
	ldx     #>(_bird_speed_delay)
	clc
	adc     _x
	bcc     L0D7C
	inx
L0D7C:	sta     ptr1
	stx     ptr1+1
	ldy     _x
	lda     _bird_health,y
	ldy     #$00
	sta     (ptr1),y
;
; if (bird_x[x] <= 1 || bird_x[x] > 235) bird_state[x] = 0;
;
L0D70:	ldy     _x
	lda     _bird_x,y
	cmp     #$02
	bcc     L126D
	ldy     _x
	lda     _bird_x,y
	cmp     #$EC
	bcc     L126E
L126D:	ldy     _x
	lda     #$00
	sta     _bird_state,y
;
; if (small_scythe.state != 0 && bird_tag[x] == 0) {
;
L126E:	lda     _small_scythe+5
	jeq     L1278
	ldy     _x
	lda     _bird_tag,y
	jne     L1277
;
; if (small_scythe.x <= bird_x[x] + BIRDS_WIDTH && 
;
	lda     _small_scythe
	jsr     pusha0
	ldy     _x
	lda     _bird_x,y
	clc
	adc     #$10
	bcc     L0D95
	ldx     #$01
L0D95:	jsr     tosicmp
	beq     L1268
	jcs     L1277
;
; small_scythe.x + SP_SSCYTHE_SIZE >= bird_x[x] &&
;
L1268:	ldx     #$00
	lda     _small_scythe
	clc
	adc     #$10
	bcc     L0D97
	inx
L0D97:	jsr     pushax
	ldy     _x
	lda     _bird_x,y
	jsr     tosicmp0
	jcc     L1277
;
; small_scythe.y <= bird_y[x] + BIRDS_HEIGHT && 
;
	lda     _small_scythe+1
	jsr     pusha0
	ldy     _x
	lda     _bird_y,y
	clc
	adc     #$08
	bcc     L0D9C
	ldx     #$01
L0D9C:	jsr     tosicmp
	beq     L1269
	jcs     L1277
;
; small_scythe.y + SP_SSCYTHE_SIZE >= bird_y[x]) {
;
L1269:	ldx     #$00
	lda     _small_scythe+1
	clc
	adc     #$10
	bcc     L0D9D
	inx
L0D9D:	jsr     pushax
	ldy     _x
	lda     _bird_y,y
	jsr     tosicmp0
	jcc     L1277
;
; tmp = ability_ex ? SP_SSCYTHE_DMG_EX : SP_SSCYTHE_DMG;
;
	lda     _player+22
	cmp     #$03
	bcc     L1272
	lda     #$02
	jmp     L1273
L1272:	lda     #$01
L1273:	sta     _tmp
;
; small_scythe.state = 0;
;
	lda     #$00
	sta     _small_scythe+5
;
; if (bird_health[x] <= tmp) {
;
	ldy     _x
	lda     _bird_health,y
	sec
	sbc     _tmp
	sta     tmp1
	lda     tmp1
	beq     L1266
	bcs     L0DAA
;
; bird_tag[x] = BIRDS_TAG_DIE;
;
L1266:	ldy     _x
	lda     #$19
	sta     _bird_tag,y
;
; sfx_play(SND_BIRD_DEATH, 1);
;
	lda     #$0B
	jsr     pusha
	lda     #$01
	jsr     _sfx_play
;
; score += bird_pallete[x] * 10;
;
	ldy     _x
	ldx     #$00
	lda     _bird_pallete,y
	jsr     mulax10
	clc
	adc     _score
	sta     _score
	txa
	adc     _score+1
	sta     _score+1
;
; if (points < GAME_MAX_POINTS) {
;
	lda     _points
	cmp     #$63
	bcs     L1277
;
; switch (bird_pallete[x]) {
;
	ldy     _x
	lda     _bird_pallete,y
;
; }
;
	cmp     #$01
	beq     L1274
	cmp     #$02
	beq     L1275
	cmp     #$03
	beq     L1276
	jmp     L1277
;
; case 1: player.cut.count += grass.col_for_point >> 1; 
;
L1274:	lda     _grass+3
	lsr     a
	clc
	adc     _player+15
	sta     _player+15
;
; game_check_for_extra_point();
;
	jsr     _game_check_for_extra_point
;
; break;
;
	jmp     L1277
;
; case 2: ++points; 
;
L1275:	inc     _points
;
; game_draw_points();
;
	jsr     _game_draw_points
;
; break;
;
	jmp     L1277
;
; case 3: points += 2; 
;
L1276:	lda     #$02
	clc
	adc     _points
	sta     _points
;
; game_draw_points();
;
	jsr     _game_draw_points
;
; break;
;
	jmp     L1277
;
; bird_health[x] -= tmp;
;
L0DAA:	lda     #<(_bird_health)
	ldx     #>(_bird_health)
	clc
	adc     _x
	bcc     L0DD1
	inx
L0DD1:	jsr     pushax
	sta     ptr1
	stx     ptr1+1
	ldy     #$00
	lda     (ptr1),y
	sec
	sbc     _tmp
	jsr     staspidx
;
; bird_tag[x] = BIRDS_TAG_HIT;
;
	ldy     _x
	lda     #$05
	sta     _bird_tag,y
;
; tmp = 0;
;
L1277:	lda     #$00
L1278:	sta     _tmp
;
; if (bird_tag[x] > 0) --bird_tag[x];
;
	ldy     _x
	lda     _bird_tag,y
	beq     L0DD9
	lda     #<(_bird_tag)
	ldx     #>(_bird_tag)
	clc
	adc     _x
	bcc     L0DDF
	inx
L0DDF:	sta     ptr1
	stx     ptr1+1
	ldy     #$00
	lda     (ptr1),y
	sec
	sbc     #$01
	sta     (ptr1),y
;
; if (bird_tag[x] > BIRDS_TAG_HIT) {
;
L0DD9:	ldy     _x
	lda     _bird_tag,y
	cmp     #$06
	bcc     L0DE0
;
; tmp = BIRDS_TAG_DIE - bird_tag[x];
;
	lda     #$19
	jsr     pusha0
	ldy     _x
	lda     _bird_tag,y
	jsr     tossuba0
	sta     _tmp
;
; if (bird_tag[x] == BIRDS_TAG_HIT + 1) {
;
	ldy     _x
	lda     _bird_tag,y
	cmp     #$06
	bne     L0DE0
;
; bird_state[x] = 0;
;
	ldy     _x
	lda     #$00
	sta     _bird_state,y
;
; if (bird_tag[x] == 0 || bird_tag[x] > BIRDS_TAG_HIT)
;
L0DE0:	ldy     _x
	lda     _bird_tag,y
	beq     L1279
	ldy     _x
	lda     _bird_tag,y
	cmp     #$06
	jcc     L127A
;
; if (bird_x_speed[x] == 1) {
;
L1279:	ldy     _x
	lda     _bird_x_speed,y
	cmp     #$01
	bne     L0DF7
;
; oam_spr(bird_x[x] + 0x08, bird_y[x] - tmp, 0x29, bird_pallete[x] - 1 | OAM_FLIP_H);
;
	jsr     decsp3
	ldy     _x
	lda     _bird_x,y
	clc
	adc     #$08
	ldy     #$02
	sta     (sp),y
	ldy     _x
	lda     _bird_y,y
	sec
	sbc     _tmp
	ldy     #$01
	sta     (sp),y
	lda     #$29
	dey
	sta     (sp),y
	ldy     _x
	lda     _bird_pallete,y
	sec
	sbc     #$01
	ora     #$40
	jsr     _oam_spr
;
; oam_spr(bird_x[x], bird_y[x] + tmp, 0x2A + bird_sprite, bird_pallete[x] - 1 | OAM_FLIP_H );
;
	jsr     decsp3
	ldy     _x
	lda     _bird_x,y
	ldy     #$02
	sta     (sp),y
	ldy     _x
	lda     _bird_y,y
	clc
	adc     _tmp
	ldy     #$01
	sta     (sp),y
	lda     _bird_sprite
	clc
	adc     #$2A
	dey
	sta     (sp),y
	ldy     _x
	lda     _bird_pallete,y
	sec
	sbc     #$01
	ora     #$40
;
; } else {
;
	jmp     L1267
;
; oam_spr(bird_x[x], bird_y[x] - tmp, 0x29, bird_pallete[x] - 1);
;
L0DF7:	jsr     decsp3
	ldy     _x
	lda     _bird_x,y
	ldy     #$02
	sta     (sp),y
	ldy     _x
	lda     _bird_y,y
	sec
	sbc     _tmp
	ldy     #$01
	sta     (sp),y
	lda     #$29
	dey
	sta     (sp),y
	ldy     _x
	lda     _bird_pallete,y
	sec
	sbc     #$01
	jsr     _oam_spr
;
; oam_spr(bird_x[x] + 0x08, bird_y[x] + tmp, 0x2A + bird_sprite, bird_pallete[x] - 1);
;
	jsr     decsp3
	ldy     _x
	lda     _bird_x,y
	clc
	adc     #$08
	ldy     #$02
	sta     (sp),y
	ldy     _x
	lda     _bird_y,y
	clc
	adc     _tmp
	ldy     #$01
	sta     (sp),y
	lda     _bird_sprite
	clc
	adc     #$2A
	dey
	sta     (sp),y
	ldy     _x
	lda     _bird_pallete,y
	sec
	sbc     #$01
L1267:	jsr     _oam_spr
;
; for (x = 0; x < BIRDS_COUNT; ++x) {
;
L127A:	inc     _x
	jmp     L126C

.endproc

; ---------------------------------------------------------------
; void __near__ upgrade_draw_sprites (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_upgrade_draw_sprites: near

.segment	"CODE"

;
; oam_clear();
;
	jsr     _oam_clear
;
; oam_meta_spr(0x1E, 0x1D + player.abilities.selection * 0x18, CURSOR);
;
	jsr     decsp2
	lda     #$1E
	ldy     #$01
	sta     (sp),y
	lda     _player+16
	jsr     pusha0
	lda     #$18
	jsr     tosumula0
	clc
	adc     #$1D
	ldy     #$00
	sta     (sp),y
	lda     #<(_CURSOR)
	ldx     #>(_CURSOR)
	jmp     _oam_meta_spr

.endproc

; ---------------------------------------------------------------
; void __near__ upgrade_draw_background (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_upgrade_draw_background: near

.segment	"CODE"

;
; fade_in();
;
	jsr     _fade_in
;
; ppu_off();
;
	jsr     _ppu_off
;
; clear_screen();
;
	jsr     _clear_screen
;
; pal_bg(upgrade_palette_bg);
;
	lda     #<(_upgrade_palette_bg)
	ldx     #>(_upgrade_palette_bg)
	jsr     _pal_bg
;
; pal_spr(upgrade_palette_sp);
;
	lda     #<(_upgrade_palette_sp)
	ldx     #>(_upgrade_palette_sp)
	jsr     _pal_spr
;
; vram_adr(PPU_PALLETE);
;
	ldx     #$23
	lda     #$C0
	jsr     _vram_adr
;
; for (x = 0x00; x != 0x40; ++x) {
;
	lda     #$00
	sta     _x
L127D:	lda     _x
	cmp     #$40
	beq     L127E
;
; vram_put(0x00);
;
	lda     #$00
	jsr     _vram_put
;
; for (x = 0x00; x != 0x40; ++x) {
;
	inc     _x
	jmp     L127D
;
; for (y = 0x02; y != 0x1B; ++y) {
;
L127E:	lda     #$02
	sta     _y
L127F:	lda     _y
	cmp     #$1B
	beq     L1282
;
; vram_adr(NAMETABLE_A + SCREEN_TILES_X * y + 0x02);
;
	ldx     #$00
	lda     _y
	jsr     shlax4
	stx     tmp1
	asl     a
	rol     tmp1
	pha
	lda     tmp1
	clc
	adc     #$20
	tax
	pla
	clc
	adc     #$02
	bcc     L0E5A
	inx
L0E5A:	jsr     _vram_adr
;
; if (y == 0x02 || y == 0x18 || y == 0x1A) {
;
	lda     _y
	cmp     #$02
	beq     L1280
	cmp     #$18
	beq     L1280
	cmp     #$1A
	bne     L0E5B
;
; vram_put(CHR_BORDER_CORNER);
;
L1280:	lda     #$26
	jsr     _vram_put
;
; for(x = 0x00; x != 0x1A; ++x) vram_put(CHR_BORDER_HORZ);
;
	lda     #$00
	sta     _x
L1281:	lda     _x
	cmp     #$1A
	beq     L0E61
	lda     #$27
	jsr     _vram_put
	inc     _x
	jmp     L1281
;
; vram_put(CHR_BORDER_CORNER);
;
L0E61:	lda     #$26
;
; } else {
;
	jmp     L127C
;
; vram_put(CHR_BORDER_VERT);
;
L0E5B:	lda     #$2A
	jsr     _vram_put
;
; vram_adr(NAMETABLE_A + SCREEN_TILES_X * y + 0x1D);
;
	ldx     #$00
	lda     _y
	jsr     shlax4
	stx     tmp1
	asl     a
	rol     tmp1
	pha
	lda     tmp1
	clc
	adc     #$20
	tax
	pla
	clc
	adc     #$1D
	bcc     L0E71
	inx
L0E71:	jsr     _vram_adr
;
; vram_put(CHR_BORDER_VERT);
;
	lda     #$2A
L127C:	jsr     _vram_put
;
; for (y = 0x02; y != 0x1B; ++y) {
;
	inc     _y
	jmp     L127F
;
; index = 0x00;
;
L1282:	lda     #$00
	sta     _index
;
; adr = NAMETABLE_A + SCREEN_TILES_X * 0x04 + 0x04;
;
	ldx     #$20
	lda     #$84
	sta     _adr
	stx     _adr+1
;
; for(x = 0x00; x != ABILITIES_COUNT; ++x) {
;
	lda     #$00
	sta     _x
L1283:	lda     _x
	cmp     #$05
	beq     L0E79
;
; tmp = player.abilities.list[x];
;
	ldy     _x
	lda     _player+17,y
	sta     _tmp
;
; upgrade_draw_icon();
;
	jsr     _upgrade_draw_icon
;
; for (y = 0x00; y != ABILITY_MAX_LEVEL; ++y)
;
	lda     #$00
	sta     _y
L1284:	lda     _y
	cmp     #$05
	beq     L0E86
;
; vram_put(y < tmp ? CHR_FCELL_TOP : CHR_CELL_TOP);
;
	cmp     _tmp
	bcs     L1285
	lda     #$23
	jmp     L1286
L1285:	lda     #$22
L1286:	jsr     _vram_put
;
; for (y = 0x00; y != ABILITY_MAX_LEVEL; ++y)
;
	inc     _y
	jmp     L1284
;
; adr += SCREEN_TILES_X;
;
L0E86:	lda     #$20
	clc
	adc     _adr
	sta     _adr
	bcc     L0E95
	inc     _adr+1
;
; upgrade_draw_icon();
;
L0E95:	jsr     _upgrade_draw_icon
;
; for (y = 0x00; y != ABILITY_MAX_LEVEL; ++y)
;
	lda     #$00
	sta     _y
L1287:	lda     _y
	cmp     #$05
	beq     L0E98
;
; vram_put(y < tmp ? CHR_FCELL_BOTTOM : CHR_CELL_BOTTOM);
;
	cmp     _tmp
	bcs     L1288
	lda     #$25
	jmp     L1289
L1288:	lda     #$24
L1289:	jsr     _vram_put
;
; for (y = 0x00; y != ABILITY_MAX_LEVEL; ++y)
;
	inc     _y
	jmp     L1287
;
; adr += SCREEN_TILES_X + SCREEN_TILES_X;
;
L0E98:	lda     #$40
	clc
	adc     _adr
	sta     _adr
	bcc     L0EA7
	inc     _adr+1
;
; for(x = 0x00; x != ABILITIES_COUNT; ++x) {
;
L0EA7:	inc     _x
	jmp     L1283
;
; put_str(NTADR_A(0x03, 0x19), "                POINTS    ");
;
L0E79:	ldx     #$23
	txa
	jsr     pushax
	lda     #<(L0EAF)
	ldx     #>(L0EAF)
	jsr     _put_str
;
; for (x = 0x01; x != ABILITY_MAX_LEVEL; ++x) {
;
	lda     #$01
	sta     _x
L128A:	lda     _x
	cmp     #$05
	beq     L0EB2
;
; if (player.abilities.elevel >= x) upgrade_draw_desc(x);
;
	lda     _player+22
	cmp     _x
	bcc     L0EB2
	lda     _x
	jsr     _upgrade_draw_desc
;
; for (x = 0x01; x != ABILITY_MAX_LEVEL; ++x) {
;
	inc     _x
	jmp     L128A
;
; upgrade_show_ablity_desc();
;
L0EB2:	jsr     _upgrade_show_ablity_desc
;
; upgrade_show_current_points();
;
	jsr     _upgrade_show_current_points
;
; ppu_on_all();
;
	jsr     _ppu_on_all
;
; for (x = 0x01; x <= ABILITY_MAX_LEVEL; ++x) {
;
	lda     #$01
	sta     _x
L128B:	lda     _x
	cmp     #$06
	bcs     L0EC2
;
; ppu_wait_nmi();
;
	jsr     _ppu_wait_nmi
;
; clear_vram_buffer();
;
	jsr     _clear_vram_buffer
;
; if (player.abilities.elevel >= x) upgrade_draw_desc(x); else break;
;
	lda     _player+22
	cmp     _x
	bcc     L0EC2
	lda     _x
	jsr     _upgrade_draw_desc
;
; for (x = 0x01; x <= ABILITY_MAX_LEVEL; ++x) {
;
	inc     _x
	jmp     L128B
;
; fade_out();
;
L0EC2:	jmp     _fade_out

.endproc

; ---------------------------------------------------------------
; void __near__ upgrade_movement_and_actions (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_upgrade_movement_and_actions: near

.segment	"CODE"

;
; state = 0;
;
	lda     #$00
	sta     _state
;
; if (pad1_new & PAD_DOWN) {
;
	lda     _pad1_new
	and     #$04
	beq     L128D
;
; sfx_play(SND_MENU_MOVE, 0);
;
	lda     #$00
	jsr     pusha
	jsr     _sfx_play
;
; if (player.abilities.selection == (ABILITIES_COUNT - 1)) player.abilities.selection = 0;
;
	lda     _player+16
	cmp     #$04
	bne     L128C
	lda     #$00
	sta     _player+16
;
; else ++player.abilities.selection;
;
	jmp     L0F73
L128C:	inc     _player+16
;
; upgrade_show_ablity_desc();
;
L0F73:	jsr     _upgrade_show_ablity_desc
;
; if (pad1_new & PAD_UP) {
;
L128D:	lda     _pad1_new
	and     #$08
	beq     L128F
;
; sfx_play(SND_MENU_MOVE, 0);
;
	lda     #$00
	jsr     pusha
	jsr     _sfx_play
;
; if (player.abilities.selection == 0) player.abilities.selection = ABILITIES_COUNT - 1;
;
	lda     _player+16
	bne     L128E
	lda     #$04
	sta     _player+16
;
; else --player.abilities.selection;
;
	jmp     L0F7F
L128E:	dec     _player+16
;
; upgrade_show_ablity_desc();
;
L0F7F:	jsr     _upgrade_show_ablity_desc
;
; if (pad1_new & PAD_B) {
;
L128F:	lda     _pad1_new
	and     #$40
	jeq     L129E
;
; if (tmp != ABILITY_MAX_LEVEL && points >= index) {
;
	lda     _tmp
	cmp     #$05
	jeq     L0F84
	lda     _points
	cmp     _index
	jcc     L0F84
;
; sfx_play(SND_MENU_UPGRADE, 0);
;
	lda     #$02
	jsr     pusha
	lda     #$00
	jsr     _sfx_play
;
; ++tmp;
;
	inc     _tmp
;
; points -= index;
;
	lda     _index
	eor     #$FF
	sec
	adc     _points
	sta     _points
;
; upgrade_recalc_ability_cost();
;
	jsr     _upgrade_recalc_ability_cost
;
; upgrade_show_current_points();
;
	jsr     _upgrade_show_current_points
;
; one_vram_buffer(CHR_FCELL_TOP, NTADR_A(0x06 + tmp, 0x04 + player.abilities.selection * 3));
;
	lda     #$23
	jsr     pusha
	ldx     #$00
	lda     _player+16
	jsr     mulax3
	clc
	adc     #$04
	bcc     L0F97
	inx
L0F97:	jsr     shlax4
	stx     tmp1
	asl     a
	rol     tmp1
	sta     ptr1
	ldx     #$00
	lda     _tmp
	clc
	adc     #$06
	bcc     L0F99
	inx
L0F99:	ora     ptr1
	pha
	txa
	ora     tmp1
	tax
	pla
	pha
	txa
	ora     #$20
	tax
	pla
	jsr     _one_vram_buffer
;
; one_vram_buffer(CHR_FCELL_BOTTOM, NTADR_A(0x06 + tmp, 0x05 + player.abilities.selection * 3));
;
	lda     #$25
	jsr     pusha
	ldx     #$00
	lda     _player+16
	jsr     mulax3
	clc
	adc     #$05
	bcc     L0FA1
	inx
L0FA1:	jsr     shlax4
	stx     tmp1
	asl     a
	rol     tmp1
	sta     ptr1
	ldx     #$00
	lda     _tmp
	clc
	adc     #$06
	bcc     L0FA3
	inx
L0FA3:	ora     ptr1
	pha
	txa
	ora     tmp1
	tax
	pla
	pha
	txa
	ora     #$20
	tax
	pla
	jsr     _one_vram_buffer
;
; player.abilities.list[player.abilities.selection] = tmp;
;
	ldy     _player+16
	lda     _tmp
	sta     _player+17,y
;
; switch(player.abilities.selection) {
;
	lda     _player+16
;
; }
;
	beq     L1297
	cmp     #$01
	beq     L1293
	cmp     #$02
	beq     L1292
	cmp     #$03
	beq     L1298
	cmp     #$04
	beq     L129D
	jmp     L129E
;
; ++player.cut.size; 
;
L1292:	inc     _player+10
;
; break;
;
	jmp     L129E
;
; if (tmp == 1 || tmp == 3 || tmp == 5) ++player.cut.power; 
;
L1293:	lda     _tmp
	cmp     #$01
	beq     L1296
	cmp     #$03
	beq     L1296
	cmp     #$05
	bne     L129E
L1296:	inc     _player+9
;
; break;
;
	jmp     L129E
;
; --player.cut.max_delay; 
;
L1297:	dec     _player+13
;
; break;
;
	jmp     L129E
;
; if (player.move_max_delay == 0) {
;
L1298:	lda     _player+5
	bne     L129B
;
; if (player.move_max_increase == 0) player.move_max_increase = 3;
;
	lda     _player+7
	bne     L1299
	lda     #$03
	sta     _player+7
;
; else --player.move_max_increase;
;
	jmp     L129A
L1299:	dec     _player+7
;
; player.move_increase = player.move_max_increase;
;
L129A:	lda     _player+7
	sta     _player+6
;
; } else {
;
	jmp     L129C
;
; --player.move_max_delay; 
;
L129B:	dec     _player+5
;
; if (tmp == ABILITY_MAX_LEVEL) upgrade_draw_desc(player.abilities.elevel);
;
L129C:	lda     _tmp
	cmp     #$05
	bne     L129E
	lda     _player+22
	jsr     _upgrade_draw_desc
;
; break;
;
	jmp     L129E
;
; ++player.abilities.elevel;
;
L129D:	inc     _player+22
;
; upgrade_draw_desc(player.abilities.elevel);
;
	lda     _player+22
	jsr     _upgrade_draw_desc
;
; break;
;
	jmp     L129E
;
; sfx_play(SND_MENU_ERROR, 0);
;
L0F84:	lda     #$03
	jsr     pusha
	lda     #$00
	jsr     _sfx_play
;
; if (pad1_new & PAD_START) state = 1;
;
L129E:	lda     _pad1_new
	and     #$10
	beq     L0FD2
	lda     #$01
	sta     _state
;
; } 
;
L0FD2:	rts

.endproc

; ---------------------------------------------------------------
; void __near__ upgrade_draw_desc (unsigned char)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_upgrade_draw_desc: near

.segment	"CODE"

;
; void upgrade_draw_desc(char abil_num) {
;
	jsr     pusha
;
; switch (abil_num) {
;
	ldy     #$00
	lda     (sp),y
;
; }
;
	cmp     #$01
	beq     L0ED6
	cmp     #$02
	beq     L0EEC
	cmp     #$03
	beq     L0F02
	cmp     #$04
	jeq     L0F18
	cmp     #$05
	jeq     L0F2E
	jmp     incsp1
;
; case 1: multi_vram_buffer_horz(" SMALL SCYTHE ", 0x0E, NTADR_A(0x0E, 0x04));
;
L0ED6:	jsr     decsp3
	lda     #<(L0ED8)
	iny
	sta     (sp),y
	iny
	lda     #>(L0ED8)
	sta     (sp),y
	lda     #$0E
	ldy     #$00
	sta     (sp),y
	ldx     #$20
	lda     #$8E
	jsr     _multi_vram_buffer_horz
;
; multi_vram_buffer_horz(" \\ [ A        ", 0x0E, NTADR_A(0x0E, 0x05));
;
	jsr     decsp3
	lda     #<(L0EE2)
	ldy     #$01
	sta     (sp),y
	iny
	lda     #>(L0EE2)
	sta     (sp),y
	lda     #$0E
	ldy     #$00
	sta     (sp),y
	ldx     #$20
	lda     #$AE
;
; break;
;
	jmp     L129F
;
; case 2: multi_vram_buffer_horz(" DASH         ", 0x0E, NTADR_A(0x0E, 0x07));
;
L0EEC:	jsr     decsp3
	lda     #<(L0EEE)
	iny
	sta     (sp),y
	iny
	lda     #>(L0EEE)
	sta     (sp),y
	lda     #$0E
	ldy     #$00
	sta     (sp),y
	ldx     #$20
	lda     #$EE
	jsr     _multi_vram_buffer_horz
;
; multi_vram_buffer_horz(" ^ ^ OR _ _   ", 0x0E, NTADR_A(0x0E, 0x08));
;
	jsr     decsp3
	lda     #<(L0EF8)
	ldy     #$01
	sta     (sp),y
	iny
	lda     #>(L0EF8)
	sta     (sp),y
	lda     #$0E
	ldy     #$00
	sta     (sp),y
	ldx     #$21
;
; break;
;
	jmp     L129F
;
; case 3: multi_vram_buffer_horz(" ABILITIES    ", 0x0E, NTADR_A(0x0E, 0x10));
;
L0F02:	jsr     decsp3
	lda     #<(L0F04)
	iny
	sta     (sp),y
	iny
	lda     #>(L0F04)
	sta     (sp),y
	lda     #$0E
	ldy     #$00
	sta     (sp),y
	ldx     #$22
	jsr     _multi_vram_buffer_horz
;
; multi_vram_buffer_horz(" POWER[       ", 0x0E,  NTADR_A(0x0E, 0x11));
;
	jsr     decsp3
	lda     #<(L0F0E)
	ldy     #$01
	sta     (sp),y
	iny
	lda     #>(L0F0E)
	sta     (sp),y
	lda     #$0E
	ldy     #$00
	sta     (sp),y
	ldx     #$22
	lda     #$2E
;
; break;
;
	jmp     L129F
;
; case 4: multi_vram_buffer_horz(" POWER SLASH  ", 0x0E, NTADR_A(0x0E, 0x0A));
;
L0F18:	jsr     decsp3
	lda     #<(L0F1A)
	iny
	sta     (sp),y
	iny
	lda     #>(L0F1A)
	sta     (sp),y
	lda     #$0E
	ldy     #$00
	sta     (sp),y
	ldx     #$21
	lda     #$4E
	jsr     _multi_vram_buffer_horz
;
; multi_vram_buffer_horz(" ] ] ]        ", 0x0E,  NTADR_A(0x0E, 0x0B));
;
	jsr     decsp3
	lda     #<(L0F24)
	ldy     #$01
	sta     (sp),y
	iny
	lda     #>(L0F24)
	sta     (sp),y
	lda     #$0E
	ldy     #$00
	sta     (sp),y
	ldx     #$21
	lda     #$6E
;
; break;
;
	jmp     L129F
;
; case 5: multi_vram_buffer_horz("[", 0x01,  NTADR_A(0x15, 0x11));
;
L0F2E:	jsr     decsp3
	lda     #<(L0F30)
	iny
	sta     (sp),y
	iny
	lda     #>(L0F30)
	sta     (sp),y
	lda     #$01
	ldy     #$00
	sta     (sp),y
	ldx     #$22
	lda     #$35
	jsr     _multi_vram_buffer_horz
;
; if (player.abilities.list[ABILITY_MOVE_SPEED] == ABILITY_MAX_LEVEL) {
;
	lda     _player+20
	cmp     #$05
	bne     L0ED4
;
; multi_vram_buffer_horz(" MOVE AND CUT ", 0x0E,  NTADR_A(0x0E, 0x0D));
;
	jsr     decsp3
	lda     #<(L0F3D)
	ldy     #$01
	sta     (sp),y
	iny
	lda     #>(L0F3D)
	sta     (sp),y
	lda     #$0E
	ldy     #$00
	sta     (sp),y
	ldx     #$21
	lda     #$AE
	jsr     _multi_vram_buffer_horz
;
; multi_vram_buffer_horz(" ACTIVATED    ", 0x0E ,  NTADR_A(0x0E, 0x0E));
;
	jsr     decsp3
	lda     #<(L0F47)
	ldy     #$01
	sta     (sp),y
	iny
	lda     #>(L0F47)
	sta     (sp),y
	lda     #$0E
	ldy     #$00
	sta     (sp),y
	ldx     #$21
	lda     #$CE
L129F:	jsr     _multi_vram_buffer_horz
;
; }
;
L0ED4:	jmp     incsp1

.endproc

; ---------------------------------------------------------------
; void __near__ upgrade_draw_icon (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_upgrade_draw_icon: near

.segment	"CODE"

;
; vram_adr(adr);
;
	lda     _adr
	ldx     _adr+1
	jsr     _vram_adr
;
; vram_put(abilities_icons[index]);
;
	ldy     _index
	lda     _abilities_icons,y
	jsr     _vram_put
;
; ++index;
;
	inc     _index
;
; vram_put(abilities_icons[index]);
;
	ldy     _index
	lda     _abilities_icons,y
	jsr     _vram_put
;
; ++index;
;
	inc     _index
;
; vram_put(0x00);
;
	lda     #$00
	jmp     _vram_put

.endproc

; ---------------------------------------------------------------
; void __near__ upgrade_recalc_ability_cost (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_upgrade_recalc_ability_cost: near

.segment	"CODE"

;
; if (tmp < 5) {
;
	lda     _tmp
	cmp     #$05
	bcs     L101D
;
; index = upgrade_cost[player.abilities.selection * ABILITY_MAX_LEVEL + tmp];
;
	ldx     #$00
	lda     _player+16
	jsr     mulax5
	clc
	adc     _tmp
	bcc     L12A0
	inx
L12A0:	sta     ptr1
	txa
	clc
	adc     #>(_upgrade_cost)
	sta     ptr1+1
	ldy     #<(_upgrade_cost)
	lda     (ptr1),y
	sta     _index
;
; one_vram_buffer(CHR_ZERO + index, NTADR_A(0x0F, 0x19));
;
	clc
	adc     #$30
	jsr     pusha
	ldx     #$23
	lda     #$2F
	jmp     _one_vram_buffer
;
; one_vram_buffer(CHR_BG_BLANK, NTADR_A(0x0F, 0x19));
;
L101D:	lda     #$7F
	jsr     pusha
	ldx     #$23
	lda     #$2F
	jmp     _one_vram_buffer

.endproc

; ---------------------------------------------------------------
; void __near__ upgrade_show_ablity_desc (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_upgrade_show_ablity_desc: near

.segment	"CODE"

;
; adr = NTADR_A(0x04, 0x19);
;
	ldx     #$23
	lda     #$24
	sta     _adr
	stx     _adr+1
;
; switch(player.abilities.selection) {
;
	lda     _player+16
;
; }
;
	beq     L1003
	cmp     #$01
	beq     L0FFC
	cmp     #$02
	beq     L0FF5
	cmp     #$03
	beq     L100A
	cmp     #$04
	beq     L1011
	jmp     L0FF3
;
; case ABILITY_CUT_SIZE: multi_vram_buffer_horz("CUT WIDTH ", 0x0A, adr); break;
;
L0FF5:	jsr     decsp3
	lda     #<(L0FF7)
	ldy     #$01
	sta     (sp),y
	iny
	lda     #>(L0FF7)
	jmp     L12A7
;
; case ABILITY_CUT_POWER: multi_vram_buffer_horz("CUT POWER ", 0x0A, adr); break;
;
L0FFC:	jsr     decsp3
	lda     #<(L0FFE)
	ldy     #$01
	sta     (sp),y
	iny
	lda     #>(L0FFE)
	jmp     L12A7
;
; case ABILITY_CUT_SPEED: multi_vram_buffer_horz("CUT SPEED ", 0x0A, adr); break;
;
L1003:	jsr     decsp3
	lda     #<(L1005)
	ldy     #$01
	sta     (sp),y
	iny
	lda     #>(L1005)
	jmp     L12A7
;
; case ABILITY_MOVE_SPEED: multi_vram_buffer_horz("MOVE SPEED", 0x0A, adr); break;
;
L100A:	jsr     decsp3
	lda     #<(L100C)
	ldy     #$01
	sta     (sp),y
	iny
	lda     #>(L100C)
	jmp     L12A7
;
; case ABILITY_SPECIAL: multi_vram_buffer_horz("SPECIAL   ", 0x0A, adr); break;
;
L1011:	jsr     decsp3
	lda     #<(L1013)
	ldy     #$01
	sta     (sp),y
	iny
	lda     #>(L1013)
L12A7:	sta     (sp),y
	lda     #$0A
	ldy     #$00
	sta     (sp),y
	lda     _adr
	ldx     _adr+1
	jsr     _multi_vram_buffer_horz
;
; tmp = player.abilities.list[player.abilities.selection];
;
L0FF3:	ldy     _player+16
	lda     _player+17,y
	sta     _tmp
;
; upgrade_recalc_ability_cost();
;
	jmp     _upgrade_recalc_ability_cost

.endproc

; ---------------------------------------------------------------
; void __near__ upgrade_show_current_points (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_upgrade_show_current_points: near

.segment	"CODE"

;
; one_vram_buffer(CHR_ZERO + points / 10, NTADR_A(0x1A, 0x19));
;
	lda     _points
	jsr     pusha0
	lda     #$0A
	jsr     tosudiva0
	clc
	adc     #$30
	jsr     pusha
	ldx     #$23
	lda     #$3A
	jsr     _one_vram_buffer
;
; one_vram_buffer(CHR_ZERO + points % 10, NTADR_A(0x1B, 0x19));
;
	lda     _points
	jsr     pusha0
	lda     #$0A
	jsr     tosumoda0
	clc
	adc     #$30
	jsr     pusha
	ldx     #$23
	lda     #$3B
	jmp     _one_vram_buffer

.endproc

; ---------------------------------------------------------------
; void __near__ title_draw_background (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_title_draw_background: near

.segment	"CODE"

;
; ppu_off();
;
	jsr     _ppu_off
;
; pal_bg(title_palette_bg);
;
	lda     #<(_title_palette_bg)
	ldx     #>(_title_palette_bg)
	jsr     _pal_bg
;
; pal_spr(title_palette_sp);
;
	lda     #<(_title_palette_sp)
	ldx     #>(_title_palette_sp)
	jsr     _pal_spr
;
; clear_screen();
;
	jsr     _clear_screen
;
; vram_adr(PPU_PALLETE);
;
	ldx     #$23
	lda     #$C0
	jsr     _vram_adr
;
; for(x = 0x00; x != 0x40; ++x) vram_put(0);
;
	lda     #$00
	sta     _x
L12A8:	lda     _x
	cmp     #$40
	beq     L069B
	lda     #$00
	jsr     _vram_put
	inc     _x
	jmp     L12A8
;
; ppu_on_all();
;
L069B:	jsr     _ppu_on_all
;
; delay(30);
;
	lda     #$1E
	jsr     _delay
;
; oam_clear();
;
	jsr     _oam_clear
;
; x = state = 0;
;
	lda     #$00
	sta     _state
	sta     _x
;
; y = 8;
;
	lda     #$08
	sta     _y
;
; sfx_play(SND_MENU_HIT, 0);
;
	lda     #$05
	jsr     pusha
	lda     #$00
	jsr     _sfx_play
;
; oam_spr(LOGO[0] + LOGO_X_OFFSET, LOGO[1] + LOGO_Y_OFFSET, LOGO[2], LOGO[3]);
;
	jsr     decsp3
	lda     _LOGO
	clc
	adc     #$48
	ldy     #$02
	sta     (sp),y
	lda     _LOGO+1
	clc
	adc     #$19
	dey
	sta     (sp),y
	lda     _LOGO+2
	dey
	sta     (sp),y
	lda     _LOGO+3
	jsr     _oam_spr
;
; delay_with_state_skip(40);
;
	lda     #$28
	jsr     _delay_with_state_skip
;
; sfx_play(SND_MENU_HIT, 0);
;
	lda     #$05
	jsr     pusha
	lda     #$00
	jsr     _sfx_play
;
; oam_spr(LOGO[4] + LOGO_X_OFFSET, LOGO[5] + LOGO_Y_OFFSET, LOGO[6], LOGO[7]);
;
	jsr     decsp3
	lda     _LOGO+4
	clc
	adc     #$48
	ldy     #$02
	sta     (sp),y
	lda     _LOGO+5
	clc
	adc     #$19
	dey
	sta     (sp),y
	lda     _LOGO+6
	dey
	sta     (sp),y
	lda     _LOGO+7
	jsr     _oam_spr
;
; delay_with_state_skip(40);
;
	lda     #$28
	jsr     _delay_with_state_skip
;
; nmi_wait_and_prepare();
;
L06CD:	jsr     _nmi_wait_and_prepare
;
; if (state == 1) break;
;
	lda     _state
	cmp     #$01
	jeq     L06CE
;
; if (pad1_new & PAD_START) state = 1;
;
	lda     _pad1_new
	and     #$10
	beq     L12A9
	lda     #$01
	sta     _state
;
; ++x;
;
L12A9:	inc     _x
;
; if (x == 0x05) {
;
	lda     _x
	cmp     #$05
	bne     L06CD
;
; x = 0;
;
	lda     #$00
	sta     _x
;
; sfx_play(SND_MENU_HIT, 0);
;
	lda     #$05
	jsr     pusha
	lda     #$00
	jsr     _sfx_play
;
; oam_spr(LOGO[y] + LOGO_X_OFFSET, LOGO[y + 1] + LOGO_Y_OFFSET, LOGO[y + 2], LOGO[y + 3]);
;
	jsr     decsp3
	ldy     _y
	lda     _LOGO,y
	clc
	adc     #$48
	ldy     #$02
	sta     (sp),y
	ldx     #$00
	lda     _y
	clc
	adc     #$01
	bcc     L06E7
	inx
L06E7:	sta     ptr1
	txa
	clc
	adc     #>(_LOGO)
	sta     ptr1+1
	ldy     #<(_LOGO)
	lda     (ptr1),y
	clc
	adc     #$19
	ldy     #$01
	sta     (sp),y
	ldx     #$00
	lda     _y
	clc
	adc     #$02
	bcc     L06EB
	inx
L06EB:	sta     ptr1
	txa
	clc
	adc     #>(_LOGO)
	sta     ptr1+1
	ldy     #<(_LOGO)
	lda     (ptr1),y
	ldy     #$00
	sta     (sp),y
	ldx     #$00
	lda     _y
	clc
	adc     #$03
	bcc     L06EE
	inx
L06EE:	sta     ptr1
	txa
	clc
	adc     #>(_LOGO)
	sta     ptr1+1
	ldy     #<(_LOGO)
	lda     (ptr1),y
	jsr     _oam_spr
;
; y += 4;
;
	lda     #$04
	clc
	adc     _y
	sta     _y
;
; if (y == LOGO_TILE_COUNT * 4) break;
;
	cmp     #$7C
	jne     L06CD
;
; delay_with_state_skip(60);
;
L06CE:	lda     #$3C
	jsr     _delay_with_state_skip
;
; if (state == 0) sfx_play(SND_GAME_LIGHTNING, 0);
;
	lda     _state
	bne     L06F5
	lda     #$09
	jsr     pusha
	lda     #$00
	jsr     _sfx_play
;
; multi_vram_buffer_horz("ONE THOUSAND MAN", 0x10, NTADR_A(0x08, 0x0C));
;
L06F5:	jsr     decsp3
	lda     #<(L06FB)
	ldy     #$01
	sta     (sp),y
	iny
	lda     #>(L06FB)
	sta     (sp),y
	lda     #$10
	ldy     #$00
	sta     (sp),y
	ldx     #$21
	lda     #$88
	jsr     _multi_vram_buffer_horz
;
; delay_with_state_skip(90);
;
	lda     #$5A
	jmp     _delay_with_state_skip

.endproc

; ---------------------------------------------------------------
; void __near__ title_draw_options (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_title_draw_options: near

.segment	"CODE"

;
; multi_vram_buffer_horz(game.effects.lightning_enabled == 0 ? "OFF": "ON ", 0x03, NTADR_A(0x14, 0x13));
;
	jsr     decsp3
	lda     _game+9
	bne     L05F4
	lda     #<(L05F3)
	ldx     #>(L05F3)
	jmp     L05F7
L05F4:	lda     #<(L05F6)
	ldx     #>(L05F6)
L05F7:	ldy     #$01
	sta     (sp),y
	iny
	txa
	sta     (sp),y
	lda     #$03
	ldy     #$00
	sta     (sp),y
	ldx     #$22
	lda     #$74
	jsr     _multi_vram_buffer_horz
;
; multi_vram_buffer_horz(game.last_level == 0 ? "ON" : "OFF ", 0x03, NTADR_A(0x14, 0x11));
;
	jsr     decsp3
	lda     _game+1
	bne     L0603
	lda     #<(L0602)
	ldx     #>(L0602)
	jmp     L0606
L0603:	lda     #<(L0605)
	ldx     #>(L0605)
L0606:	ldy     #$01
	sta     (sp),y
	iny
	txa
	sta     (sp),y
	lda     #$03
	ldy     #$00
	sta     (sp),y
	ldx     #$22
	lda     #$34
	jsr     _multi_vram_buffer_horz
;
; switch(game.difficulty) {
;
	lda     _game+6
;
; }
;
	beq     L0613
	cmp     #$01
	beq     L061F
	cmp     #$02
	beq     L062B
	rts
;
; case 0: multi_vram_buffer_horz("EASY  ", 0x06, NTADR_A(0x14, 0x0F)); break;
;
L0613:	jsr     decsp3
	lda     #<(L0615)
	ldy     #$01
	sta     (sp),y
	iny
	lda     #>(L0615)
	sta     (sp),y
	lda     #$06
	ldy     #$00
	sta     (sp),y
	ldx     #$21
	lda     #$F4
	jmp     _multi_vram_buffer_horz
;
; case 1: multi_vram_buffer_horz("NORMAL", 0x06, NTADR_A(0x14, 0x0F)); break;
;
L061F:	jsr     decsp3
	lda     #<(L0621)
	ldy     #$01
	sta     (sp),y
	iny
	lda     #>(L0621)
	sta     (sp),y
	lda     #$06
	ldy     #$00
	sta     (sp),y
	ldx     #$21
	lda     #$F4
	jmp     _multi_vram_buffer_horz
;
; case 2: multi_vram_buffer_horz("HARD  ", 0x06, NTADR_A(0x14, 0x0F)); break;
;
L062B:	jsr     decsp3
	lda     #<(L062D)
	ldy     #$01
	sta     (sp),y
	iny
	lda     #>(L062D)
	sta     (sp),y
	lda     #$06
	ldy     #$00
	sta     (sp),y
	ldx     #$21
	lda     #$F4
	jmp     _multi_vram_buffer_horz

.endproc

; ---------------------------------------------------------------
; void __near__ title_draw_menu (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_title_draw_menu: near

.segment	"CODE"

;
; for (index = 0; index != 4; ++index)
;
	lda     #$00
	sta     _index
L12AC:	lda     _index
	cmp     #$04
	beq     L0638
;
; multi_vram_buffer_horz("                    ", 0x14, NTADR_A(0x09, 0x0F + index + index));
;
	jsr     decsp3
	lda     #<(L0640)
	ldy     #$01
	sta     (sp),y
	iny
	lda     #>(L0640)
	sta     (sp),y
	lda     #$14
	ldy     #$00
	sta     (sp),y
	ldx     #$00
	lda     _index
	clc
	adc     #$0F
	bcc     L12AB
	inx
	clc
L12AB:	adc     _index
	bcc     L12AA
	inx
L12AA:	jsr     shlax4
	stx     tmp1
	asl     a
	rol     tmp1
	ora     #$09
	pha
	lda     tmp1
	ora     #$20
	tax
	pla
	jsr     _multi_vram_buffer_horz
;
; for (index = 0; index != 4; ++index)
;
	inc     _index
	jmp     L12AC
;
; nmi_wait_and_prepare();
;
L0638:	jsr     _nmi_wait_and_prepare
;
; switch (game.state) {
;
	lda     _game+3
;
; }
;
	beq     L064F
	cmp     #$04
	beq     L0665
	jmp     L12AD
;
; multi_vram_buffer_horz("START", 0x05, NTADR_A(0x0D, 0x0F));
;
L064F:	jsr     decsp3
	lda     #<(L0651)
	ldy     #$01
	sta     (sp),y
	iny
	lda     #>(L0651)
	sta     (sp),y
	lda     #$05
	ldy     #$00
	sta     (sp),y
	ldx     #$21
	lda     #$ED
	jsr     _multi_vram_buffer_horz
;
; multi_vram_buffer_horz("OPTIONS", 0x07, NTADR_A(0x0D, 0x11));
;
	jsr     decsp3
	lda     #<(L065B)
	ldy     #$01
	sta     (sp),y
	iny
	lda     #>(L065B)
	sta     (sp),y
	lda     #$07
	ldy     #$00
	sta     (sp),y
	ldx     #$22
	lda     #$2D
	jsr     _multi_vram_buffer_horz
;
; break;
;
	jmp     L12AD
;
; multi_vram_buffer_horz("LEVEL   ", 0x08, NTADR_A(0x09, 0x0F));
;
L0665:	jsr     decsp3
	lda     #<(L0667)
	ldy     #$01
	sta     (sp),y
	iny
	lda     #>(L0667)
	sta     (sp),y
	lda     #$08
	ldy     #$00
	sta     (sp),y
	ldx     #$21
	lda     #$E9
	jsr     _multi_vram_buffer_horz
;
; multi_vram_buffer_horz("ENDLESS ", 0x08, NTADR_A(0x09, 0x11));
;
	jsr     decsp3
	lda     #<(L0671)
	ldy     #$01
	sta     (sp),y
	iny
	lda     #>(L0671)
	sta     (sp),y
	lda     #$08
	ldy     #$00
	sta     (sp),y
	ldx     #$22
	lda     #$29
	jsr     _multi_vram_buffer_horz
;
; multi_vram_buffer_horz("FLASH   ", 0x08, NTADR_A(0x09, 0x13));
;
	jsr     decsp3
	lda     #<(L067B)
	ldy     #$01
	sta     (sp),y
	iny
	lda     #>(L067B)
	sta     (sp),y
	lda     #$08
	ldy     #$00
	sta     (sp),y
	ldx     #$22
	lda     #$69
	jsr     _multi_vram_buffer_horz
;
; multi_vram_buffer_horz("RETURN  ", 0x08, NTADR_A(0x09, 0x15));
;
	jsr     decsp3
	lda     #<(L0685)
	ldy     #$01
	sta     (sp),y
	iny
	lda     #>(L0685)
	sta     (sp),y
	lda     #$08
	ldy     #$00
	sta     (sp),y
	ldx     #$22
	lda     #$A9
	jsr     _multi_vram_buffer_horz
;
; title_draw_options();
;
	jsr     _title_draw_options
;
; index = 0;
;
L12AD:	lda     #$00
	sta     _index
;
; }
;
	rts

.endproc

; ---------------------------------------------------------------
; void __near__ title_check_cheat_code (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_title_check_cheat_code: near

.segment	"CODE"

;
; if (marker < 10) {
;
	lda     _marker
	cmp     #$0A
	jcs     L12C4
;
; if (pad1_new & PAD_UP) {
;
	lda     _pad1_new
	and     #$08
	beq     L12B4
;
; if (marker == 0 || marker == 1) ++marker; else marker = 0;
;
	lda     _marker
	beq     L12B1
	cmp     #$01
	beq     L12B1
	lda     #$00
	jmp     L12B3
L12B1:	inc     _marker
	jmp     L12B4
L12B3:	sta     _marker
;
; if (pad1_new & PAD_DOWN) {
;
L12B4:	lda     _pad1_new
	and     #$04
	beq     L12B8
;
; if (marker == 2 || marker == 3) ++marker; else marker = 0;
;
	lda     _marker
	cmp     #$02
	beq     L12B5
	cmp     #$03
	beq     L12B5
	lda     #$00
	jmp     L12B7
L12B5:	inc     _marker
	jmp     L12B8
L12B7:	sta     _marker
;
; if (pad1_new & PAD_LEFT) {
;
L12B8:	lda     _pad1_new
	and     #$02
	beq     L12BC
;
; if (marker == 4 || marker == 6) ++marker; else marker = 0;
;
	lda     _marker
	cmp     #$04
	beq     L12B9
	cmp     #$06
	beq     L12B9
	lda     #$00
	jmp     L12BB
L12B9:	inc     _marker
	jmp     L12BC
L12BB:	sta     _marker
;
; if (pad1_new & PAD_RIGHT) {
;
L12BC:	lda     _pad1_new
	and     #$01
	beq     L12C0
;
; if (marker == 5 || marker == 7) ++marker; else marker = 0;
;
	lda     _marker
	cmp     #$05
	beq     L12BD
	cmp     #$07
	beq     L12BD
	lda     #$00
	jmp     L12BF
L12BD:	inc     _marker
	jmp     L12C0
L12BF:	sta     _marker
;
; if (pad1_new & PAD_B) {
;
L12C0:	lda     _pad1_new
	and     #$40
	beq     L12C2
;
; if (marker == 8) ++marker; else marker = 0;
;
	lda     _marker
	cmp     #$08
	bne     L12C1
	inc     _marker
	jmp     L12C2
L12C1:	lda     #$00
	sta     _marker
;
; if (pad1_new & PAD_A) {
;
L12C2:	lda     _pad1_new
	and     #$80
	bne     L12D6
;
; }
;
	rts
;
; if (marker == 9) {
;
L12D6:	lda     _marker
	cmp     #$09
	bne     L12C3
;
; ++marker;
;
	inc     _marker
;
; sfx_play(SND_MENU_ERROR, 0);
;
	lda     #$03
	jsr     pusha
	lda     #$00
	jsr     _sfx_play
;
; multi_vram_buffer_horz("KONAMI CODE NOT FOUND", 0x15, NTADR_A(0x06, 0x17));
;
	jsr     decsp3
	lda     #<(L073E)
	ldy     #$01
	sta     (sp),y
	iny
	lda     #>(L073E)
	sta     (sp),y
	lda     #$15
	ldy     #$00
	sta     (sp),y
	ldx     #$22
	lda     #$E6
	jmp     _multi_vram_buffer_horz
;
; marker = 0;
;
L12C3:	lda     #$00
	sta     _marker
;
; } else if (marker < 249) {
;
	rts
L12C4:	lda     _marker
	cmp     #$F9
	bcc     L12D7
;
; }
;
	rts
;
; ++marker;
;
L12D7:	inc     _marker
;
; if ((marker - 10) % 20 == 0) {
;
	ldx     #$00
	lda     _marker
	sec
	sbc     #$0A
	bcs     L0751
	dex
L0751:	jsr     pushax
	lda     #$14
	jsr     tosumoda0
	cpx     #$00
	bne     L0760
	cmp     #$00
	bne     L0760
;
; if (marker > 130) {
;
	lda     _marker
	cmp     #$83
	bcc     L0753
;
; one_vram_buffer(CHR_DOT, NTADR_A(0x08 + (marker - 120) / 10, 0x19));
;
	lda     #$3B
	jsr     pusha
	lda     _marker
	sec
	sbc     #$78
	bcs     L075E
	dex
L075E:	jsr     pushax
;
; } else {
;
	jmp     L12D5
;
; one_vram_buffer(CHR_DOT, NTADR_A(0x08 + marker / 10, 0x19));
;
L0753:	lda     #$3B
	jsr     pusha
	lda     _marker
	jsr     pusha0
L12D5:	lda     #$0A
	jsr     tosudiva0
	clc
	adc     #$08
	bcc     L0769
	inx
L0769:	ora     #$20
	pha
	txa
	ora     #$03
	tax
	pla
	pha
	txa
	ora     #$20
	tax
	pla
	jsr     _one_vram_buffer
;
; if (marker == 140) {
;
L0760:	lda     _marker
	cmp     #$8C
	bne     L12C5
;
; multi_vram_buffer_horz("SEARCHING FOR ALTERNATIVES", 0x1A, NTADR_A(0x03, 0x17));
;
	jsr     decsp3
	lda     #<(L076D)
	ldy     #$01
	sta     (sp),y
	iny
	lda     #>(L076D)
	sta     (sp),y
	lda     #$1A
	ldy     #$00
	sta     (sp),y
	ldx     #$22
	lda     #$E3
	jsr     _multi_vram_buffer_horz
;
; multi_vram_buffer_horz("                 ", 0x11, NTADR_A(0x0A, 0x19));
;
	jsr     decsp3
	lda     #<(L0777)
	ldy     #$01
	sta     (sp),y
	iny
	lda     #>(L0777)
	sta     (sp),y
	lda     #$11
	ldy     #$00
	sta     (sp),y
	ldx     #$23
	lda     #$2A
	jsr     _multi_vram_buffer_horz
;
; if (marker == 249) {
;
L12C5:	lda     _marker
	cmp     #$F9
	bne     L0780
;
; multi_vram_buffer_horz("   KOSARI CODE ACTIVATED  ", 0x1A, NTADR_A(0x03, 0x17));
;
	jsr     decsp3
	lda     #<(L0783)
	ldy     #$01
	sta     (sp),y
	iny
	lda     #>(L0783)
	sta     (sp),y
	lda     #$1A
	ldy     #$00
	sta     (sp),y
	ldx     #$22
	lda     #$E3
	jsr     _multi_vram_buffer_horz
;
; multi_vram_buffer_horz("                 ", 0x11, NTADR_A(0x0B, 0x19));
;
	jsr     decsp3
	lda     #<(L078D)
	ldy     #$01
	sta     (sp),y
	iny
	lda     #>(L078D)
	sta     (sp),y
	lda     #$11
	ldy     #$00
	sta     (sp),y
	ldx     #$23
	lda     #$2B
	jsr     _multi_vram_buffer_horz
;
; sfx_play(SND_MENU_START, 0);
;
	lda     #$01
	jsr     pusha
	lda     #$00
	jsr     _sfx_play
;
; points = 99;
;
	lda     #$63
	sta     _points
;
; }
;
L0780:	rts

.endproc

; ---------------------------------------------------------------
; void __near__ process_title (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_process_title: near

.segment	"CODE"

;
; title_draw_background();
;
	jsr     _title_draw_background
;
; title_draw_menu();
;
	jsr     _title_draw_menu
;
; music_play(MSC_MENU);
;
	lda     #$00
	jsr     _music_play
;
; x = state = 0;
;
	lda     #$00
	sta     _state
	sta     _x
;
; y = 0x15;
;
	lda     #$15
	sta     _y
;
; nmi_wait_and_prepare();
;
L0523:	jsr     _nmi_wait_and_prepare
;
; oam_clear();
;
	jsr     _oam_clear
;
; for(tmp = 0x00; tmp != LOGO_TILE_COUNT * 4; tmp += 4) {
;
	lda     #$00
L12D9:	sta     _tmp
	cmp     #$7C
	beq     L12DD
;
; oam_spr(LOGO[tmp] + LOGO_X_OFFSET, LOGO[tmp + 1] + LOGO_Y_OFFSET, LOGO[tmp + 2], LOGO[tmp + 3]);
;
	jsr     decsp3
	ldy     _tmp
	lda     _LOGO,y
	clc
	adc     #$48
	ldy     #$02
	sta     (sp),y
	ldx     #$00
	lda     _tmp
	clc
	adc     #$01
	bcc     L0539
	inx
L0539:	sta     ptr1
	txa
	clc
	adc     #>(_LOGO)
	sta     ptr1+1
	ldy     #<(_LOGO)
	lda     (ptr1),y
	clc
	adc     #$19
	ldy     #$01
	sta     (sp),y
	ldx     #$00
	lda     _tmp
	clc
	adc     #$02
	bcc     L053D
	inx
L053D:	sta     ptr1
	txa
	clc
	adc     #>(_LOGO)
	sta     ptr1+1
	ldy     #<(_LOGO)
	lda     (ptr1),y
	ldy     #$00
	sta     (sp),y
	ldx     #$00
	lda     _tmp
	clc
	adc     #$03
	bcc     L0540
	inx
L0540:	sta     ptr1
	txa
	clc
	adc     #>(_LOGO)
	sta     ptr1+1
	ldy     #<(_LOGO)
	lda     (ptr1),y
	jsr     _oam_spr
;
; for(tmp = 0x00; tmp != LOGO_TILE_COUNT * 4; tmp += 4) {
;
	lda     #$04
	clc
	adc     _tmp
	jmp     L12D9
;
; ++x;
;
L12DD:	inc     _x
;
; if (x == 0x06) { 
;
	lda     _x
	cmp     #$06
	bne     L12DF
;
; x = 0;
;
	lda     #$00
	sta     _x
;
; if (state == 0) {
;
	lda     _state
	bne     L12DE
;
; ++y;
;
	inc     _y
;
; if (y == 0x18) state = 1;
;
	lda     _y
	cmp     #$18
	bne     L12DF
	lda     #$01
;
; } else {
;
	jmp     L12DA
;
; --y;
;
L12DE:	dec     _y
;
; if (y == 0x15) state = 0;
;
	lda     _y
	cmp     #$15
	bne     L12DF
	lda     #$00
L12DA:	sta     _state
;
; if (state == 0) oam_spr(game.state == GAME_ST_MENU ? 0x5E : 0x3C, 0x77 + (menu_position * 0x10), y, 0b00000001);
;
L12DF:	lda     _state
	bne     L0553
	jsr     decsp3
	lda     _game+3
	bne     L12E0
	lda     #$5E
	jmp     L12E1
L12E0:	lda     #$3C
L12E1:	ldy     #$02
	sta     (sp),y
	lda     _index
	asl     a
	asl     a
	asl     a
	asl     a
	clc
	adc     #$77
	dey
	sta     (sp),y
	lda     _y
	dey
	sta     (sp),y
	lda     #$01
;
; else oam_spr(game.state == GAME_ST_MENU ? 0x5E : 0x3C, 0x76 + (menu_position * 0x10), y, 0b10000001);
;
	jmp     L12DB
L0553:	jsr     decsp3
	lda     _game+3
	bne     L12E2
	lda     #$5E
	jmp     L12E3
L12E2:	lda     #$3C
L12E3:	ldy     #$02
	sta     (sp),y
	lda     _index
	asl     a
	asl     a
	asl     a
	asl     a
	clc
	adc     #$76
	dey
	sta     (sp),y
	lda     _y
	dey
	sta     (sp),y
	lda     #$81
L12DB:	jsr     _oam_spr
;
; if (game.state == GAME_ST_MENU) title_check_cheat_code();
;
	lda     _game+3
	bne     L12E4
	jsr     _title_check_cheat_code
;
; if (pad1_new & PAD_DOWN || pad1_new & PAD_UP) {
;
L12E4:	lda     _pad1_new
	and     #$04
	bne     L12E5
	lda     _pad1_new
	and     #$08
	beq     L12EE
;
; sfx_play(SND_MENU_MOVE, 0);
;
L12E5:	lda     #$00
	jsr     pusha
	jsr     _sfx_play
;
; menu_items = game.state == GAME_ST_MENU ? 1 : 3;
;
	lda     _game+3
	bne     L12E6
	lda     #$01
	jmp     L12E7
L12E6:	lda     #$03
L12E7:	sta     _tmp
;
; if (pad1_new & PAD_DOWN) menu_position = menu_position == menu_items ? 0 : ++menu_position;
;
	lda     _pad1_new
	and     #$04
	beq     L12EA
	lda     _tmp
	cmp     _index
	bne     L12E8
	lda     #$00
	jmp     L12E9
L12E8:	inc     _index
	lda     _index
L12E9:	sta     _index
;
; if (pad1_new & PAD_UP) menu_position = menu_position == 0 ? menu_items : --menu_position;
;
L12EA:	lda     _pad1_new
	and     #$08
	beq     L12EE
	lda     _index
	bne     L12EB
	lda     _tmp
	jmp     L12ED
L12EB:	dec     _index
	lda     _index
L12ED:	sta     _index
;
; if (pad1_new & PAD_START) {
;
L12EE:	lda     _pad1_new
	and     #$10
	jeq     L0523
;
; switch (game.state) {
;
	lda     _game+3
;
; }
;
	beq     L12EF
	cmp     #$04
	jeq     L12F5
	jmp     L0523
;
; switch (menu_position) {
;
L12EF:	lda     _index
;
; }
;
	beq     L12F1
	cmp     #$01
	beq     L12F4
	jmp     L12F5
;
; x = y = state = 0;
;
L12F1:	sta     _state
	sta     _y
	sta     _x
;
; music_stop();
;
	jsr     _music_stop
;
; sfx_play(SND_MENU_START, 0);
;
	lda     #$01
	jsr     pusha
	lda     #$00
	jsr     _sfx_play
;
; ppu_wait_nmi();
;
L059F:	jsr     _ppu_wait_nmi
;
; clear_vram_buffer();
;
	jsr     _clear_vram_buffer
;
; ++x;
;
	inc     _x
;
; if (x == 3) {
;
	lda     _x
	cmp     #$03
	bne     L059F
;
; multi_vram_buffer_horz(state == 0 ? "START" : "     ", 0x05, NTADR_A(0x0D,0x0F));
;
	jsr     decsp3
	lda     _state
	bne     L05AB
	lda     #<(L05AA)
	ldx     #>(L05AA)
	jmp     L05AE
L05AB:	lda     #<(L05AD)
	ldx     #>(L05AD)
L05AE:	ldy     #$01
	sta     (sp),y
	iny
	txa
	sta     (sp),y
	lda     #$05
	ldy     #$00
	sta     (sp),y
	ldx     #$21
	lda     #$ED
	jsr     _multi_vram_buffer_horz
;
; state = state == 0 ? 1 : 0;
;
	lda     _state
	bne     L12F2
	lda     #$01
	jmp     L12F3
L12F2:	lda     #$00
L12F3:	sta     _state
;
; x = 0;
;
	lda     #$00
	sta     _x
;
; ++y;
;
	inc     _y
;
; if (y == 0x12) return;
;
	lda     _y
	cmp     #$12
	bne     L059F
	rts
;
; game.state = GAME_ST_OPTIONS;
;
L12F4:	lda     #$04
	sta     _game+3
;
; menu_position = 0;
;
	lda     #$00
	sta     _index
;
; title_draw_menu();
;
	jsr     _title_draw_menu
;
; switch (menu_position) {
;
L12F5:	lda     _index
;
; }
;
	beq     L12F6
	cmp     #$01
	beq     L12F9
	cmp     #$02
	beq     L12FC
	cmp     #$03
	beq     L12FF
	jmp     L0523
;
; game.difficulty = game.difficulty == 2 ? 0 : ++game.difficulty;
;
L12F6:	lda     _game+6
	cmp     #$02
	bne     L12F7
	lda     #$00
	jmp     L12F8
L12F7:	inc     _game+6
	lda     _game+6
L12F8:	sta     _game+6
;
; title_draw_options();
;
	jsr     _title_draw_options
;
; break;
;
	jmp     L0523
;
; game.last_level = game.last_level == GAME_MAX_LEVEL ? 0 : GAME_MAX_LEVEL; 
;
L12F9:	lda     _game+1
	cmp     #$0C
	bne     L12FA
	lda     #$00
	jmp     L12FB
L12FA:	lda     #$0C
L12FB:	sta     _game+1
;
; title_draw_options();
;
	jsr     _title_draw_options
;
; break; 
;
	jmp     L0523
;
; game.effects.lightning_enabled = game.effects.lightning_enabled == 0 ? 1 : 0; 
;
L12FC:	lda     _game+9
	bne     L12FD
	lda     #$01
	jmp     L12FE
L12FD:	lda     #$00
L12FE:	sta     _game+9
;
; title_draw_options();
;
	jsr     _title_draw_options
;
; break;
;
	jmp     L0523
;
; game.state = GAME_ST_MENU;
;
L12FF:	lda     #$00
	sta     _game+3
;
; menu_position = 0;
;
	sta     _index
;
; title_draw_menu();
;
	jsr     _title_draw_menu
;
; break;
;
	jmp     L0523

.endproc

; ---------------------------------------------------------------
; void __near__ process_upgrades (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_process_upgrades: near

.segment	"CODE"

;
; upgrade_draw_background();
;
	jsr     _upgrade_draw_background
;
; upgrade_show_ablity_desc();
;
	jsr     _upgrade_show_ablity_desc
;
; nmi_wait_and_prepare();
;
L0E33:	jsr     _nmi_wait_and_prepare
;
; upgrade_draw_sprites();
;
	jsr     _upgrade_draw_sprites
;
; upgrade_movement_and_actions();
;
	jsr     _upgrade_movement_and_actions
;
; if (state == 1) break;
;
	lda     _state
	cmp     #$01
	bne     L0E33
	rts

.endproc

; ---------------------------------------------------------------
; void __near__ process_main_game (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_process_main_game: near

.segment	"CODE"

;
; game_process_next_level();
;
L07E7:	jsr     _game_process_next_level
;
; game_draw_background();
;
	jsr     _game_draw_background
;
; game_draw_points();
;
	jsr     _game_draw_points
;
; game_draw_time();
;
	jsr     _game_draw_time
;
; nmi_wait_and_prepare();
;
L07EF:	jsr     _nmi_wait_and_prepare
;
; if (game.paused == GAME_UNPAUSED) {
;
	lda     _game+2
	jne     L1308
;
; game_small_scythe_processing();
;
	jsr     _game_small_scythe_processing
;
; game_draw_sprites();
;
	jsr     _game_draw_sprites
;
; game_enemy_processing();
;
	jsr     _game_enemy_processing
;
; game_draw_rain();
;
	jsr     _game_draw_rain
;
; game_draw_effects();
;
	jsr     _game_draw_effects
;
; if (game.state == GAME_ST_LEVEL_LOSE) {
;
	lda     _game+3
	cmp     #$04
	bne     L1302
;
; game_grass_overgrow();
;
	jsr     _game_grass_overgrow
;
; if (game.state == GAME_ST_LEVEL_END_LOSE) break;
;
	lda     _game+3
	cmp     #$05
	bne     L07EF
	jmp     L07F0
;
; if (game.state == GAME_ST_LEVEL_WIN) {
;
L1302:	lda     _game+3
	cmp     #$02
	bne     L0801
;
; game_grass_fading();
;
	jsr     _game_grass_fading
;
; if (game.state == GAME_ST_LEVEL_END_WIN) break;
;
	lda     _game+3
	cmp     #$03
	bne     L07EF
	jmp     L07F0
;
; game_movement_and_actions();
;
L0801:	jsr     _game_movement_and_actions
;
; game_grass_grow();
;
	jsr     _game_grass_grow
;
; ++frame_tick;
;
	inc     _frame_tick
;
; if (frame_tick == FRAME_COUNT_SEC) {
;
	lda     _frame_tick
	cmp     #$3C
	jne     L1307
;
; frame_tick = 0;
;
	lda     #$00
	sta     _frame_tick
;
; --game.play_time;
;
	dec     _game+4
;
; if (game.play_time == 0) {
;
	lda     _game+4
	bne     L1303
;
; sfx_play(SND_GAME_WIN, 0);
;
	lda     #$08
	jsr     pusha
	lda     #$00
	jsr     _sfx_play
;
; game.state = GAME_ST_LEVEL_WIN;
;
	lda     #$02
	sta     _game+3
;
; adr = 0;
;
	lda     #$00
	sta     _adr
	sta     _adr+1
;
; } else {
;
	jmp     L0828
;
; if ((game.max_play_time - game.play_time) % 0x0A == 0) game.effects.lightning = 1;
;
L1303:	lda     _game+5
	sec
	sbc     _game+4
	jsr     pusha0
	lda     #$0A
	jsr     tosumoda0
	cpx     #$00
	bne     L0819
	cmp     #$00
	bne     L0819
	lda     #$01
	sta     _game+8
;
; if ((game.max_play_time - game.play_time) % 0x0E == 0) game.effects.wind = 1;
;
L0819:	lda     _game+5
	sec
	sbc     _game+4
	jsr     pusha0
	lda     #$0E
	jsr     tosumoda0
	cpx     #$00
	bne     L081F
	cmp     #$00
	bne     L081F
	lda     #$01
	sta     _game+10
;
; tmp = 1;
;
L081F:	lda     #$01
	sta     _tmp
;
; for (x = 0; x < BIRDS_COUNT; ++x) {
;
	lda     #$00
	sta     _x
L1304:	lda     _x
	cmp     #$04
	bcs     L0828
;
; if (bird_state[x] == 0) {
;
	ldy     _x
	lda     _bird_state,y
	bne     L1306
;
; if (game.level > 8) tmp = rand8() % 0x01;
;
	lda     _game
	cmp     #$09
	bcc     L1305
	jsr     _rand8
	lda     #$00
;
; else if (game.level > 5) tmp = rand8() % 0x02;
;
	jmp     L1301
L1305:	lda     _game
	cmp     #$06
	bcc     L0838
	jsr     _rand8
	and     #$01
;
; else tmp = rand8() % 0x03;
;
	jmp     L1301
L0838:	jsr     _rand8
	jsr     pushax
	lda     #$03
	jsr     tosumoda0
L1301:	sta     _tmp
;
; if (tmp == 0) game_create_enemy(x);
;
	lda     _tmp
	bne     L0828
	lda     _x
	jsr     _game_create_enemy
;
; break;
;
	jmp     L0828
;
; for (x = 0; x < BIRDS_COUNT; ++x) {
;
L1306:	inc     _x
	jmp     L1304
;
; game_draw_time();
;
L0828:	jsr     _game_draw_time
;
; if (pad1_new & PAD_START) game.paused = GAME_PAUSED;
;
L1307:	lda     _pad1_new
	and     #$10
	jeq     L07EF
	lda     #$01
	sta     _game+2
;
; } else {
;
	jmp     L07EF
;
; if (pad1_new & PAD_START) game.paused = GAME_UNPAUSED;
;
L1308:	lda     _pad1_new
	and     #$10
	jeq     L07EF
	lda     #$00
	sta     _game+2
;
; while(1) {
;
	jmp     L07EF
;
; clear_vram_buffer();
;
L07F0:	jsr     _clear_vram_buffer
;
; if (game.lives == 0x00 || game.level == game.last_level) break;
;
	lda     _game+7
	beq     L1309
	lda     _game+1
	cmp     _game
	bne     L084E
L1309:	rts
;
; else process_upgrades();
;
L084E:	jsr     _process_upgrades
;
; while(1) {
;
	jmp     L07E7

.endproc

; ---------------------------------------------------------------
; void __near__ process_end_game_string_print (unsigned char, unsigned char, __near__ const unsigned char *, unsigned char)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_process_end_game_string_print: near

.segment	"CODE"

;
; void process_end_game_string_print(unsigned char xpos, unsigned char ypos, const char *str, unsigned char extra_blank) {
;
	jsr     pusha
;
; unsigned char npos = 0;
;
	lda     #$00
	jsr     pusha
;
; if (tmp == 0) {
;
	lda     _tmp
	jne     L130D
;
; if (index == 0) {
;
	lda     _index
	bne     L130A
;
; multi_vram_buffer_horz("                                ", 0x20, NTADR_A(0, ypos));
;
	jsr     decsp3
	lda     #<(L103B)
	ldy     #$01
	sta     (sp),y
	iny
	lda     #>(L103B)
	sta     (sp),y
	lda     #$20
	ldy     #$00
	sta     (sp),y
	ldy     #$07
	ldx     #$00
	lda     (sp),y
	jsr     aslax4
	stx     tmp1
	asl     a
	rol     tmp1
	pha
	lda     tmp1
	ora     #$20
	tax
	pla
	jsr     _multi_vram_buffer_horz
;
; if (extra_blank != 0)
;
	ldy     #$01
	lda     (sp),y
	beq     L130A
;
; multi_vram_buffer_horz("                                ", 0x20, NTADR_A(0, extra_blank));
;
	jsr     decsp3
	lda     #<(L1047)
	sta     (sp),y
	iny
	lda     #>(L1047)
	sta     (sp),y
	lda     #$20
	ldy     #$00
	sta     (sp),y
	ldy     #$04
	ldx     #$00
	lda     (sp),y
	jsr     aslax4
	stx     tmp1
	asl     a
	rol     tmp1
	pha
	lda     tmp1
	ora     #$20
	tax
	pla
	jsr     _multi_vram_buffer_horz
;
; if (state == EG_PRINT_DELAY) {
;
L130A:	lda     _state
	cmp     #$05
	jne     L130C
;
; state = 0;
;
	lda     #$00
	sta     _state
;
; for (y = 0; y < index; ++y) {
;
	sta     _y
L130B:	lda     _y
	cmp     _index
	bcs     L1055
;
; *str++;
;
	ldy     #$03
	lda     (sp),y
	tax
	dey
	lda     (sp),y
	clc
	adc     #$01
	bcc     L105D
	inx
L105D:	jsr     staxysp
;
; ++xpos;
;
	ldy     #$05
	clc
	lda     #$01
	adc     (sp),y
	sta     (sp),y
;
; for (y = 0; y < index; ++y) {
;
	inc     _y
	jmp     L130B
;
; if (!*str) {
;
L1055:	ldy     #$03
	lda     (sp),y
	sta     ptr1+1
	dey
	lda     (sp),y
	sta     ptr1
	ldy     #$00
	lda     (ptr1),y
	bne     L105F
;
; ++marker;
;
	inc     _marker
;
; index = 0;
;
	sta     _index
;
; tmp = 60;
;
	lda     #$3C
	sta     _tmp
;
; } else {
;
	jmp     incsp6
;
; ++index;
;
L105F:	inc     _index
;
; one_vram_buffer(*str, NTADR_A(xpos, ypos));
;
	ldy     #$03
	lda     (sp),y
	sta     ptr1+1
	dey
	lda     (sp),y
	sta     ptr1
	ldy     #$00
	lda     (ptr1),y
	jsr     pusha
	ldy     #$05
	ldx     #$00
	lda     (sp),y
	jsr     aslax4
	stx     tmp1
	asl     a
	rol     tmp1
	sta     ptr1
	iny
	lda     (sp),y
	ora     ptr1
	pha
	lda     tmp1
	ora     #$20
	tax
	pla
	jsr     _one_vram_buffer
;
; } else {
;
	jmp     incsp6
;
; ++state;
;
L130C:	inc     _state
;
; } else {
;
	jmp     incsp6
;
; --tmp;
;
L130D:	dec     _tmp
;
; }
;
	jmp     incsp6

.endproc

; ---------------------------------------------------------------
; void __near__ process_game_win (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_process_game_win: near

.segment	"CODE"

;
; fade_in();
;
	jsr     _fade_in
;
; ppu_off();
;
	jsr     _ppu_off
;
; vram_adr(NAMETABLE_A + 0x20 * 0x1C);
;
	ldx     #$23
	lda     #$80
	jsr     _vram_adr
;
; for (x = 0x00; x != 0x20; ++x) vram_put(CHR_BG_BLANK);
;
	lda     #$00
	sta     _x
L130F:	lda     _x
	cmp     #$20
	beq     L107A
	lda     #$7F
	jsr     _vram_put
	inc     _x
	jmp     L130F
;
; ppu_on_all();
;
L107A:	jsr     _ppu_on_all
;
; music_play(MSC_GAME_WIN);
;
	lda     #$01
	jsr     _music_play
;
; fade_out();
;
	jsr     _fade_out
;
; x = 1;
;
	lda     #$01
	sta     _x
;
; player.x = 50;
;
	lda     #$32
	sta     _player
;
; player.y = PLAYER_DEF_Y;
;
	lda     #$8C
	sta     _player+1
;
; index = 0;
;
	lda     #$00
	sta     _index
;
; state = 0;
;
	sta     _state
;
; marker = 0;
;
	sta     _marker
;
; tmp = 200;
;
	lda     #$C8
	sta     _tmp
;
; nmi_wait_and_prepare();
;
L1095:	jsr     _nmi_wait_and_prepare
;
; oam_clear();
;
	jsr     _oam_clear
;
; oam_meta_spr(player.x, player.y, x == 1 ? OTM_R : OTM_L);
;
	jsr     decsp2
	lda     _player
	ldy     #$01
	sta     (sp),y
	lda     _player+1
	dey
	sta     (sp),y
	lda     _x
	cmp     #$01
	bne     L109F
	lda     #<(_OTM_R)
	ldx     #>(_OTM_R)
	jmp     L10A1
L109F:	lda     #<(_OTM_L)
	ldx     #>(_OTM_L)
L10A1:	jsr     _oam_meta_spr
;
; player.x += x;
;
	lda     _x
	clc
	adc     _player
	sta     _player
;
; if (player.x > 180) x = -1;
;
	cmp     #$B5
	bcc     L1310
	lda     #$FF
	sta     _x
;
; if (player.x < 50) x = 1;
;
L1310:	lda     _player
	cmp     #$32
	bcs     L1311
	lda     #$01
	sta     _x
;
; if (marker < 0x0A) {
;
L1311:	lda     _marker
	cmp     #$0A
	jcs     L1315
;
; if (tmp < 5 && marker == 0) {
;
	lda     _tmp
	cmp     #$05
	bcs     L1314
	lda     _marker
	bne     L1314
;
; multi_vram_buffer_horz("                                ", 0x20, NTADR_A(0, 0x09 + tmp));
;
	jsr     decsp3
	lda     #<(L10B4)
	ldy     #$01
	sta     (sp),y
	iny
	lda     #>(L10B4)
	sta     (sp),y
	lda     #$20
	ldy     #$00
	sta     (sp),y
	ldx     #$00
	lda     _tmp
	clc
	adc     #$09
	bcc     L10BC
	inx
L10BC:	jsr     shlax4
	stx     tmp1
	asl     a
	rol     tmp1
	pha
	lda     tmp1
	ora     #$20
	tax
	pla
	jsr     _multi_vram_buffer_horz
;
; switch (marker) {
;
L1314:	lda     _marker
;
; }
;
	beq     L10C2
	cmp     #$01
	beq     L10CA
	cmp     #$02
	beq     L10D2
	cmp     #$03
	jeq     L10DA
	cmp     #$04
	jeq     L10E2
	cmp     #$05
	jeq     L10EA
	cmp     #$06
	jeq     L10F2
	cmp     #$07
	jeq     L10FA
	cmp     #$08
	jeq     L1102
	cmp     #$09
	jeq     L110A
	jmp     L1315
;
; case 0: process_end_game_string_print(0x09, 0x0B, "ONE THOUSAND MAN", 0); break;
;
L10C2:	jsr     decsp4
	lda     #$09
	ldy     #$03
	sta     (sp),y
	lda     #$0B
	dey
	sta     (sp),y
	lda     #<(L10C6)
	ldy     #$00
	sta     (sp),y
	iny
	lda     #>(L10C6)
	jmp     L1317
;
; case 1: process_end_game_string_print(0x09, 0x0A, "GAME CREATED BY", 0x0B); break;
;
L10CA:	jsr     decsp4
	lda     #$09
	ldy     #$03
	sta     (sp),y
	lda     #$0A
	dey
	sta     (sp),y
	lda     #<(L10CE)
	ldy     #$00
	sta     (sp),y
	iny
	lda     #>(L10CE)
	sta     (sp),y
	lda     #$0B
	jmp     L130E
;
; case 2: process_end_game_string_print(0x0A, 0x0C, "SPERLINGSKAUZ", 0); break;
;
L10D2:	jsr     decsp4
	lda     #$0A
	ldy     #$03
	sta     (sp),y
	lda     #$0C
	dey
	sta     (sp),y
	lda     #<(L10D6)
	ldy     #$00
	sta     (sp),y
	iny
	lda     #>(L10D6)
	jmp     L1317
;
; case 3: process_end_game_string_print(0x08, 0x0A, "ORIGINAL COMICS BY", 0x0C); break;
;
L10DA:	jsr     decsp4
	lda     #$08
	ldy     #$03
	sta     (sp),y
	lda     #$0A
	dey
	sta     (sp),y
	lda     #<(L10DE)
	ldy     #$00
	sta     (sp),y
	iny
	lda     #>(L10DE)
	sta     (sp),y
	lda     #$0C
	jmp     L130E
;
; case 4: process_end_game_string_print(0x0A, 0x0C, "CYNIC MANSION", 0); break;
;
L10E2:	jsr     decsp4
	lda     #$0A
	ldy     #$03
	sta     (sp),y
	lda     #$0C
	dey
	sta     (sp),y
	lda     #<(L10E6)
	ldy     #$00
	sta     (sp),y
	iny
	lda     #>(L10E6)
	jmp     L1317
;
; case 5: process_end_game_string_print(0x08, 0x0A, "SPECIAL THANKS TO", 0x0C); break;
;
L10EA:	jsr     decsp4
	lda     #$08
	ldy     #$03
	sta     (sp),y
	lda     #$0A
	dey
	sta     (sp),y
	lda     #<(L10EE)
	ldy     #$00
	sta     (sp),y
	iny
	lda     #>(L10EE)
	sta     (sp),y
	lda     #$0C
	jmp     L130E
;
; case 6: process_end_game_string_print(0x0E, 0x0C, "SHIRU", 0); break;
;
L10F2:	jsr     decsp4
	lda     #$0E
	ldy     #$03
	sta     (sp),y
	lda     #$0C
	dey
	sta     (sp),y
	lda     #<(L10F6)
	ldy     #$00
	sta     (sp),y
	iny
	lda     #>(L10F6)
	jmp     L1317
;
; case 7: process_end_game_string_print(0x0D, 0x0C, "NESDOUG", 0); break;
;
L10FA:	jsr     decsp4
	lda     #$0D
	ldy     #$03
	sta     (sp),y
	lda     #$0C
	dey
	sta     (sp),y
	lda     #<(L10FE)
	ldy     #$00
	sta     (sp),y
	iny
	lda     #>(L10FE)
	jmp     L1317
;
; case 8: process_end_game_string_print(0x06, 0x0A, " ", 0x0C); break;
;
L1102:	jsr     decsp4
	lda     #$06
	ldy     #$03
	sta     (sp),y
	lda     #$0A
	dey
	sta     (sp),y
	lda     #<(L1106)
	ldy     #$00
	sta     (sp),y
	iny
	lda     #>(L1106)
	sta     (sp),y
	lda     #$0C
	jmp     L130E
;
; case 9: process_end_game_string_print(0x06, 0x0B, "THANK YOU FOR PLAYING!", 0); break;
;
L110A:	jsr     decsp4
	lda     #$06
	ldy     #$03
	sta     (sp),y
	lda     #$0B
	dey
	sta     (sp),y
	lda     #<(L110E)
	ldy     #$00
	sta     (sp),y
	iny
	lda     #>(L110E)
L1317:	sta     (sp),y
	lda     #$00
L130E:	jsr     _process_end_game_string_print
;
; if (pad1_new & PAD_START) break;
;
L1315:	lda     _pad1_new
	and     #$10
	jeq     L1095
	jmp     _music_stop

.endproc

; ---------------------------------------------------------------
; void __near__ process_game_end (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_process_game_end: near

.segment	"CODE"

;
; if (game.state == GAME_ST_LEVEL_END_WIN) process_game_win();
;
	lda     _game+3
	cmp     #$03
	bne     L1115
	jsr     _process_game_win
;
; pal_bg(game_palette_bg);
;
L1115:	lda     #<(_game_palette_bg)
	ldx     #>(_game_palette_bg)
	jsr     _pal_bg
;
; pal_spr(game_palette_sp);
;
	lda     #<(_game_palette_sp)
	ldx     #>(_game_palette_sp)
	jsr     _pal_spr
;
; fade_in();
;
	jsr     _fade_in
;
; ppu_off();
;
	jsr     _ppu_off
;
; vram_adr(PPU_PALLETE);
;
	ldx     #$23
	lda     #$C0
	jsr     _vram_adr
;
; for (x = 0x00; x != 0x40; ++x) vram_put(0);
;
	lda     #$00
	sta     _x
L1318:	lda     _x
	cmp     #$40
	beq     L1121
	lda     #$00
	jsr     _vram_put
	inc     _x
	jmp     L1318
;
; vram_adr(NAMETABLE_A);
;
L1121:	ldx     #$20
	lda     #$00
	jsr     _vram_adr
;
; for (x = 0x00; x != 0x20; ++x) 
;
	lda     #$00
	sta     _x
L1319:	lda     _x
	cmp     #$20
	beq     L112D
;
; for(y = 0x00; y != 0x1D; ++y) 
;
	lda     #$00
	sta     _y
L131A:	lda     _y
	cmp     #$1D
	beq     L131B
;
; vram_put(CHR_BG_BLANK);
;
	lda     #$7F
	jsr     _vram_put
;
; for(y = 0x00; y != 0x1D; ++y) 
;
	inc     _y
	jmp     L131A
;
; for (x = 0x00; x != 0x20; ++x) 
;
L131B:	inc     _x
	jmp     L1319
;
; put_str(NTADR_A(0x0B, 0x0B), "GAME OVER");
;
L112D:	ldx     #$21
	lda     #$6B
	jsr     pushax
	lda     #<(L1145)
	ldx     #>(L1145)
	jsr     _put_str
;
; put_str(NTADR_A(0x05, 0x10), "PRESS START TO RETURN");
;
	ldx     #$22
	lda     #$05
	jsr     pushax
	lda     #<(L114E)
	ldx     #>(L114E)
	jsr     _put_str
;
; put_str(NTADR_A(0x09, 0x11), "TO MAIN MENU");
;
	ldx     #$22
	lda     #$29
	jsr     pushax
	lda     #<(L1157)
	ldx     #>(L1157)
	jsr     _put_str
;
; put_str(NTADR_A(0x06, 0x0D), "FINAL SCORE");
;
	ldx     #$21
	lda     #$A6
	jsr     pushax
	lda     #<(L1160)
	ldx     #>(L1160)
	jsr     _put_str
;
; put_number(NTADR_A(0x11, 0x0D), score, 2);
;
	jsr     decsp4
	lda     #$B1
	ldy     #$02
	sta     (sp),y
	iny
	lda     #$21
	sta     (sp),y
	lda     _score
	ldy     #$00
	sta     (sp),y
	iny
	lda     _score+1
	sta     (sp),y
	lda     #$02
	jsr     _put_number
;
; ppu_on_all();
;
	jsr     _ppu_on_all
;
; oam_clear();
;
	jsr     _oam_clear
;
; fade_out();
;
	jsr     _fade_out
;
; nmi_wait_and_prepare();
;
L116E:	jsr     _nmi_wait_and_prepare
;
; if (pad1_new & PAD_START) break;
;
	lda     _pad1_new
	and     #$10
	beq     L116E
;
; game.state = GAME_ST_MENU;
;
	lda     #$00
	sta     _game+3
;
; fade_in();
;
	jsr     _fade_in
;
; ppu_off();
;
	jsr     _ppu_off
;
; vram_adr(NAMETABLE_A + SCREEN_TILES_X * 0x0B + 0x0B);
;
	ldx     #$21
	lda     #$6B
	jsr     _vram_adr
;
; for(x = 0x00; x != 0x09; ++x) vram_put(CHR_BG_BLANK);
;
	lda     #$00
	sta     _x
L131D:	lda     _x
	cmp     #$09
	beq     L117C
	lda     #$7F
	jsr     _vram_put
	inc     _x
	jmp     L131D
;
; ppu_on_all();
;
L117C:	jsr     _ppu_on_all
;
; fade_out();
;
	jmp     _fade_out

.endproc

; ---------------------------------------------------------------
; void __near__ set_bg_pallete (__near__ const unsigned char *)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_set_bg_pallete: near

.segment	"CODE"

;
; void set_bg_pallete(const char *pallete) {
;
	jsr     pushax
;
; vram_adr(PPU_PALLETE);
;
	ldx     #$23
	lda     #$C0
	jsr     _vram_adr
;
; for(x = 0x00; x != 0x40; ++x) {
;
	lda     #$00
	sta     _x
L131F:	lda     _x
	cmp     #$40
	beq     L050F
;
; vram_put(pallete[x]);
;
	ldy     #$01
	lda     (sp),y
	tax
	dey
	lda     (sp),y
	ldy     _x
	sta     ptr1
	stx     ptr1+1
	lda     (ptr1),y
	jsr     _vram_put
;
; for(x = 0x00; x != 0x40; ++x) {
;
	inc     _x
	jmp     L131F
;
; }
;
L050F:	jmp     incsp2

.endproc

; ---------------------------------------------------------------
; void __near__ main (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_main: near

.segment	"CODE"

;
; game_initial_values_set();
;
L1188:	jsr     _game_initial_values_set
;
; process_title();
;
	jsr     _process_title
;
; if (points == 99) process_upgrades();
;
	lda     _points
	cmp     #$63
	bne     L118E
	jsr     _process_upgrades
;
; process_main_game();
;
L118E:	jsr     _process_main_game
;
; process_game_end();
;
	jsr     _process_game_end
;
; while (1) {
;
	jmp     L1188

.endproc

